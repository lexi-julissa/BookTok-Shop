
/*  ## Emitted on: Wed Mar 13 13:46:34 2024  (0.368248712361918)## */
//provides com.liquidpixels.copyright
//EOResources

// ---------------------------------------------------------------------------
//    Copyright (c) 2013, LiquidPixels, Incorporated. All Rights Reserved.
//
//    This file represents Intellectual Property which is proprietary and
//  confidential to LiquidPixels, Incorporated. Any disclosure, in whole
//  or in part, is prohibited without express written permission.
//
//   $Id: copyright.js 9272 2015-07-20 16:08:04Z ecirone $
// ---------------------------------------------------------------------------

// ----------------------------
// Portions of this file include:
// org.prototypejs.prototype

/*  Prototype JavaScript framework, version 1.6.0.1
 *  (c) 2005-2007 Sam Stephenson
 *
 *  Prototype is freely distributable under the terms of an MIT-style license.
 *  For details, see the Prototype web site: http://www.prototypejs.org/
 */

// ----------------------------
// Portions of this file may include:
// us.aculo.scriptaculous.Scriptaculous

// script.aculo.us scriptaculous.js v1.8.1, Thu Jan 03 22:07:12 -0500 2008
// Copyright (c) 2005-2007 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)

// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// For details, see the script.aculo.us web site: http://script.aculo.us/
// ----------------------------

// All other code:
//  Copyright (c) 2013, LiquidPixels, Incorporated. All Rights Reserved.


/**
 * JustGage - a handy JavaScript plugin for generating and animating nice & clean dashboard gauges.
 * Copyright (c) 2012 Bojan Djuricic - pindjur(at)gmail(dot)com | http://www.madcog.com
 * Licensed under MIT.
 * Date: 31/07/2012
 * @author Bojan Djuricic  (@Toorshia)
 * @version 1.0
 *
 * http://www.justgage.com
 */

/**
 ** More info at http://www.opentip.org
 **
 ** Copyright (c) 2009, Matias Meno
 ** Graphics by Tjandra Mayerhold
 **
 ** Permission is hereby granted, free of charge, to any person obtaining a copy
 ** of this software and associated documentation files (the "Software"), to deal
 ** in the Software without restriction, including without limitation the rights
 ** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 ** copies of the Software, and to permit persons to whom the Software is
 ** furnished to do so, subject to the following conditions:
 **
 ** The above copyright notice and this permission notice shall be included in
 ** all copies or substantial portions of the Software.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 ** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 ** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 ** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 ** THE SOFTWARE.
 **
 **/

/*!
 * verge 1.9.1+201402130803
 * https://github.com/ryanve/verge
 * MIT License 2013 Ryan Van Etten
 */

 /*
  * Cookies.js - 1.2.1
  * https://github.com/ScottHamper/Cookies
  *
  * This is free and unencumbered software released into the public domain.
  */


if(!window.com) {window.com = {}};
if(!com.liquidpixels) {com.liquidpixels = {}};
if(!com.liquidpixels.wui) {com.liquidpixels.wui = {}};
if(!com.liquidpixels.viewers) {com.liquidpixels.viewers = {}};
if(!com.liquidpixels.viewers.shared) {com.liquidpixels.viewers.shared = {}};
if(!com.liquidpixels.utilities) {com.liquidpixels.utilities = {}};
if(!com.liquidpixels.utilities.Truth) {com.liquidpixels.utilities.Truth = {}};
if(!com.liquidpixels.utilities.DeepMerge) {com.liquidpixels.utilities.DeepMerge = {}};
if(!com.liquidpixels.application) {com.liquidpixels.application = {}};
if(!com.liquidpixels.application.Config) {com.liquidpixels.application.Config = {}};
if(!com.liquidpixels.utilities.Type) {com.liquidpixels.utilities.Type = {}};
if(!com.liquidpixels.query) {com.liquidpixels.query = {}};
if(!com.liquidpixels.event) {com.liquidpixels.event = {}};
if(!com.liquidpixels.event.EventDispatcher) {com.liquidpixels.event.EventDispatcher = {}};
if(!com.liquidpixels.utilities.CSSEasingFunctions) {com.liquidpixels.utilities.CSSEasingFunctions = {}};
if(!com.liquidpixels.consts) {com.liquidpixels.consts = {}};
if(!com.liquidpixels.consts.Style) {com.liquidpixels.consts.Style = {}};
if(!com.liquidpixels.liquifire) {com.liquidpixels.liquifire = {}};
if(!com.liquidpixels.ResourceServer) {com.liquidpixels.ResourceServer = {}};
if(!com.liquidpixels.ResourceServer.Flags) {com.liquidpixels.ResourceServer.Flags = {}};
if(!com.liquidpixels.zap) {com.liquidpixels.zap = {}};
if(!com.liquidpixels.zap.stitched) {com.liquidpixels.zap.stitched = {}};
if(!com.liquidpixels.wui.loader) {com.liquidpixels.wui.loader = {}};
if(!com.liquidpixels.zap.tiled) {com.liquidpixels.zap.tiled = {}};
if(!com.liquidpixels.event.EventManageable) {com.liquidpixels.event.EventManageable = {}};
if(!com.liquidpixels.ResourceServer.Loaded) {com.liquidpixels.ResourceServer.Loaded = {}};
if(!com.liquidpixels.ResourceServer.Loaded.script) {com.liquidpixels.ResourceServer.Loaded.script = {}};

if(!com.liquidpixels.ResourceServer.Flags['com.liquidpixels.viewers-html']) {com.liquidpixels.ResourceServer.Flags['com.liquidpixels.viewers-html'] = {}};
com.liquidpixels.ResourceServer.Flags['com.liquidpixels.viewers-html']['version'] = "2.1.9-1";

if(!com.liquidpixels.ResourceServer.Flags['com.liquidpixels.zap']) {com.liquidpixels.ResourceServer.Flags['com.liquidpixels.zap'] = {}};
com.liquidpixels.ResourceServer.Flags['com.liquidpixels.zap']['version'] = 1;

com.liquidpixels.ResourceServer.Loaded['script']['com.liquidpixels.Zoom'] = true;
com.liquidpixels.ResourceServer.Version = '%{LPI_VERSION}';


var Prototype = {
Version: '1.7.3',
Browser: (function () {
var ua = navigator.userAgent;
var isOpera = Object.prototype.toString.call(window.opera) == '[object Opera]';
return {
IE: !!window.attachEvent && !isOpera,
Opera: isOpera,
WebKit: ua.indexOf('AppleWebKit/') > -1,
Gecko: ua.indexOf('Gecko') > -1 && ua.indexOf('KHTML') === -1,
MobileSafari: /Apple.*Mobile/.test(ua)}
})(),
BrowserFeatures: {
XPath: !!document.evaluate,
XDomainRequest: !!window.XDomainRequest,
SelectorsAPI: !!document.querySelector,
ElementExtensions: (function () {
var constructor = window.Element || window.HTMLElement;
return !!(constructor && constructor.prototype);
})(),
SpecificElementExtensions: (function () {
if (typeof window.HTMLDivElement !== 'undefined')
return true;
var div = document.createElement('div'),
form = document.createElement('form'),
isSupported = false;
if (div['__proto__'] && (div['__proto__'] !== form['__proto__'])) {
isSupported = true;}
div = form = null;
return isSupported;
})()},
ScriptFragment: '<script[^>]*>([\\S\\s]*?)<\/script\\s*>',
JSONFilter: /^\/\*-secure-([\s\S]*)\*\/\s*$/,
emptyFunction: function () {},
K: function (x) { return x }};
if (Prototype.Browser.MobileSafari)
Prototype.BrowserFeatures.SpecificElementExtensions = false;
var Class = (function () {
var IS_DONTENUM_BUGGY = (function () {
for (var p in { toString: 1 }) {
if (p === 'toString') return false;}
return true;
})();
function subclass() {};
function create() {
var parent = null,
properties = $A(arguments);
if (Object.isFunction(properties[0]))
parent = properties.shift();
function klass() {
this.initialize.apply(this, arguments);}
Object.extend(klass, Class.Methods);
klass.superclass = parent;
klass.subclasses = [];
if (parent) {
subclass.prototype = parent.prototype;
klass.prototype = new subclass;
parent.subclasses.push(klass);}
for (var i = 0, length = properties.length; i < length; i++)
klass.addMethods(properties[i]);
if (!klass.prototype.initialize)
klass.prototype.initialize = Prototype.emptyFunction;
klass.prototype.constructor = klass;
return klass;}
function addMethods(source) {
var ancestor = this.superclass && this.superclass.prototype,
properties = Object.keys(source);
if (IS_DONTENUM_BUGGY) {
if (source.toString != Object.prototype.toString)
properties.push("toString");
if (source.valueOf != Object.prototype.valueOf)
properties.push("valueOf");}
for (var i = 0, length = properties.length; i < length; i++) {
var property = properties[i],
value = source[property];
if (ancestor && Object.isFunction(value) &&
value.argumentNames()[0] == "$super") {
var method = value;
value = (function (m) {
return function () { return ancestor[m].apply(this, arguments); };
})(property).wrap(method);
value.valueOf = (function (method) {
return function () { return method.valueOf.call(method); };
})(method);
value.toString = (function (method) {
return function () { return method.toString.call(method); };
})(method);}
this.prototype[property] = value;}
return this;}
return {
create: create,
Methods: {
addMethods: addMethods}};
})();
(function () {
var _toString = Object.prototype.toString,
_hasOwnProperty = Object.prototype.hasOwnProperty,
NULL_TYPE = 'Null',
UNDEFINED_TYPE = 'Undefined',
BOOLEAN_TYPE = 'Boolean',
NUMBER_TYPE = 'Number',
STRING_TYPE = 'String',
OBJECT_TYPE = 'Object',
FUNCTION_CLASS = '[object Function]',
BOOLEAN_CLASS = '[object Boolean]',
NUMBER_CLASS = '[object Number]',
STRING_CLASS = '[object String]',
ARRAY_CLASS = '[object Array]',
DATE_CLASS = '[object Date]',
NATIVE_JSON_STRINGIFY_SUPPORT = window.JSON &&
typeof JSON.stringify === 'function' &&
JSON.stringify(0) === '0' &&
typeof JSON.stringify(Prototype.K) === 'undefined';
var DONT_ENUMS = ['toString', 'toLocaleString', 'valueOf',
'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'
];
var IS_DONTENUM_BUGGY = (function () {
for (var p in { toString: 1 }) {
if (p === 'toString') return false;}
return true;
})();
function Type(o) {
switch (o) {
case null:
return NULL_TYPE;
case (void 0):
return UNDEFINED_TYPE;}
var type = typeof o;
switch (type) {
case 'boolean':
return BOOLEAN_TYPE;
case 'number':
return NUMBER_TYPE;
case 'string':
return STRING_TYPE;}
return OBJECT_TYPE;}
function extend(destination, source) {
for (var property in source)
destination[property] = source[property];
return destination;}
function inspect(object) {
try {
if (isUndefined(object)) return 'undefined';
if (object === null) return 'null';
return object.inspect ? object.inspect() : String(object);
} catch (e) {
if (e instanceof RangeError) return '...';
throw e;}}
function toJSON(value) {
return Str('', { '': value }, []);}
function Str(key, holder, stack) {
var value = holder[key];
if (Type(value) === OBJECT_TYPE && typeof value.toJSON === 'function') {
value = value.toJSON(key);}
var _class = _toString.call(value);
switch (_class) {
case NUMBER_CLASS:
case BOOLEAN_CLASS:
case STRING_CLASS:
value = value.valueOf();}
switch (value) {
case null:
return 'null';
case true:
return 'true';
case false:
return 'false';}
var type = typeof value;
switch (type) {
case 'string':
return value.inspect(true);
case 'number':
return isFinite(value) ? String(value) : 'null';
case 'object':
for (var i = 0, length = stack.length; i < length; i++) {
if (stack[i] === value) {
throw new TypeError("Cyclic reference to '" + value + "' in object");}}
stack.push(value);
var partial = [];
if (_class === ARRAY_CLASS) {
for (var i = 0, length = value.length; i < length; i++) {
var str = Str(i, value, stack);
partial.push(typeof str === 'undefined' ? 'null' : str);}
partial = '[' + partial.join(',') + ']';
} else {
var keys = Object.keys(value);
for (var i = 0, length = keys.length; i < length; i++) {
var key = keys[i],
str = Str(key, value, stack);
if (typeof str !== "undefined") {
partial.push(key.inspect(true) + ':' + str);}}
partial = '{' + partial.join(',') + '}';}
stack.pop();
return partial;}}
function stringify(object) {
return JSON.stringify(object);}
function toQueryString(object) {
return $H(object).toQueryString();}
function toHTML(object) {
return object && object.toHTML ? object.toHTML() : String.interpret(object);}
function keys(object) {
if (Type(object) !== OBJECT_TYPE) { throw new TypeError(); }
var results = [];
for (var property in object) {
if (_hasOwnProperty.call(object, property))
results.push(property);}
if (IS_DONTENUM_BUGGY) {
for (var i = 0; property = DONT_ENUMS[i]; i++) {
if (_hasOwnProperty.call(object, property))
results.push(property);}}
return results;}
function values(object) {
var results = [];
for (var property in object)
results.push(object[property]);
return results;}
function clone(object) {
return extend({}, object);}
function isElement(object) {
return !!(object && object.nodeType == 1);}
function isArray(object) {
return _toString.call(object) === ARRAY_CLASS;}
var hasNativeIsArray = (typeof Array.isArray == 'function') &&
Array.isArray([]) && !Array.isArray({});
if (hasNativeIsArray) {
isArray = Array.isArray;}
function isHash(object) {
return object instanceof Hash;}
function isFunction(object) {
return _toString.call(object) === FUNCTION_CLASS;}
function isString(object) {
return _toString.call(object) === STRING_CLASS;}
function isNumber(object) {
return _toString.call(object) === NUMBER_CLASS;}
function isDate(object) {
return _toString.call(object) === DATE_CLASS;}
function isUndefined(object) {
return typeof object === "undefined";}
extend(Object, {
extend: extend,
inspect: inspect,
toJSON: NATIVE_JSON_STRINGIFY_SUPPORT ? stringify : toJSON,
toQueryString: toQueryString,
toHTML: toHTML,
keys: Object.keys || keys,
values: values,
clone: clone,
isElement: isElement,
isArray: isArray,
isHash: isHash,
isFunction: isFunction,
isString: isString,
isNumber: isNumber,
isDate: isDate,
isUndefined: isUndefined});
})();
Object.extend(Function.prototype, (function () {
var slice = Array.prototype.slice;
function update(array, args) {
var arrayLength = array.length,
length = args.length;
while (length--) array[arrayLength + length] = args[length];
return array;}
function merge(array, args) {
array = slice.call(array, 0);
return update(array, args);}
function argumentNames() {
var names = this.toString().match(/^[\s\(]*function[^(]*\(([^)]*)\)/)[1]
.replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '')
.replace(/\s+/g, '').split(',');
return names.length == 1 && !names[0] ? [] : names;}
function bind(context) {
if (arguments.length < 2 && Object.isUndefined(arguments[0]))
return this;
if (!Object.isFunction(this))
throw new TypeError("The object is not callable.");
var nop = function () {};
var __method = this,
args = slice.call(arguments, 1);
var bound = function () {
var a = merge(args, arguments);
var c = this instanceof bound ? this : context;
return __method.apply(c, a);};
nop.prototype = this.prototype;
bound.prototype = new nop();
return bound;}
function bindAsEventListener(context) {
var __method = this,
args = slice.call(arguments, 1);
return function (event) {
var a = update([event || window.event], args);
return __method.apply(context, a);}}
function curry() {
if (!arguments.length) return this;
var __method = this,
args = slice.call(arguments, 0);
return function () {
var a = merge(args, arguments);
return __method.apply(this, a);}}
function delay(timeout) {
var __method = this,
args = slice.call(arguments, 1);
timeout = timeout * 1000;
return window.setTimeout(function () {
return __method.apply(__method, args);
}, timeout);}
function defer() {
var args = update([0.01], arguments);
return this.delay.apply(this, args);}
function wrap(wrapper) {
var __method = this;
return function () {
var a = update([__method.bind(this)], arguments);
return wrapper.apply(this, a);}}
function methodize() {
if (this._methodized) return this._methodized;
var __method = this;
return this._methodized = function () {
var a = update([this], arguments);
return __method.apply(null, a);};}
var extensions = {
argumentNames: argumentNames,
bindAsEventListener: bindAsEventListener,
curry: curry,
delay: delay,
defer: defer,
wrap: wrap,
methodize: methodize};
if (!Function.prototype.bind)
extensions.bind = bind;
return extensions;
})());
(function (proto) {
function toISOString() {
return this.getUTCFullYear() + '-' +
(this.getUTCMonth() + 1).toPaddedString(2) + '-' +
this.getUTCDate().toPaddedString(2) + 'T' +
this.getUTCHours().toPaddedString(2) + ':' +
this.getUTCMinutes().toPaddedString(2) + ':' +
this.getUTCSeconds().toPaddedString(2) + 'Z';}
function toJSON() {
return this.toISOString();}
if (!proto.toISOString) proto.toISOString = toISOString;
if (!proto.toJSON) proto.toJSON = toJSON;
})(Date.prototype);
RegExp.prototype.match = RegExp.prototype.test;
RegExp.escape = function (str) {
return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');};
var PeriodicalExecuter = Class.create({
initialize: function (callback, frequency) {
this.callback = callback;
this.frequency = frequency;
this.currentlyExecuting = false;
this.registerCallback();},
registerCallback: function () {
this.timer = setInterval(this.onTimerEvent.bind(this), this.frequency * 1000);},
execute: function () {
this.callback(this);},
stop: function () {
if (!this.timer) return;
clearInterval(this.timer);
this.timer = null;},
onTimerEvent: function () {
if (!this.currentlyExecuting) {
try {
this.currentlyExecuting = true;
this.execute();
this.currentlyExecuting = false;
} catch (e) {
this.currentlyExecuting = false;
throw e;}}}});
Object.extend(String, {
interpret: function (value) {
return value == null ? '' : String(value);},
specialChar: {
'\b': '\\b',
'\t': '\\t',
'\n': '\\n',
'\f': '\\f',
'\r': '\\r',
'\\': '\\\\'}});
Object.extend(String.prototype, (function () {
var NATIVE_JSON_PARSE_SUPPORT = window.JSON &&
typeof JSON.parse === 'function' &&
JSON.parse('{"test": true}').test;
function prepareReplacement(replacement) {
if (Object.isFunction(replacement)) return replacement;
var template = new Template(replacement);
return function (match) { return template.evaluate(match) };}
function isNonEmptyRegExp(regexp) {
return regexp.source && regexp.source !== '(?:)';}
function gsub(pattern, replacement) {
var result = '',
source = this,
match;
replacement = prepareReplacement(replacement);
if (Object.isString(pattern))
pattern = RegExp.escape(pattern);
if (!(pattern.length || isNonEmptyRegExp(pattern))) {
replacement = replacement('');
return replacement + source.split('').join(replacement) + replacement;}
while (source.length > 0) {
match = source.match(pattern)
if (match && match[0].length > 0) {
result += source.slice(0, match.index);
result += String.interpret(replacement(match));
source = source.slice(match.index + match[0].length);
} else {
result += source, source = '';}}
return result;}
function sub(pattern, replacement, count) {
replacement = prepareReplacement(replacement);
count = Object.isUndefined(count) ? 1 : count;
return this.gsub(pattern, function (match) {
if (--count < 0) return match[0];
return replacement(match);});}
function scan(pattern, iterator) {
this.gsub(pattern, iterator);
return String(this);}
function truncate(length, truncation) {
length = length || 30;
truncation = Object.isUndefined(truncation) ? '...' : truncation;
return this.length > length ?
this.slice(0, length - truncation.length) + truncation : String(this);}
function strip() {
return this.replace(/^\s+/, '').replace(/\s+$/, '');}
function stripTags() {
return this.replace(/<\w+(\s+("[^"]*"|'[^']*'|[^>])+)?(\/)?>|<\/\w+>/gi, '');}
function stripScripts() {
return this.replace(new RegExp(Prototype.ScriptFragment, 'img'), '');}
function extractScripts() {
var matchAll = new RegExp(Prototype.ScriptFragment, 'img'),
matchOne = new RegExp(Prototype.ScriptFragment, 'im');
return (this.match(matchAll) || []).map(function (scriptTag) {
return (scriptTag.match(matchOne) || ['', ''])[1];});}
function evalScripts() {
return this.extractScripts().map(function (script) { return eval(script); });}
function escapeHTML() {
return this.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');}
function unescapeHTML() {
return this.stripTags().replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');}
function toQueryParams(separator) {
var match = this.strip().match(/([^?#]*)(#.*)?$/);
if (!match) return {};
return match[1].split(separator || '&').inject({}, function (hash, pair) {
if ((pair = pair.split('='))[0]) {
var key = decodeURIComponent(pair.shift()),
value = pair.length > 1 ? pair.join('=') : pair[0];
if (value != undefined) {
value = value.gsub('+', ' ');
value = decodeURIComponent(value);}
if (key in hash) {
if (!Object.isArray(hash[key])) hash[key] = [hash[key]];
hash[key].push(value);
} else hash[key] = value;}
return hash;});}
function toArray() {
return this.split('');}
function succ() {
return this.slice(0, this.length - 1) +
String.fromCharCode(this.charCodeAt(this.length - 1) + 1);}
function times(count) {
return count < 1 ? '' : new Array(count + 1).join(this);}
function camelize() {
return this.replace(/-+(.)?/g, function (match, chr) {
return chr ? chr.toUpperCase() : '';});}
function capitalize() {
return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase();}
function underscore() {
return this.replace(/::/g, '/')
.replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
.replace(/([a-z\d])([A-Z])/g, '$1_$2')
.replace(/-/g, '_')
.toLowerCase();}
function dasherize() {
return this.replace(/_/g, '-');}
function inspect(useDoubleQuotes) {
var escapedString = this.replace(/[\x00-\x1f\\]/g, function (character) {
if (character in String.specialChar) {
return String.specialChar[character];}
return '\\u00' + character.charCodeAt().toPaddedString(2, 16);});
if (useDoubleQuotes) return '"' + escapedString.replace(/"/g, '\\"') + '"';
return "'" + escapedString.replace(/'/g, '\\\'') + "'";}
function unfilterJSON(filter) {
return this.replace(filter || Prototype.JSONFilter, '$1');}
function isJSON() {
var str = this;
if (str.blank()) return false;
str = str.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@');
str = str.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']');
str = str.replace(/(?:^|:|,)(?:\s*\[)+/g, '');
return (/^[\],:{}\s]*$/).test(str);}
function evalJSON(sanitize) {
var json = this.unfilterJSON(),
cx = /[\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff\u0000]/g;
if (cx.test(json)) {
json = json.replace(cx, function (a) {
return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);});}
try {
if (!sanitize || json.isJSON()) return eval('(' + json + ')');
} catch (e) {}
throw new SyntaxError('Badly formed JSON string: ' + this.inspect());}
function parseJSON() {
var json = this.unfilterJSON();
return JSON.parse(json);}
function include(pattern) {
return this.indexOf(pattern) > -1;}
function startsWith(pattern, position) {
position = Object.isNumber(position) ? position : 0;
return this.lastIndexOf(pattern, position) === position;}
function endsWith(pattern, position) {
pattern = String(pattern);
position = Object.isNumber(position) ? position : this.length;
if (position < 0) position = 0;
if (position > this.length) position = this.length;
var d = position - pattern.length;
return d >= 0 && this.indexOf(pattern, d) === d;}
function empty() {
return this == '';}
function blank() {
return /^\s*$/.test(this);}
function interpolate(object, pattern) {
return new Template(this, pattern).evaluate(object);}
return {
gsub: gsub,
sub: sub,
scan: scan,
truncate: truncate,
strip: String.prototype.trim || strip,
stripTags: stripTags,
stripScripts: stripScripts,
extractScripts: extractScripts,
evalScripts: evalScripts,
escapeHTML: escapeHTML,
unescapeHTML: unescapeHTML,
toQueryParams: toQueryParams,
parseQuery: toQueryParams,
toArray: toArray,
succ: succ,
times: times,
camelize: camelize,
capitalize: capitalize,
underscore: underscore,
dasherize: dasherize,
inspect: inspect,
unfilterJSON: unfilterJSON,
isJSON: isJSON,
evalJSON: NATIVE_JSON_PARSE_SUPPORT ? parseJSON : evalJSON,
include: include,
startsWith: String.prototype.startsWith || startsWith,
endsWith: String.prototype.endsWith || endsWith,
empty: empty,
blank: blank,
interpolate: interpolate};
})());
var Template = Class.create({
initialize: function (template, pattern) {
this.template = template.toString();
this.pattern = pattern || Template.Pattern;},
evaluate: function (object) {
if (object && Object.isFunction(object.toTemplateReplacements))
object = object.toTemplateReplacements();
return this.template.gsub(this.pattern, function (match) {
if (object == null) return (match[1] + '');
var before = match[1] || '';
if (before == '\\') return match[2];
var ctx = object,
expr = match[3],
pattern = /^([^.[]+|\[((?:.*?[^\\])?)\])(\.|\[|$)/;
match = pattern.exec(expr);
if (match == null) return before;
while (match != null) {
var comp = match[1].startsWith('[') ? match[2].replace(/\\\\]/g, ']') : match[1];
ctx = ctx[comp];
if (null == ctx || '' == match[3]) break;
expr = expr.substring('[' == match[3] ? match[1].length : match[0].length);
match = pattern.exec(expr);}
return before + String.interpret(ctx);});}});
Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\})/;
var $break = {};
var Enumerable = (function () {
function each(iterator, context) {
try {
this._each(iterator, context);
} catch (e) {
if (e != $break) throw e;}
return this;}
function eachSlice(number, iterator, context) {
var index = -number,
slices = [],
array = this.toArray();
if (number < 1) return array;
while ((index += number) < array.length)
slices.push(array.slice(index, index + number));
return slices.collect(iterator, context);}
function all(iterator, context) {
iterator = iterator || Prototype.K;
var result = true;
this.each(function (value, index) {
result = result && !!iterator.call(context, value, index, this);
if (!result) throw $break;
}, this);
return result;}
function any(iterator, context) {
iterator = iterator || Prototype.K;
var result = false;
this.each(function (value, index) {
if (result = !!iterator.call(context, value, index, this))
throw $break;
}, this);
return result;}
function collect(iterator, context) {
iterator = iterator || Prototype.K;
var results = [];
this.each(function (value, index) {
results.push(iterator.call(context, value, index, this));
}, this);
return results;}
function detect(iterator, context) {
var result;
this.each(function (value, index) {
if (iterator.call(context, value, index, this)) {
result = value;
throw $break;}
}, this);
return result;}
function findAll(iterator, context) {
var results = [];
this.each(function (value, index) {
if (iterator.call(context, value, index, this))
results.push(value);
}, this);
return results;}
function grep(filter, iterator, context) {
iterator = iterator || Prototype.K;
var results = [];
if (Object.isString(filter))
filter = new RegExp(RegExp.escape(filter));
this.each(function (value, index) {
if (filter.match(value))
results.push(iterator.call(context, value, index, this));
}, this);
return results;}
function include(object) {
if (Object.isFunction(this.indexOf) && this.indexOf(object) != -1)
return true;
var found = false;
this.each(function (value) {
if (value == object) {
found = true;
throw $break;}});
return found;}
function inGroupsOf(number, fillWith) {
fillWith = Object.isUndefined(fillWith) ? null : fillWith;
return this.eachSlice(number, function (slice) {
while (slice.length < number) slice.push(fillWith);
return slice;});}
function inject(memo, iterator, context) {
this.each(function (value, index) {
memo = iterator.call(context, memo, value, index, this);
}, this);
return memo;}
function invoke(method) {
var args = $A(arguments).slice(1);
return this.map(function (value) {
return value[method].apply(value, args);});}
function max(iterator, context) {
iterator = iterator || Prototype.K;
var result;
this.each(function (value, index) {
value = iterator.call(context, value, index, this);
if (result == null || value >= result)
result = value;
}, this);
return result;}
function min(iterator, context) {
iterator = iterator || Prototype.K;
var result;
this.each(function (value, index) {
value = iterator.call(context, value, index, this);
if (result == null || value < result)
result = value;
}, this);
return result;}
function partition(iterator, context) {
iterator = iterator || Prototype.K;
var trues = [],
falses = [];
this.each(function (value, index) {
(iterator.call(context, value, index, this) ?
trues : falses).push(value);
}, this);
return [trues, falses];}
function pluck(property) {
var results = [];
this.each(function (value) {
results.push(value[property]);});
return results;}
function reject(iterator, context) {
var results = [];
this.each(function (value, index) {
if (!iterator.call(context, value, index, this))
results.push(value);
}, this);
return results;}
function sortBy(iterator, context) {
return this.map(function (value, index) {
return {
value: value,
criteria: iterator.call(context, value, index, this)};
}, this).sort(function (left, right) {
var a = left.criteria,
b = right.criteria;
return a < b ? -1 : a > b ? 1 : 0;
}).pluck('value');}
function toArray() {
return this.map();}
function zip() {
var iterator = Prototype.K,
args = $A(arguments);
if (Object.isFunction(args.last()))
iterator = args.pop();
var collections = [this].concat(args).map($A);
return this.map(function (value, index) {
return iterator(collections.pluck(index));});}
function size() {
return this.toArray().length;}
function inspect() {
return '#<Enumerable:' + this.toArray().inspect() + '>';}
return {
each: each,
eachSlice: eachSlice,
all: all,
every: all,
any: any,
some: any,
collect: collect,
map: collect,
detect: detect,
findAll: findAll,
select: findAll,
filter: findAll,
grep: grep,
include: include,
member: include,
inGroupsOf: inGroupsOf,
inject: inject,
invoke: invoke,
max: max,
min: min,
partition: partition,
pluck: pluck,
reject: reject,
sortBy: sortBy,
toArray: toArray,
entries: toArray,
zip: zip,
size: size,
inspect: inspect,
find: detect};
})();
function $A(iterable) {
if (!iterable) return [];
if ('toArray' in Object(iterable)) return iterable.toArray();
var length = iterable.length || 0,
results = new Array(length);
while (length--) results[length] = iterable[length];
return results;}
function $w(string) {
if (!Object.isString(string)) return [];
string = string.strip();
return string ? string.split(/\s+/) : [];}
Array.from = $A;
(function () {
var arrayProto = Array.prototype,
slice = arrayProto.slice,
_each = arrayProto.forEach; // use native browser JS 1.6 implementation if available
function each(iterator, context) {
for (var i = 0, length = this.length >>> 0; i < length; i++) {
if (i in this) iterator.call(context, this[i], i, this);}}
if (!_each) _each = each;
function clear() {
this.length = 0;
return this;}
function first() {
return this[0];}
function last() {
return this[this.length - 1];}
function compact() {
return this.select(function (value) {
return value != null;});}
function flatten() {
return this.inject([], function (array, value) {
if (Object.isArray(value))
return array.concat(value.flatten());
array.push(value);
return array;});}
function without() {
var values = slice.call(arguments, 0);
return this.select(function (value) {
return !values.include(value);});}
function reverse(inline) {
return (inline === false ? this.toArray() : this)._reverse();}
function uniq(sorted) {
return this.inject([], function (array, value, index) {
if (0 == index || (sorted ? array.last() != value : !array.include(value)))
array.push(value);
return array;});}
function intersect(array) {
return this.uniq().findAll(function (item) {
return array.indexOf(item) !== -1;});}
function clone() {
return slice.call(this, 0);}
function size() {
return this.length;}
function inspect() {
return '[' + this.map(Object.inspect).join(', ') + ']';}
function indexOf(item, i) {
if (this == null) throw new TypeError();
var array = Object(this),
length = array.length >>> 0;
if (length === 0) return -1;
i = Number(i);
if (isNaN(i)) {
i = 0;
} else if (i !== 0 && isFinite(i)) {
i = (i > 0 ? 1 : -1) * Math.floor(Math.abs(i));}
if (i > length) return -1;
var k = i >= 0 ? i : Math.max(length - Math.abs(i), 0);
for (; k < length; k++)
if (k in array && array[k] === item) return k;
return -1;}
function lastIndexOf(item, i) {
if (this == null) throw new TypeError();
var array = Object(this),
length = array.length >>> 0;
if (length === 0) return -1;
if (!Object.isUndefined(i)) {
i = Number(i);
if (isNaN(i)) {
i = 0;
} else if (i !== 0 && isFinite(i)) {
i = (i > 0 ? 1 : -1) * Math.floor(Math.abs(i));}
} else {
i = length;}
var k = i >= 0 ? Math.min(i, length - 1) :
length - Math.abs(i);
for (; k >= 0; k--)
if (k in array && array[k] === item) return k;
return -1;}
function concat(_) {
var array = [],
items = slice.call(arguments, 0),
item, n = 0;
items.unshift(this);
for (var i = 0, length = items.length; i < length; i++) {
item = items[i];
if (Object.isArray(item) && !('callee' in item)) {
for (var j = 0, arrayLength = item.length; j < arrayLength; j++) {
if (j in item) array[n] = item[j];
n++;}
} else {
array[n++] = item;}}
array.length = n;
return array;}
function wrapNative(method) {
return function () {
if (arguments.length === 0) {
return method.call(this, Prototype.K);
} else if (arguments[0] === undefined) {
var args = slice.call(arguments, 1);
args.unshift(Prototype.K);
return method.apply(this, args);
} else {
return method.apply(this, arguments);}};}
function map(iterator) {
if (this == null) throw new TypeError();
iterator = iterator || Prototype.K;
var object = Object(this);
var results = [],
context = arguments[1],
n = 0;
for (var i = 0, length = object.length >>> 0; i < length; i++) {
if (i in object) {
results[n] = iterator.call(context, object[i], i, object);}
n++;}
results.length = n;
return results;}
if (arrayProto.map) {
map = wrapNative(Array.prototype.map);}
function filter(iterator) {
if (this == null || !Object.isFunction(iterator))
throw new TypeError();
var object = Object(this);
var results = [],
context = arguments[1],
value;
for (var i = 0, length = object.length >>> 0; i < length; i++) {
if (i in object) {
value = object[i];
if (iterator.call(context, value, i, object)) {
results.push(value);}}}
return results;}
if (arrayProto.filter) {
filter = Array.prototype.filter;}
function some(iterator) {
if (this == null) throw new TypeError();
iterator = iterator || Prototype.K;
var context = arguments[1];
var object = Object(this);
for (var i = 0, length = object.length >>> 0; i < length; i++) {
if (i in object && iterator.call(context, object[i], i, object)) {
return true;}}
return false;}
if (arrayProto.some) {
some = wrapNative(Array.prototype.some);}
function every(iterator) {
if (this == null) throw new TypeError();
iterator = iterator || Prototype.K;
var context = arguments[1];
var object = Object(this);
for (var i = 0, length = object.length >>> 0; i < length; i++) {
if (i in object && !iterator.call(context, object[i], i, object)) {
return false;}}
return true;}
if (arrayProto.every) {
every = wrapNative(Array.prototype.every);}
Object.extend(arrayProto, Enumerable);
if (arrayProto.entries === Enumerable.entries) {
delete arrayProto.entries;}
if (!arrayProto._reverse)
arrayProto._reverse = arrayProto.reverse;
Object.extend(arrayProto, {
_each: _each,
map: map,
collect: map,
select: filter,
filter: filter,
findAll: filter,
some: some,
any: some,
every: every,
all: every,
clear: clear,
first: first,
last: last,
compact: compact,
flatten: flatten,
without: without,
reverse: reverse,
uniq: uniq,
intersect: intersect,
clone: clone,
toArray: clone,
size: size,
inspect: inspect});
var CONCAT_ARGUMENTS_BUGGY = (function () {
return [].concat(arguments)[0][0] !== 1;
})(1, 2);
if (CONCAT_ARGUMENTS_BUGGY) arrayProto.concat = concat;
if (!arrayProto.indexOf) arrayProto.indexOf = indexOf;
if (!arrayProto.lastIndexOf) arrayProto.lastIndexOf = lastIndexOf;
})();
function $H(object) {
return new Hash(object);};
var Hash = Class.create(Enumerable, (function () {
function initialize(object) {
this._object = Object.isHash(object) ? object.toObject() : Object.clone(object);}
function _each(iterator, context) {
var i = 0;
for (var key in this._object) {
var value = this._object[key],
pair = [key, value];
pair.key = key;
pair.value = value;
iterator.call(context, pair, i);
i++;}}
function set(key, value) {
return this._object[key] = value;}
function get(key) {
if (this._object[key] !== Object.prototype[key])
return this._object[key];}
function unset(key) {
var value = this._object[key];
delete this._object[key];
return value;}
function toObject() {
return Object.clone(this._object);}
function keys() {
return this.pluck('key');}
function values() {
return this.pluck('value');}
function index(value) {
var match = this.detect(function (pair) {
return pair.value === value;});
return match && match.key;}
function merge(object) {
return this.clone().update(object);}
function update(object) {
return new Hash(object).inject(this, function (result, pair) {
result.set(pair.key, pair.value);
return result;});}
function toQueryPair(key, value) {
if (Object.isUndefined(value)) return key;
value = String.interpret(value);
value = value.gsub(/(\r)?\n/, '\r\n');
value = encodeURIComponent(value);
value = value.gsub(/%20/, '+');
return key + '=' + value;}
function toQueryString() {
return this.inject([], function (results, pair) {
var key = encodeURIComponent(pair.key),
values = pair.value;
if (values && typeof values == 'object') {
if (Object.isArray(values)) {
var queryValues = [];
for (var i = 0, len = values.length, value; i < len; i++) {
value = values[i];
queryValues.push(toQueryPair(key, value));}
return results.concat(queryValues);}
} else results.push(toQueryPair(key, values));
return results;
}).join('&');}
function inspect() {
return '#<Hash:{' + this.map(function (pair) {
return pair.map(Object.inspect).join(': ');
}).join(', ') + '}>';}
function clone() {
return new Hash(this);}
return {
initialize: initialize,
_each: _each,
set: set,
get: get,
unset: unset,
toObject: toObject,
toTemplateReplacements: toObject,
keys: keys,
values: values,
index: index,
merge: merge,
update: update,
toQueryString: toQueryString,
inspect: inspect,
toJSON: toObject,
clone: clone};
})());
Hash.from = $H;
Object.extend(Number.prototype, (function () {
function toColorPart() {
return this.toPaddedString(2, 16);}
function succ() {
return this + 1;}
function times(iterator, context) {
$R(0, this, true).each(iterator, context);
return this;}
function toPaddedString(length, radix) {
var string = this.toString(radix || 10);
return '0'.times(length - string.length) + string;}
function abs() {
return Math.abs(this);}
function round() {
return Math.round(this);}
function ceil() {
return Math.ceil(this);}
function floor() {
return Math.floor(this);}
return {
toColorPart: toColorPart,
succ: succ,
times: times,
toPaddedString: toPaddedString,
abs: abs,
round: round,
ceil: ceil,
floor: floor};
})());
function $R(start, end, exclusive) {
return new ObjectRange(start, end, exclusive);}
var ObjectRange = Class.create(Enumerable, (function () {
function initialize(start, end, exclusive) {
this.start = start;
this.end = end;
this.exclusive = exclusive;}
function _each(iterator, context) {
var value = this.start,
i;
for (i = 0; this.include(value); i++) {
iterator.call(context, value, i);
value = value.succ();}}
function include(value) {
if (value < this.start)
return false;
if (this.exclusive)
return value < this.end;
return value <= this.end;}
return {
initialize: initialize,
_each: _each,
include: include};
})());
var Abstract = {};
var Try = {
these: function () {
var returnValue;
for (var i = 0, length = arguments.length; i < length; i++) {
var lambda = arguments[i];
try {
returnValue = lambda();
break;
} catch (e) {}}
return returnValue;}};
var Ajax = {
getTransport: function () {
return Try.these(
function () { return new XDomainRequest() },
function () { return new XMLHttpRequest() },
function () { return new ActiveXObject('Msxml2.XMLHTTP') },
function () { return new ActiveXObject('Microsoft.XMLHTTP') }
) || false;},
activeRequestCount: 0};
Ajax.Responders = {
responders: [],
_each: function (iterator, context) {
this.responders._each(iterator, context);},
register: function (responder) {
if (!this.include(responder))
this.responders.push(responder);},
unregister: function (responder) {
this.responders = this.responders.without(responder);},
dispatch: function (callback, request, transport, json) {
this.each(function (responder) {
if (Object.isFunction(responder[callback])) {
try {
responder[callback].apply(responder, [request, transport, json]);
} catch (e) {}}});}};
Object.extend(Ajax.Responders, Enumerable);
Ajax.Responders.register({
onCreate: function () { Ajax.activeRequestCount++ },
onComplete: function () { Ajax.activeRequestCount-- }});
Ajax.Base = Class.create({
initialize: function (options) {
this.options = {
method: 'post',
asynchronous: true,
contentType: 'application/x-www-form-urlencoded',
encoding: 'UTF-8',
parameters: '',
evalJSON: true,
evalJS: true};
Object.extend(this.options, options || {});
this.options.method = this.options.method.toLowerCase();
if (Object.isHash(this.options.parameters))
this.options.parameters = this.options.parameters.toObject();}});
Ajax.Request = Class.create(Ajax.Base, {
_complete: false,
initialize: function ($super, url, options) {
$super(options);
this.transport = Ajax.getTransport();
this.request(url);},
request: function (url) {
this.url = url;
this.method = this.options.method;
var params = Object.isString(this.options.parameters) ?
this.options.parameters :
Object.toQueryString(this.options.parameters);
if (!['get', 'post'].include(this.method)) {
params += (params ? '&' : '') + "_method=" + this.method;
this.method = 'post';}
if (params && this.method === 'get') {
this.url += (this.url.include('?') ? '&' : '?') + params;}
this.parameters = params.toQueryParams();
try {
var response = new Ajax.Response(this);
if (this.options.onCreate) this.options.onCreate(response);
Ajax.Responders.dispatch('onCreate', this, response);
this.transport.open(this.method.toUpperCase(), this.url,
this.options.asynchronous);
if (this.options.asynchronous) this.respondToReadyState.bind(this).defer(1);
if (Prototype.BrowserFeatures.XDomainRequest) {
this.transport.onload = function () {
this.transport["status"] = 200;
this.transport["XDomainRequest"] = true;
this.transport["readyState"] = 4;
if (!this._complete){
this.respondToReadyState(this.transport.readyState);}
}.bind(this);
}else {
this.transport.onreadystatechange = this.onStateChange.bind(this);
this.setRequestHeaders();}
this.body = this.method == 'post' ? (this.options.postBody || params) : null;
this.transport.send(this.body);
if (!this.options.asynchronous && this.transport.overrideMimeType)
this.onStateChange();
} catch (e) {
this.dispatchException(e);}},
onStateChange: function () {
var readyState = this.transport.readyState;
if (readyState > 1 && !((readyState == 4) && this._complete))
this.respondToReadyState(this.transport.readyState);},
setRequestHeaders: function () {
var headers = {
'X-Requested-With': 'XMLHttpRequest',
'X-Prototype-Version': Prototype.Version,
'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'};
if (this.method == 'post') {
headers['Content-type'] = this.options.contentType +
(this.options.encoding ? '; charset=' + this.options.encoding : '');
if (this.transport.overrideMimeType &&
(navigator.userAgent.match(/Gecko\/(\d{4})/) || [0, 2005])[1] < 2005)
headers['Connection'] = 'close';}
if (typeof this.options.requestHeaders == 'object') {
var extras = this.options.requestHeaders;
if (Object.isFunction(extras.push))
for (var i = 0, length = extras.length; i < length; i += 2)
headers[extras[i]] = extras[i + 1];
else
$H(extras).each(function (pair) { headers[pair.key] = pair.value });}
for (var name in headers)
if (headers[name] != null && !Prototype.BrowserFeatures.XDomainRequest)
this.transport.setRequestHeader(name, headers[name]);},
success: function () {
var status = this.getStatus();
return !status || (status >= 200 && status < 300) || status == 304;},
getStatus: function () {
try {
if (this.transport.status === 1223) return 204;
return this.transport.status || 0;
} catch (e) { return 0 }},
respondToReadyState: function (readyState) {
var state = Ajax.Request.Events[readyState],
response = new Ajax.Response(this);
if (state == 'Complete') {
try {
this._complete = true;
(this.options['on' + response.status] ||
this.options['on' + (this.success() ? 'Success' : 'Failure')] ||
Prototype.emptyFunction)(response, response.headerJSON);
} catch (e) {
this.dispatchException(e);}
var contentType = response.getHeader('Content-type');
if (this.options.evalJS == 'force' ||
(this.options.evalJS && this.isSameOrigin() && contentType &&
contentType.match(/^\s*(text|application)\/(x-)?(java|ecma)script(;.*)?\s*$/i)))
this.evalResponse();}
try {
(this.options['on' + state] || Prototype.emptyFunction)(response, response.headerJSON);
Ajax.Responders.dispatch('on' + state, this, response, response.headerJSON);
} catch (e) {
this.dispatchException(e);}
if (state == 'Complete') {
this.transport.onreadystatechange = Prototype.emptyFunction;}},
isSameOrigin: function () {
var m = this.url.match(/^\s*https?:\/\/[^\/]*/);
return !m || (m[0] == '#{protocol}//#{domain}#{port}'.interpolate({
protocol: location.protocol,
domain: document.domain,
port: location.port ? ':' + location.port : ''
}));},
getHeader: function (name) {
try {
return this.transport.getResponseHeader(name) || null;
} catch (e) { return null; }},
evalResponse: function () {
try {
return eval((this.transport.responseText || '').unfilterJSON());
} catch (e) {
this.dispatchException(e);}},
dispatchException: function (exception) {
(this.options.onException || Prototype.emptyFunction)(this, exception);
Ajax.Responders.dispatch('onException', this, exception);}});
Ajax.Request.Events = ['Uninitialized', 'Loading', 'Loaded', 'Interactive', 'Complete'];
Ajax.Response = Class.create({
initialize: function (request) {
this.request = request;
var transport = this.transport = request.transport,
readyState = this.readyState = transport.readyState;
if ((readyState > 2 && !Prototype.Browser.IE) || readyState == 4) {
this.status = this.getStatus();
this.statusText = this.getStatusText();
this.responseText = String.interpret(transport.responseText);
this.headerJSON = this._getHeaderJSON();}
if (readyState == 4) {
if (transport.XDomainRequest) {
if (transport.contentType.match(/xml/)) {
var doc = new ActiveXObject('Microsoft.XMLDOM');
doc.async = false;
try {
doc.loadXML(this.responseText);
} catch (e) {
doc = undefined;}
this.responseXML = doc;}
} else {
var xml = transport.responseXML;
this.responseXML = Object.isUndefined(xml) ? null : xml;}
this.responseJSON = this._getResponseJSON();}},
status: 0,
statusText: '',
getStatus: Ajax.Request.prototype.getStatus,
getStatusText: function () {
try {
return this.transport.statusText || '';
} catch (e) { return '' }},
getHeader: Ajax.Request.prototype.getHeader,
getAllHeaders: function () {
try {
return this.getAllResponseHeaders();
} catch (e) { return null }},
getResponseHeader: function (name) {
return this.transport.getResponseHeader(name);},
getAllResponseHeaders: function () {
return this.transport.getAllResponseHeaders();},
_getHeaderJSON: function () {
var json = this.getHeader('X-JSON');
if (!json) return null;
try {
json = decodeURIComponent(escape(json));
} catch (e) {}
try {
return json.evalJSON(this.request.options.sanitizeJSON ||
!this.request.isSameOrigin());
} catch (e) {
this.request.dispatchException(e);}},
_getResponseJSON: function () {
var options = this.request.options;
if (!options.evalJSON || (options.evalJSON != 'force' &&
!(this.getHeader('Content-type') || '').include('application/json')) ||
this.responseText.blank())
return null;
try {
return this.responseText.evalJSON(options.sanitizeJSON ||
!this.request.isSameOrigin());
} catch (e) {
this.request.dispatchException(e);}}});
Ajax.Updater = Class.create(Ajax.Request, {
initialize: function ($super, container, url, options) {
this.container = {
success: (container.success || container),
failure: (container.failure || (container.success ? null : container))};
options = Object.clone(options);
var onComplete = options.onComplete;
options.onComplete = (function (response, json) {
this.updateContent(response.responseText);
if (Object.isFunction(onComplete)) onComplete(response, json);
}).bind(this);
$super(url, options);},
updateContent: function (responseText) {
var receiver = this.container[this.success() ? 'success' : 'failure'],
options = this.options;
if (!options.evalScripts) responseText = responseText.stripScripts();
if (receiver = prototype$(receiver)) {
if (options.insertion) {
if (Object.isString(options.insertion)) {
var insertion = {};
insertion[options.insertion] = responseText;
receiver.insert(insertion);
} else options.insertion(receiver, responseText);
} else receiver.update(responseText);}}});
Ajax.PeriodicalUpdater = Class.create(Ajax.Base, {
initialize: function ($super, container, url, options) {
$super(options);
this.onComplete = this.options.onComplete;
this.frequency = (this.options.frequency || 2);
this.decay = (this.options.decay || 1);
this.updater = {};
this.container = container;
this.url = url;
this.start();},
start: function () {
this.options.onComplete = this.updateComplete.bind(this);
this.onTimerEvent();},
stop: function () {
this.updater.options.onComplete = undefined;
clearTimeout(this.timer);
(this.onComplete || Prototype.emptyFunction).apply(this, arguments);},
updateComplete: function (response) {
if (this.options.decay) {
this.decay = (response.responseText == this.lastText ?
this.decay * this.options.decay : 1);
this.lastText = response.responseText;}
this.timer = this.onTimerEvent.bind(this).delay(this.decay * this.frequency);},
onTimerEvent: function () {
this.updater = new Ajax.Updater(this.container, this.url, this.options);}});
(function (GLOBAL) {
var UNDEFINED;
var SLICE = Array.prototype.slice;
var DIV = document.createElement('div');
function prototype$(element) {
if (arguments.length > 1) {
for (var i = 0, elements = [], length = arguments.length; i < length; i++)
elements.push(prototype$(arguments[i]));
return elements;}
if (Object.isString(element))
element = document.getElementById(element);
return Element.extend(element);}
GLOBAL.prototype$ = prototype$;
if (!GLOBAL.Node) GLOBAL.Node = {};
if (!GLOBAL.Node.ELEMENT_NODE) {
Object.extend(GLOBAL.Node, {
ELEMENT_NODE: 1,
ATTRIBUTE_NODE: 2,
TEXT_NODE: 3,
CDATA_SECTION_NODE: 4,
ENTITY_REFERENCE_NODE: 5,
ENTITY_NODE: 6,
PROCESSING_INSTRUCTION_NODE: 7,
COMMENT_NODE: 8,
DOCUMENT_NODE: 9,
DOCUMENT_TYPE_NODE: 10,
DOCUMENT_FRAGMENT_NODE: 11,
NOTATION_NODE: 12});}
var ELEMENT_CACHE = {};
function shouldUseCreationCache(tagName, attributes) {
if (tagName === 'select') return false;
if ('type' in attributes) return false;
return true;}
var HAS_EXTENDED_CREATE_ELEMENT_SYNTAX = (function () {
try {
var el = document.createElement('<input name="x">');
return el.tagName.toLowerCase() === 'input' && el.name === 'x';
} catch (err) {
return false;}
})();
var oldElement = GLOBAL.Element;
function Element(tagName, attributes) {
attributes = attributes || {};
tagName = tagName.toLowerCase();
if (HAS_EXTENDED_CREATE_ELEMENT_SYNTAX && attributes.name) {
tagName = '<' + tagName + ' name="' + attributes.name + '">';
delete attributes.name;
return Element.writeAttribute(document.createElement(tagName), attributes);}
if (!ELEMENT_CACHE[tagName])
ELEMENT_CACHE[tagName] = Element.extend(document.createElement(tagName));
var node = shouldUseCreationCache(tagName, attributes) ?
ELEMENT_CACHE[tagName].cloneNode(false) : document.createElement(tagName);
return Element.writeAttribute(node, attributes);}
GLOBAL.Element = Element;
Object.extend(GLOBAL.Element, oldElement || {});
if (oldElement) GLOBAL.Element.prototype = oldElement.prototype;
Element.Methods = { ByTag: {}, Simulated: {} };
var methods = {};
var INSPECT_ATTRIBUTES = { id: 'id', className: 'class' };
function inspect(element) {
element = prototype$(element);
var result = '<' + element.tagName.toLowerCase();
var attribute, value;
for (var property in INSPECT_ATTRIBUTES) {
attribute = INSPECT_ATTRIBUTES[property];
value = (element[property] || '').toString();
if (value) result += ' ' + attribute + '=' + value.inspect(true);}
return result + '>';}
methods.inspect = inspect;
function visible(element) {
return prototype$(element).getStyle('display') !== 'none';}
function toggle(element, bool) {
element = prototype$(element);
if (typeof bool !== 'boolean')
bool = !Element.visible(element);
Element[bool ? 'show' : 'hide'](element);
return element;}
function hide(element) {
element = prototype$(element);
element.style.display = 'none';
return element;}
function show(element) {
element = prototype$(element);
element.style.display = '';
return element;}
Object.extend(methods, {
visible: visible,
toggle: toggle,
hide: hide,
show: show});
function remove(element) {
element = prototype$(element);
element.parentNode.removeChild(element);
return element;}
var SELECT_ELEMENT_INNERHTML_BUGGY = (function () {
var el = document.createElement("select"),
isBuggy = true;
el.innerHTML = "<option value=\"test\">test</option>";
if (el.options && el.options[0]) {
isBuggy = el.options[0].nodeName.toUpperCase() !== "OPTION";}
el = null;
return isBuggy;
})();
var TABLE_ELEMENT_INNERHTML_BUGGY = (function () {
try {
var el = document.createElement("table");
if (el && el.tBodies) {
el.innerHTML = "<tbody><tr><td>test</td></tr></tbody>";
var isBuggy = typeof el.tBodies[0] == "undefined";
el = null;
return isBuggy;}
} catch (e) {
return true;}
})();
var LINK_ELEMENT_INNERHTML_BUGGY = (function () {
try {
var el = document.createElement('div');
el.innerHTML = "<link />";
var isBuggy = (el.childNodes.length === 0);
el = null;
return isBuggy;
} catch (e) {
return true;}
})();
var ANY_INNERHTML_BUGGY = SELECT_ELEMENT_INNERHTML_BUGGY ||
TABLE_ELEMENT_INNERHTML_BUGGY || LINK_ELEMENT_INNERHTML_BUGGY;
var SCRIPT_ELEMENT_REJECTS_TEXTNODE_APPENDING = (function () {
var s = document.createElement("script"),
isBuggy = false;
try {
s.appendChild(document.createTextNode(""));
isBuggy = !s.firstChild ||
s.firstChild && s.firstChild.nodeType !== 3;
} catch (e) {
isBuggy = true;}
s = null;
return isBuggy;
})();
function update(element, content) {
element = prototype$(element);
var descendants = element.getElementsByTagName('*'),
i = descendants.length;
while (i--) purgeElement(descendants[i]);
if (content && content.toElement)
content = content.toElement();
if (Object.isElement(content))
return element.update().insert(content);
content = Object.toHTML(content);
var tagName = element.tagName.toUpperCase();
if (tagName === 'SCRIPT' && SCRIPT_ELEMENT_REJECTS_TEXTNODE_APPENDING) {
element.text = content;
return element;}
if (ANY_INNERHTML_BUGGY) {
if (tagName in INSERTION_TRANSLATIONS.tags) {
while (element.firstChild)
element.removeChild(element.firstChild);
var nodes = getContentFromAnonymousElement(tagName, content.stripScripts());
for (var i = 0, node; node = nodes[i]; i++)
element.appendChild(node);
} else if (LINK_ELEMENT_INNERHTML_BUGGY && Object.isString(content) && content.indexOf('<link') > -1) {
while (element.firstChild)
element.removeChild(element.firstChild);
var nodes = getContentFromAnonymousElement(tagName,
content.stripScripts(), true);
for (var i = 0, node; node = nodes[i]; i++)
element.appendChild(node);
} else {
element.innerHTML = content.stripScripts();}
} else {
element.innerHTML = content.stripScripts();}
content.evalScripts.bind(content).defer();
return element;}
function replace(element, content) {
element = prototype$(element);
if (content && content.toElement) {
content = content.toElement();
} else if (!Object.isElement(content)) {
content = Object.toHTML(content);
var range = element.ownerDocument.createRange();
range.selectNode(element);
content.evalScripts.bind(content).defer();
content = range.createContextualFragment(content.stripScripts());}
element.parentNode.replaceChild(content, element);
return element;}
var INSERTION_TRANSLATIONS = {
before: function (element, node) {
element.parentNode.insertBefore(node, element);},
top: function (element, node) {
element.insertBefore(node, element.firstChild);},
bottom: function (element, node) {
element.appendChild(node);},
after: function (element, node) {
element.parentNode.insertBefore(node, element.nextSibling);},
tags: {
TABLE: ['<table>', '</table>', 1],
TBODY: ['<table><tbody>', '</tbody></table>', 2],
TR: ['<table><tbody><tr>', '</tr></tbody></table>', 3],
TD: ['<table><tbody><tr><td>', '</td></tr></tbody></table>', 4],
SELECT: ['<select>', '</select>', 1]}};
var tags = INSERTION_TRANSLATIONS.tags;
Object.extend(tags, {
THEAD: tags.TBODY,
TFOOT: tags.TBODY,
TH: tags.TD});
function replace_IE(element, content) {
element = prototype$(element);
if (content && content.toElement)
content = content.toElement();
if (Object.isElement(content)) {
element.parentNode.replaceChild(content, element);
return element;}
content = Object.toHTML(content);
var parent = element.parentNode,
tagName = parent.tagName.toUpperCase();
if (tagName in INSERTION_TRANSLATIONS.tags) {
var nextSibling = Element.next(element);
var fragments = getContentFromAnonymousElement(
tagName, content.stripScripts());
parent.removeChild(element);
var iterator;
if (nextSibling)
iterator = function (node) { parent.insertBefore(node, nextSibling) };
else
iterator = function (node) { parent.appendChild(node); }
fragments.each(iterator);
} else {
element.outerHTML = content.stripScripts();}
content.evalScripts.bind(content).defer();
return element;}
if ('outerHTML' in document.documentElement)
replace = replace_IE;
function isContent(content) {
if (Object.isUndefined(content) || content === null) return false;
if (Object.isString(content) || Object.isNumber(content)) return true;
if (Object.isElement(content)) return true;
if (content.toElement || content.toHTML) return true;
return false;}
function insertContentAt(element, content, position) {
position = position.toLowerCase();
var method = INSERTION_TRANSLATIONS[position];
if (content && content.toElement) content = content.toElement();
if (Object.isElement(content)) {
method(element, content);
return element;}
content = Object.toHTML(content);
var tagName = ((position === 'before' || position === 'after') ?
element.parentNode : element).tagName.toUpperCase();
var childNodes = getContentFromAnonymousElement(tagName, content.stripScripts());
if (position === 'top' || position === 'after') childNodes.reverse();
for (var i = 0, node; node = childNodes[i]; i++)
method(element, node);
content.evalScripts.bind(content).defer();}
function insert(element, insertions) {
element = prototype$(element);
if (isContent(insertions))
insertions = { bottom: insertions };
for (var position in insertions)
insertContentAt(element, insertions[position], position);
return element;}
function wrap(element, wrapper, attributes) {
element = prototype$(element);
if (Object.isElement(wrapper)) {
prototype$(wrapper).writeAttribute(attributes || {});
} else if (Object.isString(wrapper)) {
wrapper = new Element(wrapper, attributes);
} else {
wrapper = new Element('div', wrapper);}
if (element.parentNode)
element.parentNode.replaceChild(wrapper, element);
wrapper.appendChild(element);
return wrapper;}
function cleanWhitespace(element) {
element = prototype$(element);
var node = element.firstChild;
while (node) {
var nextNode = node.nextSibling;
if (node.nodeType === Node.TEXT_NODE && !/\S/.test(node.nodeValue))
element.removeChild(node);
node = nextNode;}
return element;}
function empty(element) {
return prototype$(element).innerHTML.blank();}
function getContentFromAnonymousElement(tagName, html, force) {
var t = INSERTION_TRANSLATIONS.tags[tagName],
div = DIV;
var workaround = !!t;
if (!workaround && force) {
workaround = true;
t = ['', '', 0];}
if (workaround) {
div.innerHTML = '&#160;' + t[0] + html + t[1];
div.removeChild(div.firstChild);
for (var i = t[2]; i--;)
div = div.firstChild;
} else {
div.innerHTML = html;}
return $A(div.childNodes);}
function clone(element, deep) {
if (!(element = prototype$(element))) return;
var clone = element.cloneNode(deep);
if (!HAS_UNIQUE_ID_PROPERTY) {
clone._prototypeUID = UNDEFINED;
if (deep) {
var descendants = Element.select(clone, '*'),
i = descendants.length;
while (i--)
descendants[i]._prototypeUID = UNDEFINED;}}
return Element.extend(clone);}
function purgeElement(element) {
var uid = getUniqueElementID(element);
if (uid) {
Element.stopObserving(element);
if (!HAS_UNIQUE_ID_PROPERTY)
element._prototypeUID = UNDEFINED;
delete Element.Storage[uid];}}
function purgeCollection(elements) {
var i = elements.length;
while (i--)
purgeElement(elements[i]);}
function purgeCollection_IE(elements) {
var i = elements.length,
element, uid;
while (i--) {
element = elements[i];
uid = getUniqueElementID(element);
delete Element.Storage[uid];
delete Event.cache[uid];}}
if (HAS_UNIQUE_ID_PROPERTY) {
purgeCollection = purgeCollection_IE;}
function purge(element) {
if (!(element = prototype$(element))) return;
purgeElement(element);
var descendants = element.getElementsByTagName('*'),
i = descendants.length;
while (i--) purgeElement(descendants[i]);
return null;}
Object.extend(methods, {
remove: remove,
update: update,
replace: replace,
insert: insert,
wrap: wrap,
cleanWhitespace: cleanWhitespace,
empty: empty,
clone: clone,
purge: purge});
function recursivelyCollect(element, property, maximumLength) {
element = prototype$(element);
maximumLength = maximumLength || -1;
var elements = [];
while (element = element[property]) {
if (element.nodeType === Node.ELEMENT_NODE)
elements.push(Element.extend(element));
if (elements.length === maximumLength) break;}
return elements;}
function ancestors(element) {
return recursivelyCollect(element, 'parentNode');}
function descendants(element) {
return Element.select(element, '*');}
function firstDescendant(element) {
element = prototype$(element).firstChild;
while (element && element.nodeType !== Node.ELEMENT_NODE)
element = element.nextSibling;
return prototype$(element);}
function immediateDescendants(element) {
var results = [],
child = prototype$(element).firstChild;
while (child) {
if (child.nodeType === Node.ELEMENT_NODE)
results.push(Element.extend(child));
child = child.nextSibling;}
return results;}
function previousSiblings(element) {
return recursivelyCollect(element, 'previousSibling');}
function nextSiblings(element) {
return recursivelyCollect(element, 'nextSibling');}
function siblings(element) {
element = prototype$(element);
var previous = previousSiblings(element),
next = nextSiblings(element);
return previous.reverse().concat(next);}
function match(element, selector) {
element = prototype$(element);
if (Object.isString(selector))
return Prototype.Selector.match(element, selector);
return selector.match(element);}
function _recursivelyFind(element, property, expression, index) {
element = prototype$(element), expression = expression || 0, index = index || 0;
if (Object.isNumber(expression)) {
index = expression, expression = null;}
while (element = element[property]) {
if (element.nodeType !== 1) continue;
if (expression && !Prototype.Selector.match(element, expression))
continue;
if (--index >= 0) continue;
return Element.extend(element);}}
function up(element, expression, index) {
element = prototype$(element);
if (arguments.length === 1) return prototype$(element.parentNode);
return _recursivelyFind(element, 'parentNode', expression, index);}
function down(element, expression, index) {
if (arguments.length === 1) return firstDescendant(element);
element = prototype$(element), expression = expression || 0, index = index || 0;
if (Object.isNumber(expression))
index = expression, expression = '*';
var node = Prototype.Selector.select(expression, element)[index];
return Element.extend(node);}
function previous(element, expression, index) {
return _recursivelyFind(element, 'previousSibling', expression, index);}
function next(element, expression, index) {
return _recursivelyFind(element, 'nextSibling', expression, index);}
function select(element) {
element = prototype$(element);
var expressions = SLICE.call(arguments, 1).join(', ');
return Prototype.Selector.select(expressions, element);}
function adjacent(element) {
element = prototype$(element);
var expressions = SLICE.call(arguments, 1).join(', ');
var siblings = Element.siblings(element),
results = [];
for (var i = 0, sibling; sibling = siblings[i]; i++) {
if (Prototype.Selector.match(sibling, expressions))
results.push(sibling);}
return results;}
function descendantOf_DOM(element, ancestor) {
element = prototype$(element), ancestor = prototype$(ancestor);
if (!element || !ancestor) return false;
while (element = element.parentNode)
if (element === ancestor) return true;
return false;}
function descendantOf_contains(element, ancestor) {
element = prototype$(element), ancestor = prototype$(ancestor);
if (!element || !ancestor) return false;
if (!ancestor.contains) return descendantOf_DOM(element, ancestor);
return ancestor.contains(element) && ancestor !== element;}
function descendantOf_compareDocumentPosition(element, ancestor) {
element = prototype$(element), ancestor = prototype$(ancestor);
if (!element || !ancestor) return false;
return (element.compareDocumentPosition(ancestor) & 8) === 8;}
var descendantOf;
if (DIV.compareDocumentPosition) {
descendantOf = descendantOf_compareDocumentPosition;
} else if (DIV.contains) {
descendantOf = descendantOf_contains;
} else {
descendantOf = descendantOf_DOM;}
Object.extend(methods, {
recursivelyCollect: recursivelyCollect,
ancestors: ancestors,
descendants: descendants,
firstDescendant: firstDescendant,
immediateDescendants: immediateDescendants,
previousSiblings: previousSiblings,
nextSiblings: nextSiblings,
siblings: siblings,
match: match,
up: up,
down: down,
previous: previous,
next: next,
select: select,
adjacent: adjacent,
descendantOf: descendantOf,
getElementsBySelector: select,
childElements: immediateDescendants});
var idCounter = 1;
function identify(element) {
element = prototype$(element);
var id = Element.readAttribute(element, 'id');
if (id) return id;
do { id = 'anonymous_element_' + idCounter++ } while (prototype$(id));
Element.writeAttribute(element, 'id', id);
return id;}
function readAttribute(element, name) {
return prototype$(element).getAttribute(name);}
function readAttribute_IE(element, name) {
element = prototype$(element);
var table = ATTRIBUTE_TRANSLATIONS.read;
if (table.values[name])
return table.values[name](element, name);
if (table.names[name]) name = table.names[name];
if (name.include(':')) {
if (!element.attributes || !element.attributes[name]) return null;
return element.attributes[name].value;}
return element.getAttribute(name);}
function readAttribute_Opera(element, name) {
if (name === 'title') return element.title;
return element.getAttribute(name);}
var PROBLEMATIC_ATTRIBUTE_READING = (function () {
DIV.setAttribute('onclick', []);
var value = DIV.getAttribute('onclick');
var isFunction = Object.isArray(value);
DIV.removeAttribute('onclick');
return isFunction;
})();
if (PROBLEMATIC_ATTRIBUTE_READING) {
readAttribute = readAttribute_IE;
} else if (Prototype.Browser.Opera) {
readAttribute = readAttribute_Opera;}
function writeAttribute(element, name, value) {
element = prototype$(element);
var attributes = {},
table = ATTRIBUTE_TRANSLATIONS.write;
if (typeof name === 'object') {
attributes = name;
} else {
attributes[name] = Object.isUndefined(value) ? true : value;}
for (var attr in attributes) {
name = table.names[attr] || attr;
value = attributes[attr];
if (table.values[attr]) {
value = table.values[attr](element, value);
if (Object.isUndefined(value)) continue;}
if (value === false || value === null)
element.removeAttribute(name);
else if (value === true)
element.setAttribute(name, name);
else element.setAttribute(name, value);}
return element;}
var PROBLEMATIC_HAS_ATTRIBUTE_WITH_CHECKBOXES = (function () {
if (!HAS_EXTENDED_CREATE_ELEMENT_SYNTAX) {
return false;}
var checkbox = document.createElement('<input type="checkbox">');
checkbox.checked = true;
var node = checkbox.getAttributeNode('checked');
return !node || !node.specified;
})();
function hasAttribute(element, attribute) {
attribute = ATTRIBUTE_TRANSLATIONS.has[attribute] || attribute;
var node = prototype$(element).getAttributeNode(attribute);
return !!(node && node.specified);}
function hasAttribute_IE(element, attribute) {
if (attribute === 'checked') {
return element.checked;}
return hasAttribute(element, attribute);}
GLOBAL.Element.Methods.Simulated.hasAttribute =
PROBLEMATIC_HAS_ATTRIBUTE_WITH_CHECKBOXES ?
hasAttribute_IE : hasAttribute;
function classNames(element) {
return new Element.ClassNames(element);}
var regExpCache = {};
function getRegExpForClassName(className) {
if (regExpCache[className]) return regExpCache[className];
var re = new RegExp("(^|\\s+)" + className + "(\\s+|$)");
regExpCache[className] = re;
return re;}
function hasClassName(element, className) {
if (!(element = prototype$(element))) return;
var elementClassName = element.className;
if (elementClassName.length === 0) return false;
if (elementClassName === className) return true;
return getRegExpForClassName(className).test(elementClassName);}
function addClassName(element, className) {
if (!(element = prototype$(element))) return;
if (!hasClassName(element, className))
element.className += (element.className ? ' ' : '') + className;
return element;}
function removeClassName(element, className) {
if (!(element = prototype$(element))) return;
element.className = element.className.replace(
getRegExpForClassName(className), ' ').strip();
return element;}
function toggleClassName(element, className, bool) {
if (!(element = prototype$(element))) return;
if (Object.isUndefined(bool))
bool = !hasClassName(element, className);
var method = Element[bool ? 'addClassName' : 'removeClassName'];
return method(element, className);}
var ATTRIBUTE_TRANSLATIONS = {};
var classProp = 'className',
forProp = 'for';
DIV.setAttribute(classProp, 'x');
if (DIV.className !== 'x') {
DIV.setAttribute('class', 'x');
if (DIV.className === 'x')
classProp = 'class';}
var LABEL = document.createElement('label');
LABEL.setAttribute(forProp, 'x');
if (LABEL.htmlFor !== 'x') {
LABEL.setAttribute('htmlFor', 'x');
if (LABEL.htmlFor === 'x')
forProp = 'htmlFor';}
LABEL = null;
function _getAttr(element, attribute) {
return element.getAttribute(attribute);}
function _getAttr2(element, attribute) {
return element.getAttribute(attribute, 2);}
function _getAttrNode(element, attribute) {
var node = element.getAttributeNode(attribute);
return node ? node.value : '';}
function _getFlag(element, attribute) {
return prototype$(element).hasAttribute(attribute) ? attribute : null;}
DIV.onclick = Prototype.emptyFunction;
var onclickValue = DIV.getAttribute('onclick');
var _getEv;
if (String(onclickValue).indexOf('{') > -1) {
_getEv = function (element, attribute) {
var value = element.getAttribute(attribute);
if (!value) return null;
value = value.toString();
value = value.split('{')[1];
value = value.split('}')[0];
return value.strip();};
} else if (onclickValue === '') {
_getEv = function (element, attribute) {
var value = element.getAttribute(attribute);
if (!value) return null;
return value.strip();};}
ATTRIBUTE_TRANSLATIONS.read = {
names: {
'class': classProp,
'className': classProp,
'for': forProp,
'htmlFor': forProp},
values: {
style: function (element) {
return element.style.cssText.toLowerCase();},
title: function (element) {
return element.title;}}};
ATTRIBUTE_TRANSLATIONS.write = {
names: {
className: 'class',
htmlFor: 'for',
cellpadding: 'cellPadding',
cellspacing: 'cellSpacing'},
values: {
checked: function (element, value) {
value = !!value;
element.checked = value;
return value ? 'checked' : null;},
style: function (element, value) {
element.style.cssText = value ? value : '';}}};
ATTRIBUTE_TRANSLATIONS.has = { names: {} };
Object.extend(ATTRIBUTE_TRANSLATIONS.write.names,
ATTRIBUTE_TRANSLATIONS.read.names);
var CAMEL_CASED_ATTRIBUTE_NAMES = $w('colSpan rowSpan vAlign dateTime ' +
'accessKey tabIndex encType maxLength readOnly longDesc frameBorder');
for (var i = 0, attr; attr = CAMEL_CASED_ATTRIBUTE_NAMES[i]; i++) {
ATTRIBUTE_TRANSLATIONS.write.names[attr.toLowerCase()] = attr;
ATTRIBUTE_TRANSLATIONS.has.names[attr.toLowerCase()] = attr;}
Object.extend(ATTRIBUTE_TRANSLATIONS.read.values, {
href: _getAttr2,
src: _getAttr2,
type: _getAttr,
action: _getAttrNode,
disabled: _getFlag,
checked: _getFlag,
readonly: _getFlag,
multiple: _getFlag,
onload: _getEv,
onunload: _getEv,
onclick: _getEv,
ondblclick: _getEv,
onmousedown: _getEv,
onmouseup: _getEv,
onmouseover: _getEv,
onmousemove: _getEv,
onmouseout: _getEv,
onfocus: _getEv,
onblur: _getEv,
onkeypress: _getEv,
onkeydown: _getEv,
onkeyup: _getEv,
onsubmit: _getEv,
onreset: _getEv,
onselect: _getEv,
onchange: _getEv});
Object.extend(methods, {
identify: identify,
readAttribute: readAttribute,
writeAttribute: writeAttribute,
classNames: classNames,
hasClassName: hasClassName,
addClassName: addClassName,
removeClassName: removeClassName,
toggleClassName: toggleClassName});
function normalizeStyleName(style) {
if (style === 'float' || style === 'styleFloat')
return 'cssFloat';
return style.camelize();}
function normalizeStyleName_IE(style) {
if (style === 'float' || style === 'cssFloat')
return 'styleFloat';
return style.camelize();}
function setStyle(element, styles) {
element = prototype$(element);
var elementStyle = element.style,
match;
if (Object.isString(styles)) {
elementStyle.cssText += ';' + styles;
if (styles.include('opacity')) {
var opacity = styles.match(/opacity:\s*(\d?\.?\d*)/)[1];
Element.setOpacity(element, opacity);}
return element;}
for (var property in styles) {
if (property === 'opacity') {
Element.setOpacity(element, styles[property]);
} else {
var value = styles[property];
if (property === 'float' || property === 'cssFloat') {
property = Object.isUndefined(elementStyle.styleFloat) ?
'cssFloat' : 'styleFloat';}
elementStyle[property] = value;}}
return element;}
function getStyle(element, style) {
element = prototype$(element);
style = normalizeStyleName(style);
var value = element.style[style];
if (!value || value === 'auto') {
var css = document.defaultView.getComputedStyle(element, null);
value = css ? css[style] : null;}
if (style === 'opacity') return value ? parseFloat(value) : 1.0;
return value === 'auto' ? null : value;}
function getStyle_Opera(element, style) {
switch (style) {
case 'height':
case 'width':
if (!Element.visible(element)) return null;
var dim = parseInt(getStyle(element, style), 10);
if (dim !== element['offset' + style.capitalize()])
return dim + 'px';
return Element.measure(element, style);
default:
return getStyle(element, style);}}
function getStyle_IE(element, style) {
element = prototype$(element);
style = normalizeStyleName_IE(style);
var value = element.style[style];
if (!value && element.currentStyle) {
value = element.currentStyle[style];}
if (style === 'opacity') {
if (!STANDARD_CSS_OPACITY_SUPPORTED)
return getOpacity_IE(element);
else return value ? parseFloat(value) : 1.0;}
if (value === 'auto') {
if ((style === 'width' || style === 'height') && Element.visible(element))
return Element.measure(element, style) + 'px';
return null;}
return value;}
function stripAlphaFromFilter_IE(filter) {
return (filter || '').replace(/alpha\([^\)]*\)/gi, '');}
function hasLayout_IE(element) {
if (!element.currentStyle || !element.currentStyle.hasLayout)
element.style.zoom = 1;
return element;}
var STANDARD_CSS_OPACITY_SUPPORTED = (function () {
DIV.style.cssText = "opacity:.55";
return /^0.55/.test(DIV.style.opacity);
})();
function setOpacity(element, value) {
element = prototype$(element);
if (value == 1 || value === '') value = '';
else if (value < 0.00001) value = 0;
element.style.opacity = value;
return element;}
function setOpacity_IE(element, value) {
if (STANDARD_CSS_OPACITY_SUPPORTED)
return setOpacity(element, value);
element = hasLayout_IE(prototype$(element));
var filter = Element.getStyle(element, 'filter'),
style = element.style;
if (value == 1 || value === '') {
filter = stripAlphaFromFilter_IE(filter);
if (filter) style.filter = filter;
else style.removeAttribute('filter');
return element;}
if (value < 0.00001) value = 0;
style.filter = stripAlphaFromFilter_IE(filter) +
' alpha(opacity=' + (value * 100) + ')';
return element;}
function getOpacity(element) {
return Element.getStyle(element, 'opacity');}
function getOpacity_IE(element) {
if (STANDARD_CSS_OPACITY_SUPPORTED)
return getOpacity(element);
var filter = Element.getStyle(element, 'filter');
if (filter.length === 0) return 1.0;
var match = (filter || '').match(/alpha\(opacity=(.*)\)/i);
if (match && match[1]) return parseFloat(match[1]) / 100;
return 1.0;}
Object.extend(methods, {
setStyle: setStyle,
getStyle: getStyle,
setOpacity: setOpacity,
getOpacity: getOpacity});
if ('styleFloat' in DIV.style) {
methods.getStyle = getStyle_IE;
methods.setOpacity = setOpacity_IE;
methods.getOpacity = getOpacity_IE;}
var UID = 0;
GLOBAL.Element.Storage = { UID: 1 };
function getUniqueElementID(element) {
if (element === window) return 0;
if (typeof element._prototypeUID === 'undefined')
element._prototypeUID = Element.Storage.UID++;
return element._prototypeUID;}
function getUniqueElementID_IE(element) {
if (element === window) return 0;
if (element == document) return 1;
return element.uniqueID;}
var HAS_UNIQUE_ID_PROPERTY = ('uniqueID' in DIV);
if (HAS_UNIQUE_ID_PROPERTY)
getUniqueElementID = getUniqueElementID_IE;
function getStorage(element) {
if (!(element = prototype$(element))) return;
var uid = getUniqueElementID(element);
if (!Element.Storage[uid])
Element.Storage[uid] = $H();
return Element.Storage[uid];}
function store(element, key, value) {
if (!(element = prototype$(element))) return;
var storage = getStorage(element);
if (arguments.length === 2) {
storage.update(key);
} else {
storage.set(key, value);}
return element;}
function retrieve(element, key, defaultValue) {
if (!(element = prototype$(element))) return;
var storage = getStorage(element),
value = storage.get(key);
if (Object.isUndefined(value)) {
storage.set(key, defaultValue);
value = defaultValue;}
return value;}
Object.extend(methods, {
getStorage: getStorage,
store: store,
retrieve: retrieve});
var Methods = {},
ByTag = Element.Methods.ByTag,
F = Prototype.BrowserFeatures;
if (!F.ElementExtensions && ('__proto__' in DIV)) {
GLOBAL.HTMLElement = {};
GLOBAL.HTMLElement.prototype = DIV['__proto__'];
F.ElementExtensions = true;}
function checkElementPrototypeDeficiency(tagName) {
if (typeof window.Element === 'undefined') return false;
if (!HAS_EXTENDED_CREATE_ELEMENT_SYNTAX) return false;
var proto = window.Element.prototype;
if (proto) {
var id = '_' + (Math.random() + '').slice(2),
el = document.createElement(tagName);
proto[id] = 'x';
var isBuggy = (el[id] !== 'x');
delete proto[id];
el = null;
return isBuggy;}
return false;}
var HTMLOBJECTELEMENT_PROTOTYPE_BUGGY =
checkElementPrototypeDeficiency('object');
function extendElementWith(element, methods) {
for (var property in methods) {
var value = methods[property];
if (Object.isFunction(value) && !(property in element))
element[property] = value.methodize();}}
var EXTENDED = {};
function elementIsExtended(element) {
var uid = getUniqueElementID(element);
return (uid in EXTENDED);}
function extend(element) {
if (!element || elementIsExtended(element)) return element;
if (element.nodeType !== Node.ELEMENT_NODE || element == window)
return element;
var methods = Object.clone(Methods),
tagName = element.tagName.toUpperCase();
if (ByTag[tagName]) Object.extend(methods, ByTag[tagName]);
extendElementWith(element, methods);
EXTENDED[getUniqueElementID(element)] = true;
return element;}
function extend_IE8(element) {
if (!element || elementIsExtended(element)) return element;
var t = element.tagName;
if (t && (/^(?:object|applet|embed)$/i.test(t))) {
extendElementWith(element, Element.Methods);
extendElementWith(element, Element.Methods.Simulated);
extendElementWith(element, Element.Methods.ByTag[t.toUpperCase()]);}
return element;}
if (F.SpecificElementExtensions) {
extend = HTMLOBJECTELEMENT_PROTOTYPE_BUGGY ? extend_IE8 : Prototype.K;}
function addMethodsToTagName(tagName, methods) {
tagName = tagName.toUpperCase();
if (!ByTag[tagName]) ByTag[tagName] = {};
Object.extend(ByTag[tagName], methods);}
function mergeMethods(destination, methods, onlyIfAbsent) {
if (Object.isUndefined(onlyIfAbsent)) onlyIfAbsent = false;
for (var property in methods) {
var value = methods[property];
if (!Object.isFunction(value)) continue;
if (!onlyIfAbsent || !(property in destination))
destination[property] = value.methodize();}}
function findDOMClass(tagName) {
var klass;
var trans = {
"OPTGROUP": "OptGroup",
"TEXTAREA": "TextArea",
"P": "Paragraph",
"FIELDSET": "FieldSet",
"UL": "UList",
"OL": "OList",
"DL": "DList",
"DIR": "Directory",
"H1": "Heading",
"H2": "Heading",
"H3": "Heading",
"H4": "Heading",
"H5": "Heading",
"H6": "Heading",
"Q": "Quote",
"INS": "Mod",
"DEL": "Mod",
"A": "Anchor",
"IMG": "Image",
"CAPTION": "TableCaption",
"COL": "TableCol",
"COLGROUP": "TableCol",
"THEAD": "TableSection",
"TFOOT": "TableSection",
"TBODY": "TableSection",
"TR": "TableRow",
"TH": "TableCell",
"TD": "TableCell",
"FRAMESET": "FrameSet",
"IFRAME": "IFrame"};
if (trans[tagName]) klass = 'HTML' + trans[tagName] + 'Element';
if (window[klass]) return window[klass];
klass = 'HTML' + tagName + 'Element';
if (window[klass]) return window[klass];
klass = 'HTML' + tagName.capitalize() + 'Element';
if (window[klass]) return window[klass];
var element = document.createElement(tagName),
proto = element['__proto__'] || element.constructor.prototype;
element = null;
return proto;}
function addMethods(methods) {
if (arguments.length === 0) addFormMethods();
if (arguments.length === 2) {
var tagName = methods;
methods = arguments[1];}
if (!tagName) {
Object.extend(Element.Methods, methods || {});
} else {
if (Object.isArray(tagName)) {
for (var i = 0, tag; tag = tagName[i]; i++)
addMethodsToTagName(tag, methods);
} else {
addMethodsToTagName(tagName, methods);}}
var ELEMENT_PROTOTYPE = window.HTMLElement ? HTMLElement.prototype :
Element.prototype;
if (F.ElementExtensions) {
mergeMethods(ELEMENT_PROTOTYPE, Element.Methods);
mergeMethods(ELEMENT_PROTOTYPE, Element.Methods.Simulated, true);}
if (F.SpecificElementExtensions) {
for (var tag in Element.Methods.ByTag) {
var klass = findDOMClass(tag);
if (Object.isUndefined(klass)) continue;
mergeMethods(klass.prototype, ByTag[tag]);}}
Object.extend(Element, Element.Methods);
Object.extend(Element, Element.Methods.Simulated);
delete Element.ByTag;
delete Element.Simulated;
Element.extend.refresh();
ELEMENT_CACHE = {};}
Object.extend(GLOBAL.Element, {
extend: extend,
addMethods: addMethods});
if (extend === Prototype.K) {
GLOBAL.Element.extend.refresh = Prototype.emptyFunction;
} else {
GLOBAL.Element.extend.refresh = function () {
if (Prototype.BrowserFeatures.ElementExtensions) return;
Object.extend(Methods, Element.Methods);
Object.extend(Methods, Element.Methods.Simulated);
EXTENDED = {};};}
function addFormMethods() {
Object.extend(Form, Form.Methods);
Object.extend(Form.Element, Form.Element.Methods);
Object.extend(Element.Methods.ByTag, {
"FORM": Object.clone(Form.Methods),
"INPUT": Object.clone(Form.Element.Methods),
"SELECT": Object.clone(Form.Element.Methods),
"TEXTAREA": Object.clone(Form.Element.Methods),
"BUTTON": Object.clone(Form.Element.Methods)});}
Element.addMethods(methods);
function destroyCache_IE() {
DIV = null;
ELEMENT_CACHE = null;}
if (window.attachEvent)
window.attachEvent('onunload', destroyCache_IE);
})(this);
(function () {
function toDecimal(pctString) {
var match = pctString.match(/^(\d+)%?$/i);
if (!match) return null;
return (Number(match[1]) / 100);}
function getRawStyle(element, style) {
element = prototype$(element);
var value = element.style[style];
if (!value || value === 'auto') {
var css = document.defaultView.getComputedStyle(element, null);
value = css ? css[style] : null;}
if (style === 'opacity') return value ? parseFloat(value) : 1.0;
return value === 'auto' ? null : value;}
function getRawStyle_IE(element, style) {
var value = element.style[style];
if (!value && element.currentStyle) {
value = element.currentStyle[style];}
return value;}
function getContentWidth(element, context) {
var boxWidth = element.offsetWidth;
var bl = getPixelValue(element, 'borderLeftWidth', context) || 0;
var br = getPixelValue(element, 'borderRightWidth', context) || 0;
var pl = getPixelValue(element, 'paddingLeft', context) || 0;
var pr = getPixelValue(element, 'paddingRight', context) || 0;
return boxWidth - bl - br - pl - pr;}
if (!Object.isUndefined(document.documentElement.currentStyle) && !Prototype.Browser.Opera) {
getRawStyle = getRawStyle_IE;}
function getPixelValue(value, property, context) {
var element = null;
if (Object.isElement(value)) {
element = value;
value = getRawStyle(element, property);}
if (value === null || Object.isUndefined(value)) {
return null;}
if ((/^(?:-)?\d+(\.\d+)?(px)?$/i).test(value)) {
return window.parseFloat(value);}
var isPercentage = value.include('%'),
isViewport = (context === document.viewport);
if (/\d/.test(value) && element && element.runtimeStyle && !(isPercentage && isViewport)) {
var style = element.style.left,
rStyle = element.runtimeStyle.left;
element.runtimeStyle.left = element.currentStyle.left;
element.style.left = value || 0;
value = element.style.pixelLeft;
element.style.left = style;
element.runtimeStyle.left = rStyle;
return value;}
if (element && isPercentage) {
context = context || element.parentNode;
var decimal = toDecimal(value),
whole = null;
var isHorizontal = property.include('left') || property.include('right') ||
property.include('width');
var isVertical = property.include('top') || property.include('bottom') ||
property.include('height');
if (context === document.viewport) {
if (isHorizontal) {
whole = document.viewport.getWidth();
} else if (isVertical) {
whole = document.viewport.getHeight();}
} else {
if (isHorizontal) {
whole = prototype$(context).measure('width');
} else if (isVertical) {
whole = prototype$(context).measure('height');}}
return (whole === null) ? 0 : whole * decimal;}
return 0;}
function toCSSPixels(number) {
if (Object.isString(number) && number.endsWith('px'))
return number;
return number + 'px';}
function isDisplayed(element) {
while (element && element.parentNode) {
var display = element.getStyle('display');
if (display === 'none') {
return false;}
element = prototype$(element.parentNode);}
return true;}
var hasLayout = Prototype.K;
if ('currentStyle' in document.documentElement) {
hasLayout = function (element) {
if (!element.currentStyle.hasLayout) {
element.style.zoom = 1;}
return element;};}
function cssNameFor(key) {
if (key.include('border')) key = key + '-width';
return key.camelize();}
Element.Layout = Class.create(Hash, {
initialize: function ($super, element, preCompute) {
$super();
this.element = prototype$(element);
Element.Layout.PROPERTIES.each(function (property) {
this._set(property, null);
}, this);
if (preCompute) {
this._preComputing = true;
this._begin();
Element.Layout.PROPERTIES.each(this._compute, this);
this._end();
this._preComputing = false;}},
_set: function (property, value) {
return Hash.prototype.set.call(this, property, value);},
set: function (property, value) {
throw "Properties of Element.Layout are read-only.";},
get: function ($super, property) {
var value = $super(property);
return value === null ? this._compute(property) : value;},
_begin: function () {
if (this._isPrepared()) return;
var element = this.element;
if (isDisplayed(element)) {
this._setPrepared(true);
return;}
var originalStyles = {
position: element.style.position || '',
width: element.style.width || '',
visibility: element.style.visibility || '',
display: element.style.display || ''};
element.store('prototype_original_styles', originalStyles);
var position = getRawStyle(element, 'position'),
width = element.offsetWidth;
if (width === 0 || width === null) {
element.style.display = 'block';
width = element.offsetWidth;}
var context = (position === 'fixed') ? document.viewport :
element.parentNode;
var tempStyles = {
visibility: 'hidden',
display: 'block'};
if (position !== 'fixed') tempStyles.position = 'absolute';
element.setStyle(tempStyles);
var positionedWidth = element.offsetWidth,
newWidth;
if (width && (positionedWidth === width)) {
newWidth = getContentWidth(element, context);
} else if (position === 'absolute' || position === 'fixed') {
newWidth = getContentWidth(element, context);
} else {
var parent = element.parentNode,
pLayout = prototype$(parent).getLayout();
newWidth = pLayout.get('width') -
this.get('margin-left') -
this.get('border-left') -
this.get('padding-left') -
this.get('padding-right') -
this.get('border-right') -
this.get('margin-right');}
element.setStyle({ width: newWidth + 'px' });
this._setPrepared(true);},
_end: function () {
var element = this.element;
var originalStyles = element.retrieve('prototype_original_styles');
element.store('prototype_original_styles', null);
element.setStyle(originalStyles);
this._setPrepared(false);},
_compute: function (property) {
var COMPUTATIONS = Element.Layout.COMPUTATIONS;
if (!(property in COMPUTATIONS)) {
throw "Property not found.";}
return this._set(property, COMPUTATIONS[property].call(this, this.element));},
_isPrepared: function () {
return this.element.retrieve('prototype_element_layout_prepared', false);},
_setPrepared: function (bool) {
return this.element.store('prototype_element_layout_prepared', bool);},
toObject: function () {
var args = $A(arguments);
var keys = (args.length === 0) ? Element.Layout.PROPERTIES :
args.join(' ').split(' ');
var obj = {};
keys.each(function (key) {
if (!Element.Layout.PROPERTIES.include(key)) return;
var value = this.get(key);
if (value != null) obj[key] = value;
}, this);
return obj;},
toHash: function () {
var obj = this.toObject.apply(this, arguments);
return new Hash(obj);},
toCSS: function () {
var args = $A(arguments);
var keys = (args.length === 0) ? Element.Layout.PROPERTIES :
args.join(' ').split(' ');
var css = {};
keys.each(function (key) {
if (!Element.Layout.PROPERTIES.include(key)) return;
if (Element.Layout.COMPOSITE_PROPERTIES.include(key)) return;
var value = this.get(key);
if (value != null) css[cssNameFor(key)] = value + 'px';
}, this);
return css;},
inspect: function () {
return "#<Element.Layout>";}});
Object.extend(Element.Layout, {
PROPERTIES: $w('height width top left right bottom border-left border-right border-top border-bottom padding-left padding-right padding-top padding-bottom margin-top margin-bottom margin-left margin-right padding-box-width padding-box-height border-box-width border-box-height margin-box-width margin-box-height'),
COMPOSITE_PROPERTIES: $w('padding-box-width padding-box-height margin-box-width margin-box-height border-box-width border-box-height'),
COMPUTATIONS: {
'height': function (element) {
if (!this._preComputing) this._begin();
var bHeight = this.get('border-box-height');
if (bHeight <= 0) {
if (!this._preComputing) this._end();
return 0;}
var bTop = this.get('border-top'),
bBottom = this.get('border-bottom');
var pTop = this.get('padding-top'),
pBottom = this.get('padding-bottom');
if (!this._preComputing) this._end();
return bHeight - bTop - bBottom - pTop - pBottom;},
'width': function (element) {
if (!this._preComputing) this._begin();
var bWidth = this.get('border-box-width');
if (bWidth <= 0) {
if (!this._preComputing) this._end();
return 0;}
var bLeft = this.get('border-left'),
bRight = this.get('border-right');
var pLeft = this.get('padding-left'),
pRight = this.get('padding-right');
if (!this._preComputing) this._end();
return bWidth - bLeft - bRight - pLeft - pRight;},
'padding-box-height': function (element) {
var height = this.get('height'),
pTop = this.get('padding-top'),
pBottom = this.get('padding-bottom');
return height + pTop + pBottom;},
'padding-box-width': function (element) {
var width = this.get('width'),
pLeft = this.get('padding-left'),
pRight = this.get('padding-right');
return width + pLeft + pRight;},
'border-box-height': function (element) {
if (!this._preComputing) this._begin();
var height = element.offsetHeight;
if (!this._preComputing) this._end();
return height;},
'border-box-width': function (element) {
if (!this._preComputing) this._begin();
var width = element.offsetWidth;
if (!this._preComputing) this._end();
return width;},
'margin-box-height': function (element) {
var bHeight = this.get('border-box-height'),
mTop = this.get('margin-top'),
mBottom = this.get('margin-bottom');
if (bHeight <= 0) return 0;
return bHeight + mTop + mBottom;},
'margin-box-width': function (element) {
var bWidth = this.get('border-box-width'),
mLeft = this.get('margin-left'),
mRight = this.get('margin-right');
if (bWidth <= 0) return 0;
return bWidth + mLeft + mRight;},
'top': function (element) {
var offset = element.positionedOffset();
return offset.top;},
'bottom': function (element) {
var offset = element.positionedOffset(),
parent = element.getOffsetParent(),
pHeight = parent.measure('height');
var mHeight = this.get('border-box-height');
return pHeight - mHeight - offset.top;},
'left': function (element) {
var offset = element.positionedOffset();
return offset.left;},
'right': function (element) {
var offset = element.positionedOffset(),
parent = element.getOffsetParent(),
pWidth = parent.measure('width');
var mWidth = this.get('border-box-width');
return pWidth - mWidth - offset.left;},
'padding-top': function (element) {
return getPixelValue(element, 'paddingTop');},
'padding-bottom': function (element) {
return getPixelValue(element, 'paddingBottom');},
'padding-left': function (element) {
return getPixelValue(element, 'paddingLeft');},
'padding-right': function (element) {
return getPixelValue(element, 'paddingRight');},
'border-top': function (element) {
return getPixelValue(element, 'borderTopWidth');},
'border-bottom': function (element) {
return getPixelValue(element, 'borderBottomWidth');},
'border-left': function (element) {
return getPixelValue(element, 'borderLeftWidth');},
'border-right': function (element) {
return getPixelValue(element, 'borderRightWidth');},
'margin-top': function (element) {
return getPixelValue(element, 'marginTop');},
'margin-bottom': function (element) {
return getPixelValue(element, 'marginBottom');},
'margin-left': function (element) {
return getPixelValue(element, 'marginLeft');},
'margin-right': function (element) {
return getPixelValue(element, 'marginRight');}}});
if ('getBoundingClientRect' in document.documentElement) {
Object.extend(Element.Layout.COMPUTATIONS, {
'right': function (element) {
var parent = hasLayout(element.getOffsetParent());
var rect = element.getBoundingClientRect(),
pRect = parent.getBoundingClientRect();
return (pRect.right - rect.right).round();},
'bottom': function (element) {
var parent = hasLayout(element.getOffsetParent());
var rect = element.getBoundingClientRect(),
pRect = parent.getBoundingClientRect();
return (pRect.bottom - rect.bottom).round();}});}
Element.Offset = Class.create({
initialize: function (left, top) {
this.left = left.round();
this.top = top.round();
this[0] = this.left;
this[1] = this.top;},
relativeTo: function (offset) {
return new Element.Offset(
this.left - offset.left,
this.top - offset.top
);},
inspect: function () {
return "#<Element.Offset left: #{left} top: #{top}>".interpolate(this);},
toString: function () {
return "[#{left}, #{top}]".interpolate(this);},
toArray: function () {
return [this.left, this.top];}});
function getLayout(element, preCompute) {
return new Element.Layout(element, preCompute);}
function measure(element, property) {
return prototype$(element).getLayout().get(property);}
function getHeight(element) {
return Element.getDimensions(element).height;}
function getWidth(element) {
return Element.getDimensions(element).width;}
function getDimensions(element) {
element = prototype$(element);
var display = Element.getStyle(element, 'display');
if (display && display !== 'none') {
return { width: element.offsetWidth, height: element.offsetHeight };}
var style = element.style;
var originalStyles = {
visibility: style.visibility,
position: style.position,
display: style.display};
var newStyles = {
visibility: 'hidden',
display: 'block'};
if (originalStyles.position !== 'fixed')
newStyles.position = 'absolute';
Element.setStyle(element, newStyles);
var dimensions = {
width: element.offsetWidth,
height: element.offsetHeight};
Element.setStyle(element, originalStyles);
return dimensions;}
function getOffsetParent(element) {
element = prototype$(element);
function selfOrBody(element) {
return isHtml(element) ? prototype$(document.body) : prototype$(element);}
if (isDocument(element) || isDetached(element) || isBody(element) || isHtml(element))
return prototype$(document.body);
var isInline = (Element.getStyle(element, 'display') === 'inline');
if (!isInline && element.offsetParent) return selfOrBody(element.offsetParent);
while ((element = element.parentNode) && element !== document.body) {
if (Element.getStyle(element, 'position') !== 'static') {
return selfOrBody(element);}}
return prototype$(document.body);}
function cumulativeOffset(element) {
element = prototype$(element);
var valueT = 0,
valueL = 0;
if (element.parentNode) {
do {
valueT += element.offsetTop || 0;
valueL += element.offsetLeft || 0;
element = element.offsetParent;
} while (element);}
return new Element.Offset(valueL, valueT);}
function positionedOffset(element) {
element = prototype$(element);
var layout = element.getLayout();
var valueT = 0,
valueL = 0;
do {
valueT += element.offsetTop || 0;
valueL += element.offsetLeft || 0;
element = element.offsetParent;
if (element) {
if (isBody(element)) break;
var p = Element.getStyle(element, 'position');
if (p !== 'static') break;}
} while (element);
valueL -= layout.get('margin-left');
valueT -= layout.get('margin-top');
return new Element.Offset(valueL, valueT);}
function cumulativeScrollOffset(element) {
var valueT = 0,
valueL = 0;
do {
if (element === document.body) {
var bodyScrollNode = document.documentElement || document.body.parentNode || document.body;
valueT += !Object.isUndefined(window.pageYOffset) ? window.pageYOffset : bodyScrollNode.scrollTop || 0;
valueL += !Object.isUndefined(window.pageXOffset) ? window.pageXOffset : bodyScrollNode.scrollLeft || 0;
break;
} else {
valueT += element.scrollTop || 0;
valueL += element.scrollLeft || 0;
element = element.parentNode;}
} while (element);
return new Element.Offset(valueL, valueT);}
function viewportOffset(forElement) {
var valueT = 0,
valueL = 0,
docBody = document.body;
forElement = prototype$(forElement);
var element = forElement;
do {
valueT += element.offsetTop || 0;
valueL += element.offsetLeft || 0;
if (element.offsetParent == docBody &&
Element.getStyle(element, 'position') == 'absolute') break;
} while (element = element.offsetParent);
element = forElement;
do {
if (element != docBody) {
valueT -= element.scrollTop || 0;
valueL -= element.scrollLeft || 0;}
} while (element = element.parentNode);
return new Element.Offset(valueL, valueT);}
function absolutize(element) {
element = prototype$(element);
if (Element.getStyle(element, 'position') === 'absolute') {
return element;}
var offsetParent = getOffsetParent(element);
var eOffset = element.viewportOffset(),
pOffset = offsetParent.viewportOffset();
var offset = eOffset.relativeTo(pOffset);
var layout = element.getLayout();
element.store('prototype_absolutize_original_styles', {
position: element.getStyle('position'),
left: element.getStyle('left'),
top: element.getStyle('top'),
width: element.getStyle('width'),
height: element.getStyle('height')});
element.setStyle({
position: 'absolute',
top: offset.top + 'px',
left: offset.left + 'px',
width: layout.get('width') + 'px',
height: layout.get('height') + 'px'});
return element;}
function relativize(element) {
element = prototype$(element);
if (Element.getStyle(element, 'position') === 'relative') {
return element;}
var originalStyles =
element.retrieve('prototype_absolutize_original_styles');
if (originalStyles) element.setStyle(originalStyles);
return element;}
function scrollTo(element) {
element = prototype$(element);
var pos = Element.cumulativeOffset(element);
window.scrollTo(pos.left, pos.top);
return element;}
function makePositioned(element) {
element = prototype$(element);
var position = Element.getStyle(element, 'position'),
styles = {};
if (position === 'static' || !position) {
styles.position = 'relative';
if (Prototype.Browser.Opera) {
styles.top = 0;
styles.left = 0;}
Element.setStyle(element, styles);
Element.store(element, 'prototype_made_positioned', true);}
return element;}
function undoPositioned(element) {
element = prototype$(element);
var storage = Element.getStorage(element),
madePositioned = storage.get('prototype_made_positioned');
if (madePositioned) {
storage.unset('prototype_made_positioned');
Element.setStyle(element, {
position: '',
top: '',
bottom: '',
left: '',
right: ''});}
return element;}
function makeClipping(element) {
element = prototype$(element);
var storage = Element.getStorage(element),
madeClipping = storage.get('prototype_made_clipping');
if (Object.isUndefined(madeClipping)) {
var overflow = Element.getStyle(element, 'overflow');
storage.set('prototype_made_clipping', overflow);
if (overflow !== 'hidden')
element.style.overflow = 'hidden';}
return element;}
function undoClipping(element) {
element = prototype$(element);
var storage = Element.getStorage(element),
overflow = storage.get('prototype_made_clipping');
if (!Object.isUndefined(overflow)) {
storage.unset('prototype_made_clipping');
element.style.overflow = overflow || '';}
return element;}
function clonePosition(element, source, options) {
options = Object.extend({
setLeft: true,
setTop: true,
setWidth: true,
setHeight: true,
offsetTop: 0,
offsetLeft: 0
}, options || {});
var docEl = document.documentElement;
source = prototype$(source);
element = prototype$(element);
var p, delta, layout, styles = {};
if (options.setLeft || options.setTop) {
p = Element.viewportOffset(source);
delta = [0, 0];
if (Element.getStyle(element, 'position') === 'absolute') {
var parent = Element.getOffsetParent(element);
if (parent !== document.body) delta = Element.viewportOffset(parent);}}
function pageScrollXY() {
var x = 0,
y = 0;
if (Object.isNumber(window.pageXOffset)) {
x = window.pageXOffset;
y = window.pageYOffset;
} else if (document.body && (document.body.scrollLeft || document.body.scrollTop)) {
x = document.body.scrollLeft;
y = document.body.scrollTop;
} else if (docEl && (docEl.scrollLeft || docEl.scrollTop)) {
x = docEl.scrollLeft;
y = docEl.scrollTop;}
return { x: x, y: y };}
var pageXY = pageScrollXY();
if (options.setWidth || options.setHeight) {
layout = Element.getLayout(source);}
if (options.setLeft)
styles.left = (p[0] + pageXY.x - delta[0] + options.offsetLeft) + 'px';
if (options.setTop)
styles.top = (p[1] + pageXY.y - delta[1] + options.offsetTop) + 'px';
var currentLayout = element.getLayout();
if (options.setWidth) {
styles.width = layout.get('width') + 'px';}
if (options.setHeight) {
styles.height = layout.get('height') + 'px';}
return Element.setStyle(element, styles);}
if (Prototype.Browser.IE) {
getOffsetParent = getOffsetParent.wrap(
function (proceed, element) {
element = prototype$(element);
if (isDocument(element) || isDetached(element) || isBody(element) || isHtml(element))
return prototype$(document.body);
var position = element.getStyle('position');
if (position !== 'static') return proceed(element);
element.setStyle({ position: 'relative' });
var value = proceed(element);
element.setStyle({ position: position });
return value;}
);
positionedOffset = positionedOffset.wrap(function (proceed, element) {
element = prototype$(element);
if (!element.parentNode) return new Element.Offset(0, 0);
var position = element.getStyle('position');
if (position !== 'static') return proceed(element);
var offsetParent = element.getOffsetParent();
if (offsetParent && offsetParent.getStyle('position') === 'fixed')
hasLayout(offsetParent);
element.setStyle({ position: 'relative' });
var value = proceed(element);
element.setStyle({ position: position });
return value;});
} else if (Prototype.Browser.Webkit) {
cumulativeOffset = function (element) {
element = prototype$(element);
var valueT = 0,
valueL = 0;
do {
valueT += element.offsetTop || 0;
valueL += element.offsetLeft || 0;
if (element.offsetParent == document.body) {
if (Element.getStyle(element, 'position') == 'absolute') break;}
element = element.offsetParent;
} while (element);
return new Element.Offset(valueL, valueT);};}
Element.addMethods({
getLayout: getLayout,
measure: measure,
getWidth: getWidth,
getHeight: getHeight,
getDimensions: getDimensions,
getOffsetParent: getOffsetParent,
cumulativeOffset: cumulativeOffset,
positionedOffset: positionedOffset,
cumulativeScrollOffset: cumulativeScrollOffset,
viewportOffset: viewportOffset,
absolutize: absolutize,
relativize: relativize,
scrollTo: scrollTo,
makePositioned: makePositioned,
undoPositioned: undoPositioned,
makeClipping: makeClipping,
undoClipping: undoClipping,
clonePosition: clonePosition});
function isBody(element) {
return element.nodeName.toUpperCase() === 'BODY';}
function isHtml(element) {
return element.nodeName.toUpperCase() === 'HTML';}
function isDocument(element) {
return element.nodeType === Node.DOCUMENT_NODE;}
function isDetached(element) {
return element !== document.body &&
!Element.descendantOf(element, document.body);}
if ('getBoundingClientRect' in document.documentElement) {
Element.addMethods({
viewportOffset: function (element) {
element = prototype$(element);
if (isDetached(element)) return new Element.Offset(0, 0);
var rect = element.getBoundingClientRect(),
docEl = document.documentElement;
return new Element.Offset(rect.left - docEl.clientLeft,
rect.top - docEl.clientTop);}});}
})();
(function () {
var IS_OLD_OPERA = Prototype.Browser.Opera &&
(window.parseFloat(window.opera.version()) < 9.5);
var ROOT = null;
function getRootElement() {
if (ROOT) return ROOT;
ROOT = IS_OLD_OPERA ? document.body : document.documentElement;
return ROOT;}
function getDimensions() {
return { width: this.getWidth(), height: this.getHeight() };}
function getWidth() {
return getRootElement().clientWidth;}
function getHeight() {
return getRootElement().clientHeight;}
function getScrollOffsets() {
var x = window.pageXOffset || document.documentElement.scrollLeft ||
document.body.scrollLeft;
var y = window.pageYOffset || document.documentElement.scrollTop ||
document.body.scrollTop;
return new Element.Offset(x, y);}
document.viewport = {
getDimensions: getDimensions,
getWidth: getWidth,
getHeight: getHeight,
getScrollOffsets: getScrollOffsets};
})();
window.$$ = function () {
var expression = $A(arguments).join(', ');
return Prototype.Selector.select(expression, document);};
Prototype.Selector = (function () {
function select() {
throw new Error('Method "Prototype.Selector.select" must be defined.');}
function match() {
throw new Error('Method "Prototype.Selector.match" must be defined.');}
function find(elements, expression, index) {
index = index || 0;
var match = Prototype.Selector.match,
length = elements.length,
matchIndex = 0,
i;
for (i = 0; i < length; i++) {
if (match(elements[i], expression) && index == matchIndex++) {
return Element.extend(elements[i]);}}}
function extendElements(elements) {
for (var i = 0, length = elements.length; i < length; i++) {
Element.extend(elements[i]);}
return elements;}
var K = Prototype.K;
return {
select: select,
match: match,
find: find,
extendElements: (Element.extend === K) ? K : extendElements,
extendElement: Element.extend};
})();
Prototype._original_property = window.Sizzle;
;
(function () {
function fakeDefine(fn) {
Prototype._actual_sizzle = fn();}
fakeDefine.amd = true;
if (typeof define !== 'undefined' && define.amd) {
Prototype._original_define = define;
Prototype._actual_sizzle = null;
window.define = fakeDefine;}
})();
(function (window) {
var i,
support,
Expr,
getText,
isXML,
compile,
select,
outermostContext,
sortInput,
hasDuplicate,
setDocument,
document,
docElem,
documentIsHTML,
rbuggyQSA,
rbuggyMatches,
matches,
contains,
expando = "sizzle" + -(new Date()),
preferredDoc = window.document,
dirruns = 0,
done = 0,
classCache = createCache(),
tokenCache = createCache(),
compilerCache = createCache(),
sortOrder = function (a, b) {
if (a === b) {
hasDuplicate = true;}
return 0;},
strundefined = typeof undefined,
MAX_NEGATIVE = 1 << 31,
hasOwn = ({}).hasOwnProperty,
arr = [],
pop = arr.pop,
push_native = arr.push,
push = arr.push,
slice = arr.slice,
indexOf = arr.indexOf || function (elem) {
var i = 0,
len = this.length;
for (; i < len; i++) {
if (this[i] === elem) {
return i;}}
return -1;},
booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
whitespace = "[\\x20\\t\\r\\n\\f]",
characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
identifier = characterEncoding.replace("w", "w#"),
attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
"*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",
pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace(3, 8) + ")*)|.*)\\)|)",
rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
rpseudo = new RegExp(pseudos),
ridentifier = new RegExp("^" + identifier + "$"),
matchExpr = {
"ID": new RegExp("^#(" + characterEncoding + ")"),
"CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
"TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
"ATTR": new RegExp("^" + attributes),
"PSEUDO": new RegExp("^" + pseudos),
"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
"*(\\d+)|))" + whitespace + "*\\)|)", "i"),
"bool": new RegExp("^(?:" + booleans + ")$", "i"),
"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")},
rinputs = /^(?:input|select|textarea|button)$/i,
rheader = /^h\d$/i,
rnative = /^[^{]+\{\s*\[native \w/,
rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
rsibling = /[+~]/,
rescape = /'|\\/g,
runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
funescape = function (_, escaped, escapedWhitespace) {
var high = "0x" + escaped - 0x10000;
return high !== high || escapedWhitespace ?
escaped :
high < 0 ?
String.fromCharCode(high + 0x10000) :
String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);};
try {
push.apply(
(arr = slice.call(preferredDoc.childNodes)),
preferredDoc.childNodes
);
arr[preferredDoc.childNodes.length].nodeType;
} catch (e) {
push = {
apply: arr.length ?
function (target, els) {
push_native.apply(target, slice.call(els));
} :
function (target, els) {
var j = target.length,
i = 0;
while ((target[j++] = els[i++])) {}
target.length = j - 1;}};}
function Sizzle(selector, context, results, seed) {
var match, elem, m, nodeType,
i, groups, old, nid, newContext, newSelector;
if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
setDocument(context);}
context = context || document;
results = results || [];
if (!selector || typeof selector !== "string") {
return results;}
if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
return [];}
if (documentIsHTML && !seed) {
if ((match = rquickExpr.exec(selector))) {
if ((m = match[1])) {
if (nodeType === 9) {
elem = context.getElementById(m);
if (elem && elem.parentNode) {
if (elem.id === m) {
results.push(elem);
return results;}
} else {
return results;}
} else {
if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) &&
contains(context, elem) && elem.id === m) {
results.push(elem);
return results;}}
} else if (match[2]) {
push.apply(results, context.getElementsByTagName(selector));
return results;
} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
push.apply(results, context.getElementsByClassName(m));
return results;}}
if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
nid = old = expando;
newContext = context;
newSelector = nodeType === 9 && selector;
if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
groups = tokenize(selector);
if ((old = context.getAttribute("id"))) {
nid = old.replace(rescape, "\\$&");
} else {
context.setAttribute("id", nid);}
nid = "[id='" + nid + "'] ";
i = groups.length;
while (i--) {
groups[i] = nid + toSelector(groups[i]);}
newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
newSelector = groups.join(",");}
if (newSelector) {
try {
push.apply(results,
newContext.querySelectorAll(newSelector)
);
return results;
} catch (qsaError) {} finally {
if (!old) {
context.removeAttribute("id");}}}}}
return select(selector.replace(rtrim, "$1"), context, results, seed);}
function createCache() {
var keys = [];
function cache(key, value) {
if (keys.push(key + " ") > Expr.cacheLength) {
delete cache[keys.shift()];}
return (cache[key + " "] = value);}
return cache;}
function markFunction(fn) {
fn[expando] = true;
return fn;}
function assert(fn) {
var div = document.createElement("div");
try {
return !!fn(div);
} catch (e) {
return false;
} finally {
if (div.parentNode) {
div.parentNode.removeChild(div);}
div = null;}}
function addHandle(attrs, handler) {
var arr = attrs.split("|"),
i = attrs.length;
while (i--) {
Expr.attrHandle[arr[i]] = handler;}}
function siblingCheck(a, b) {
var cur = b && a,
diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
(~b.sourceIndex || MAX_NEGATIVE) -
(~a.sourceIndex || MAX_NEGATIVE);
if (diff) {
return diff;}
if (cur) {
while ((cur = cur.nextSibling)) {
if (cur === b) {
return -1;}}}
return a ? 1 : -1;}
function createInputPseudo(type) {
return function (elem) {
var name = elem.nodeName.toLowerCase();
return name === "input" && elem.type === type;};}
function createButtonPseudo(type) {
return function (elem) {
var name = elem.nodeName.toLowerCase();
return (name === "input" || name === "button") && elem.type === type;};}
function createPositionalPseudo(fn) {
return markFunction(function (argument) {
argument = +argument;
return markFunction(function (seed, matches) {
var j,
matchIndexes = fn([], seed.length, argument),
i = matchIndexes.length;
while (i--) {
if (seed[(j = matchIndexes[i])]) {
seed[j] = !(matches[j] = seed[j]);}}});});}
function testContext(context) {
return context && typeof context.getElementsByTagName !== strundefined && context;}
support = Sizzle.support = {};
isXML = Sizzle.isXML = function (elem) {
var documentElement = elem && (elem.ownerDocument || elem).documentElement;
return documentElement ? documentElement.nodeName !== "HTML" : false;};
setDocument = Sizzle.setDocument = function (node) {
var hasCompare,
doc = node ? node.ownerDocument || node : preferredDoc,
parent = doc.defaultView;
if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
return document;}
document = doc;
docElem = doc.documentElement;
documentIsHTML = !isXML(doc);
if (parent && parent !== parent.top) {
if (parent.addEventListener) {
parent.addEventListener("unload", function () {
setDocument();
}, false);
} else if (parent.attachEvent) {
parent.attachEvent("onunload", function () {
setDocument();});}}
support.attributes = assert(function (div) {
div.className = "i";
return !div.getAttribute("className");});
support.getElementsByTagName = assert(function (div) {
div.appendChild(doc.createComment(""));
return !div.getElementsByTagName("*").length;});
support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function (div) {
div.innerHTML = "<div class='a'></div><div class='a i'></div>";
div.firstChild.className = "i";
return div.getElementsByClassName("i").length === 2;});
support.getById = assert(function (div) {
docElem.appendChild(div).id = expando;
return !doc.getElementsByName || !doc.getElementsByName(expando).length;});
if (support.getById) {
Expr.find["ID"] = function (id, context) {
if (typeof context.getElementById !== strundefined && documentIsHTML) {
var m = context.getElementById(id);
return m && m.parentNode ? [m] : [];}};
Expr.filter["ID"] = function (id) {
var attrId = id.replace(runescape, funescape);
return function (elem) {
return elem.getAttribute("id") === attrId;};};
} else {
delete Expr.find["ID"];
Expr.filter["ID"] = function (id) {
var attrId = id.replace(runescape, funescape);
return function (elem) {
var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
return node && node.value === attrId;};};}
Expr.find["TAG"] = support.getElementsByTagName ?
function (tag, context) {
if (typeof context.getElementsByTagName !== strundefined) {
return context.getElementsByTagName(tag);}
} :
function (tag, context) {
var elem,
tmp = [],
i = 0,
results = context.getElementsByTagName(tag);
if (tag === "*") {
while ((elem = results[i++])) {
if (elem.nodeType === 1) {
tmp.push(elem);}}
return tmp;}
return results;};
Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
return context.getElementsByClassName(className);}};
rbuggyMatches = [];
rbuggyQSA = [];
if ((support.qsa = rnative.test(doc.querySelectorAll))) {
assert(function (div) {
div.innerHTML = "<select t=''><option selected=''></option></select>";
if (div.querySelectorAll("[t^='']").length) {
rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");}
if (!div.querySelectorAll("[selected]").length) {
rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");}
if (!div.querySelectorAll(":checked").length) {
rbuggyQSA.push(":checked");}});
assert(function (div) {
var input = doc.createElement("input");
input.setAttribute("type", "hidden");
div.appendChild(input).setAttribute("name", "D");
if (div.querySelectorAll("[name=d]").length) {
rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");}
if (!div.querySelectorAll(":enabled").length) {
rbuggyQSA.push(":enabled", ":disabled");}
div.querySelectorAll("*,:x");
rbuggyQSA.push(",.*:");});}
if ((support.matchesSelector = rnative.test((matches = docElem.webkitMatchesSelector ||
docElem.mozMatchesSelector ||
docElem.oMatchesSelector ||
docElem.msMatchesSelector)))) {
assert(function (div) {
support.disconnectedMatch = matches.call(div, "div");
matches.call(div, "[s!='']:x");
rbuggyMatches.push("!=", pseudos);});}
rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
hasCompare = rnative.test(docElem.compareDocumentPosition);
contains = hasCompare || rnative.test(docElem.contains) ?
function (a, b) {
var adown = a.nodeType === 9 ? a.documentElement : a,
bup = b && b.parentNode;
return a === bup || !!(bup && bup.nodeType === 1 && (
adown.contains ?
adown.contains(bup) :
a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
));
} :
function (a, b) {
if (b) {
while ((b = b.parentNode)) {
if (b === a) {
return true;}}}
return false;};
sortOrder = hasCompare ?
function (a, b) {
if (a === b) {
hasDuplicate = true;
return 0;}
var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
if (compare) {
return compare;}
compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
a.compareDocumentPosition(b) :
1;
if (compare & 1 ||
(!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
return -1;}
if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
return 1;}
return sortInput ?
(indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :
0;}
return compare & 4 ? -1 : 1;
} :
function (a, b) {
if (a === b) {
hasDuplicate = true;
return 0;}
var cur,
i = 0,
aup = a.parentNode,
bup = b.parentNode,
ap = [a],
bp = [b];
if (!aup || !bup) {
return a === doc ? -1 :
b === doc ? 1 :
aup ? -1 :
bup ? 1 :
sortInput ?
(indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :
0;
} else if (aup === bup) {
return siblingCheck(a, b);}
cur = a;
while ((cur = cur.parentNode)) {
ap.unshift(cur);}
cur = b;
while ((cur = cur.parentNode)) {
bp.unshift(cur);}
while (ap[i] === bp[i]) {
i++;}
return i ?
siblingCheck(ap[i], bp[i]) :
ap[i] === preferredDoc ? -1 :
bp[i] === preferredDoc ? 1 :
0;};
return doc;};
Sizzle.matches = function (expr, elements) {
return Sizzle(expr, null, null, elements);};
Sizzle.matchesSelector = function (elem, expr) {
if ((elem.ownerDocument || elem) !== document) {
setDocument(elem);}
expr = expr.replace(rattributeQuotes, "='$1']");
if (support.matchesSelector && documentIsHTML &&
(!rbuggyMatches || !rbuggyMatches.test(expr)) &&
(!rbuggyQSA || !rbuggyQSA.test(expr))) {
try {
var ret = matches.call(elem, expr);
if (ret || support.disconnectedMatch ||
elem.document && elem.document.nodeType !== 11) {
return ret;}
} catch (e) {}}
return Sizzle(expr, document, null, [elem]).length > 0;};
Sizzle.contains = function (context, elem) {
if ((context.ownerDocument || context) !== document) {
setDocument(context);}
return contains(context, elem);};
Sizzle.attr = function (elem, name) {
if ((elem.ownerDocument || elem) !== document) {
setDocument(elem);}
var fn = Expr.attrHandle[name.toLowerCase()],
val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
fn(elem, name, !documentIsHTML) :
undefined;
return val !== undefined ?
val :
support.attributes || !documentIsHTML ?
elem.getAttribute(name) :
(val = elem.getAttributeNode(name)) && val.specified ?
val.value :
null;};
Sizzle.error = function (msg) {
throw new Error("Syntax error, unrecognized expression: " + msg);};
Sizzle.uniqueSort = function (results) {
var elem,
duplicates = [],
j = 0,
i = 0;
hasDuplicate = !support.detectDuplicates;
sortInput = !support.sortStable && results.slice(0);
results.sort(sortOrder);
if (hasDuplicate) {
while ((elem = results[i++])) {
if (elem === results[i]) {
j = duplicates.push(i);}}
while (j--) {
results.splice(duplicates[j], 1);}}
sortInput = null;
return results;};
getText = Sizzle.getText = function (elem) {
var node,
ret = "",
i = 0,
nodeType = elem.nodeType;
if (!nodeType) {
while ((node = elem[i++])) {
ret += getText(node);}
} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
if (typeof elem.textContent === "string") {
return elem.textContent;
} else {
for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
ret += getText(elem);}}
} else if (nodeType === 3 || nodeType === 4) {
return elem.nodeValue;}
return ret;};
Expr = Sizzle.selectors = {
cacheLength: 50,
createPseudo: markFunction,
match: matchExpr,
attrHandle: {},
find: {},
relative: {
">": { dir: "parentNode", first: true },
" ": { dir: "parentNode" },
"+": { dir: "previousSibling", first: true },
"~": { dir: "previousSibling" }},
preFilter: {
"ATTR": function (match) {
match[1] = match[1].replace(runescape, funescape);
match[3] = (match[4] || match[5] || "").replace(runescape, funescape);
if (match[2] === "~=") {
match[3] = " " + match[3] + " ";}
return match.slice(0, 4);},
"CHILD": function (match) {
match[1] = match[1].toLowerCase();
if (match[1].slice(0, 3) === "nth") {
if (!match[3]) {
Sizzle.error(match[0]);}
match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
match[5] = +((match[7] + match[8]) || match[3] === "odd");
} else if (match[3]) {
Sizzle.error(match[0]);}
return match;},
"PSEUDO": function (match) {
var excess,
unquoted = !match[5] && match[2];
if (matchExpr["CHILD"].test(match[0])) {
return null;}
if (match[3] && match[4] !== undefined) {
match[2] = match[4];
} else if (unquoted && rpseudo.test(unquoted) &&
(excess = tokenize(unquoted, true)) &&
(excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
match[0] = match[0].slice(0, excess);
match[2] = unquoted.slice(0, excess);}
return match.slice(0, 3);}},
filter: {
"TAG": function (nodeNameSelector) {
var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
return nodeNameSelector === "*" ?
function () { return true; } :
function (elem) {
return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;};},
"CLASS": function (className) {
var pattern = classCache[className + " "];
return pattern ||
(pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
classCache(className, function (elem) {
return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "");});},
"ATTR": function (name, operator, check) {
return function (elem) {
var result = Sizzle.attr(elem, name);
if (result == null) {
return operator === "!=";}
if (!operator) {
return true;}
result += "";
return operator === "=" ? result === check :
operator === "!=" ? result !== check :
operator === "^=" ? check && result.indexOf(check) === 0 :
operator === "*=" ? check && result.indexOf(check) > -1 :
operator === "$=" ? check && result.slice(-check.length) === check :
operator === "~=" ? (" " + result + " ").indexOf(check) > -1 :
operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
false;};},
"CHILD": function (type, what, argument, first, last) {
var simple = type.slice(0, 3) !== "nth",
forward = type.slice(-4) !== "last",
ofType = what === "of-type";
return first === 1 && last === 0 ?
function (elem) {
return !!elem.parentNode;
} :
function (elem, context, xml) {
var cache, outerCache, node, diff, nodeIndex, start,
dir = simple !== forward ? "nextSibling" : "previousSibling",
parent = elem.parentNode,
name = ofType && elem.nodeName.toLowerCase(),
useCache = !xml && !ofType;
if (parent) {
if (simple) {
while (dir) {
node = elem;
while ((node = node[dir])) {
if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
return false;}}
start = dir = type === "only" && !start && "nextSibling";}
return true;}
start = [forward ? parent.firstChild : parent.lastChild];
if (forward && useCache) {
outerCache = parent[expando] || (parent[expando] = {});
cache = outerCache[type] || [];
nodeIndex = cache[0] === dirruns && cache[1];
diff = cache[0] === dirruns && cache[2];
node = nodeIndex && parent.childNodes[nodeIndex];
while ((node = ++nodeIndex && node && node[dir] ||
(diff = nodeIndex = 0) || start.pop())) {
if (node.nodeType === 1 && ++diff && node === elem) {
outerCache[type] = [dirruns, nodeIndex, diff];
break;}}
} else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
diff = cache[1];
} else {
while ((node = ++nodeIndex && node && node[dir] ||
(diff = nodeIndex = 0) || start.pop())) {
if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
if (useCache) {
(node[expando] || (node[expando] = {}))[type] = [dirruns, diff];}
if (node === elem) {
break;}}}}
diff -= last;
return diff === first || (diff % first === 0 && diff / first >= 0);}};},
"PSEUDO": function (pseudo, argument) {
var args,
fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
Sizzle.error("unsupported pseudo: " + pseudo);
if (fn[expando]) {
return fn(argument);}
if (fn.length > 1) {
args = [pseudo, pseudo, "", argument];
return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
markFunction(function (seed, matches) {
var idx,
matched = fn(seed, argument),
i = matched.length;
while (i--) {
idx = indexOf.call(seed, matched[i]);
seed[idx] = !(matches[idx] = matched[i]);}
}) :
function (elem) {
return fn(elem, 0, args);};}
return fn;}},
pseudos: {
"not": markFunction(function (selector) {
var input = [],
results = [],
matcher = compile(selector.replace(rtrim, "$1"));
return matcher[expando] ?
markFunction(function (seed, matches, context, xml) {
var elem,
unmatched = matcher(seed, null, xml, []),
i = seed.length;
while (i--) {
if ((elem = unmatched[i])) {
seed[i] = !(matches[i] = elem);}}
}) :
function (elem, context, xml) {
input[0] = elem;
matcher(input, null, xml, results);
return !results.pop();};
}),
"has": markFunction(function (selector) {
return function (elem) {
return Sizzle(selector, elem).length > 0;};
}),
"contains": markFunction(function (text) {
return function (elem) {
return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;};
}),
"lang": markFunction(function (lang) {
if (!ridentifier.test(lang || "")) {
Sizzle.error("unsupported lang: " + lang);}
lang = lang.replace(runescape, funescape).toLowerCase();
return function (elem) {
var elemLang;
do {
if ((elemLang = documentIsHTML ?
elem.lang :
elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
elemLang = elemLang.toLowerCase();
return elemLang === lang || elemLang.indexOf(lang + "-") === 0;}
} while ((elem = elem.parentNode) && elem.nodeType === 1);
return false;};
}),
"target": function (elem) {
var hash = window.location && window.location.hash;
return hash && hash.slice(1) === elem.id;},
"root": function (elem) {
return elem === docElem;},
"focus": function (elem) {
return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);},
"enabled": function (elem) {
return elem.disabled === false;},
"disabled": function (elem) {
return elem.disabled === true;},
"checked": function (elem) {
var nodeName = elem.nodeName.toLowerCase();
return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);},
"selected": function (elem) {
if (elem.parentNode) {
elem.parentNode.selectedIndex;}
return elem.selected === true;},
"empty": function (elem) {
for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
if (elem.nodeType < 6) {
return false;}}
return true;},
"parent": function (elem) {
return !Expr.pseudos["empty"](elem);},
"header": function (elem) {
return rheader.test(elem.nodeName);},
"input": function (elem) {
return rinputs.test(elem.nodeName);},
"button": function (elem) {
var name = elem.nodeName.toLowerCase();
return name === "input" && elem.type === "button" || name === "button";},
"text": function (elem) {
var attr;
return elem.nodeName.toLowerCase() === "input" &&
elem.type === "text" &&
((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");},
"first": createPositionalPseudo(function () {
return [0];
}),
"last": createPositionalPseudo(function (matchIndexes, length) {
return [length - 1];
}),
"eq": createPositionalPseudo(function (matchIndexes, length, argument) {
return [argument < 0 ? argument + length : argument];
}),
"even": createPositionalPseudo(function (matchIndexes, length) {
var i = 0;
for (; i < length; i += 2) {
matchIndexes.push(i);}
return matchIndexes;
}),
"odd": createPositionalPseudo(function (matchIndexes, length) {
var i = 1;
for (; i < length; i += 2) {
matchIndexes.push(i);}
return matchIndexes;
}),
"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
var i = argument < 0 ? argument + length : argument;
for (; --i >= 0;) {
matchIndexes.push(i);}
return matchIndexes;
}),
"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
var i = argument < 0 ? argument + length : argument;
for (; ++i < length;) {
matchIndexes.push(i);}
return matchIndexes;
})}};
Expr.pseudos["nth"] = Expr.pseudos["eq"];
for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
Expr.pseudos[i] = createInputPseudo(i);}
for (i in { submit: true, reset: true }) {
Expr.pseudos[i] = createButtonPseudo(i);}
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();
function tokenize(selector, parseOnly) {
var matched, match, tokens, type,
soFar, groups, preFilters,
cached = tokenCache[selector + " "];
if (cached) {
return parseOnly ? 0 : cached.slice(0);}
soFar = selector;
groups = [];
preFilters = Expr.preFilter;
while (soFar) {
if (!matched || (match = rcomma.exec(soFar))) {
if (match) {
soFar = soFar.slice(match[0].length) || soFar;}
groups.push((tokens = []));}
matched = false;
if ((match = rcombinators.exec(soFar))) {
matched = match.shift();
tokens.push({
value: matched,
type: match[0].replace(rtrim, " ")});
soFar = soFar.slice(matched.length);}
for (type in Expr.filter) {
if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
(match = preFilters[type](match)))) {
matched = match.shift();
tokens.push({
value: matched,
type: type,
matches: match});
soFar = soFar.slice(matched.length);}}
if (!matched) {
break;}}
return parseOnly ?
soFar.length :
soFar ?
Sizzle.error(selector) :
tokenCache(selector, groups).slice(0);}
function toSelector(tokens) {
var i = 0,
len = tokens.length,
selector = "";
for (; i < len; i++) {
selector += tokens[i].value;}
return selector;}
function addCombinator(matcher, combinator, base) {
var dir = combinator.dir,
checkNonElements = base && dir === "parentNode",
doneName = done++;
return combinator.first ?
function (elem, context, xml) {
while ((elem = elem[dir])) {
if (elem.nodeType === 1 || checkNonElements) {
return matcher(elem, context, xml);}}
} :
function (elem, context, xml) {
var oldCache, outerCache,
newCache = [dirruns, doneName];
if (xml) {
while ((elem = elem[dir])) {
if (elem.nodeType === 1 || checkNonElements) {
if (matcher(elem, context, xml)) {
return true;}}}
} else {
while ((elem = elem[dir])) {
if (elem.nodeType === 1 || checkNonElements) {
outerCache = elem[expando] || (elem[expando] = {});
if ((oldCache = outerCache[dir]) &&
oldCache[0] === dirruns && oldCache[1] === doneName) {
return (newCache[2] = oldCache[2]);
} else {
outerCache[dir] = newCache;
if ((newCache[2] = matcher(elem, context, xml))) {
return true;}}}}}};}
function elementMatcher(matchers) {
return matchers.length > 1 ?
function (elem, context, xml) {
var i = matchers.length;
while (i--) {
if (!matchers[i](elem, context, xml)) {
return false;}}
return true;
} :
matchers[0];}
function multipleContexts(selector, contexts, results) {
var i = 0,
len = contexts.length;
for (; i < len; i++) {
Sizzle(selector, contexts[i], results);}
return results;}
function condense(unmatched, map, filter, context, xml) {
var elem,
newUnmatched = [],
i = 0,
len = unmatched.length,
mapped = map != null;
for (; i < len; i++) {
if ((elem = unmatched[i])) {
if (!filter || filter(elem, context, xml)) {
newUnmatched.push(elem);
if (mapped) {
map.push(i);}}}}
return newUnmatched;}
function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
if (postFilter && !postFilter[expando]) {
postFilter = setMatcher(postFilter);}
if (postFinder && !postFinder[expando]) {
postFinder = setMatcher(postFinder, postSelector);}
return markFunction(function (seed, results, context, xml) {
var temp, i, elem,
preMap = [],
postMap = [],
preexisting = results.length,
elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
matcherIn = preFilter && (seed || !selector) ?
condense(elems, preMap, preFilter, context, xml) :
elems,
matcherOut = matcher ?
postFinder || (seed ? preFilter : preexisting || postFilter) ?
[] :
results :
matcherIn;
if (matcher) {
matcher(matcherIn, matcherOut, context, xml);}
if (postFilter) {
temp = condense(matcherOut, postMap);
postFilter(temp, [], context, xml);
i = temp.length;
while (i--) {
if ((elem = temp[i])) {
matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);}}}
if (seed) {
if (postFinder || preFilter) {
if (postFinder) {
temp = [];
i = matcherOut.length;
while (i--) {
if ((elem = matcherOut[i])) {
temp.push((matcherIn[i] = elem));}}
postFinder(null, (matcherOut = []), temp, xml);}
i = matcherOut.length;
while (i--) {
if ((elem = matcherOut[i]) &&
(temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
seed[temp] = !(results[temp] = elem);}}}
} else {
matcherOut = condense(
matcherOut === results ?
matcherOut.splice(preexisting, matcherOut.length) :
matcherOut
);
if (postFinder) {
postFinder(null, results, matcherOut, xml);
} else {
push.apply(results, matcherOut);}}});}
function matcherFromTokens(tokens) {
var checkContext, matcher, j,
len = tokens.length,
leadingRelative = Expr.relative[tokens[0].type],
implicitRelative = leadingRelative || Expr.relative[" "],
i = leadingRelative ? 1 : 0,
matchContext = addCombinator(function (elem) {
return elem === checkContext;
}, implicitRelative, true),
matchAnyContext = addCombinator(function (elem) {
return indexOf.call(checkContext, elem) > -1;
}, implicitRelative, true),
matchers = [function (elem, context, xml) {
return (!leadingRelative && (xml || context !== outermostContext)) || (
(checkContext = context).nodeType ?
matchContext(elem, context, xml) :
matchAnyContext(elem, context, xml));
}];
for (; i < len; i++) {
if ((matcher = Expr.relative[tokens[i].type])) {
matchers = [addCombinator(elementMatcher(matchers), matcher)];
} else {
matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
if (matcher[expando]) {
j = ++i;
for (; j < len; j++) {
if (Expr.relative[tokens[j].type]) {
break;}}
return setMatcher(
i > 1 && elementMatcher(matchers),
i > 1 && toSelector(
tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })
).replace(rtrim, "$1"),
matcher,
i < j && matcherFromTokens(tokens.slice(i, j)),
j < len && matcherFromTokens((tokens = tokens.slice(j))),
j < len && toSelector(tokens)
);}
matchers.push(matcher);}}
return elementMatcher(matchers);}
function matcherFromGroupMatchers(elementMatchers, setMatchers) {
var bySet = setMatchers.length > 0,
byElement = elementMatchers.length > 0,
superMatcher = function (seed, context, xml, results, outermost) {
var elem, j, matcher,
matchedCount = 0,
i = "0",
unmatched = seed && [],
setMatched = [],
contextBackup = outermostContext,
elems = seed || byElement && Expr.find["TAG"]("*", outermost),
dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
len = elems.length;
if (outermost) {
outermostContext = context !== document && context;}
for (; i !== len && (elem = elems[i]) != null; i++) {
if (byElement && elem) {
j = 0;
while ((matcher = elementMatchers[j++])) {
if (matcher(elem, context, xml)) {
results.push(elem);
break;}}
if (outermost) {
dirruns = dirrunsUnique;}}
if (bySet) {
if ((elem = !matcher && elem)) {
matchedCount--;}
if (seed) {
unmatched.push(elem);}}}
matchedCount += i;
if (bySet && i !== matchedCount) {
j = 0;
while ((matcher = setMatchers[j++])) {
matcher(unmatched, setMatched, context, xml);}
if (seed) {
if (matchedCount > 0) {
while (i--) {
if (!(unmatched[i] || setMatched[i])) {
setMatched[i] = pop.call(results);}}}
setMatched = condense(setMatched);}
push.apply(results, setMatched);
if (outermost && !seed && setMatched.length > 0 &&
(matchedCount + setMatchers.length) > 1) {
Sizzle.uniqueSort(results);}}
if (outermost) {
dirruns = dirrunsUnique;
outermostContext = contextBackup;}
return unmatched;};
return bySet ?
markFunction(superMatcher) :
superMatcher;}
compile = Sizzle.compile = function (selector, match /* Internal Use Only */ ) {
var i,
setMatchers = [],
elementMatchers = [],
cached = compilerCache[selector + " "];
if (!cached) {
if (!match) {
match = tokenize(selector);}
i = match.length;
while (i--) {
cached = matcherFromTokens(match[i]);
if (cached[expando]) {
setMatchers.push(cached);
} else {
elementMatchers.push(cached);}}
cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
cached.selector = selector;}
return cached;};
select = Sizzle.select = function (selector, context, results, seed) {
var i, tokens, token, type, find,
compiled = typeof selector === "function" && selector,
match = !seed && tokenize((selector = compiled.selector || selector));
results = results || [];
if (match.length === 1) {
tokens = match[0] = match[0].slice(0);
if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
support.getById && context.nodeType === 9 && documentIsHTML &&
Expr.relative[tokens[1].type]) {
context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
if (!context) {
return results;
} else if (compiled) {
context = context.parentNode;}
selector = selector.slice(tokens.shift().value.length);}
i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
while (i--) {
token = tokens[i];
if (Expr.relative[(type = token.type)]) {
break;}
if ((find = Expr.find[type])) {
if ((seed = find(
token.matches[0].replace(runescape, funescape),
rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
))) {
tokens.splice(i, 1);
selector = seed.length && toSelector(tokens);
if (!selector) {
push.apply(results, seed);
return results;}
break;}}}}
(compiled || compile(selector, match))(
seed,
context, !documentIsHTML,
results,
rsibling.test(selector) && testContext(context.parentNode) || context
);
return results;};
support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
support.detectDuplicates = !!hasDuplicate;
setDocument();
support.sortDetached = assert(function (div1) {
return div1.compareDocumentPosition(document.createElement("div")) & 1;});
if (!assert(function (div) {
div.innerHTML = "<a href='#'></a>";
return div.firstChild.getAttribute("href") === "#";
})) {
addHandle("type|href|height|width", function (elem, name, isXML) {
if (!isXML) {
return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);}});}
if (!support.attributes || !assert(function (div) {
div.innerHTML = "<input/>";
div.firstChild.setAttribute("value", "");
return div.firstChild.getAttribute("value") === "";
})) {
addHandle("value", function (elem, name, isXML) {
if (!isXML && elem.nodeName.toLowerCase() === "input") {
return elem.defaultValue;}});}
if (!assert(function (div) {
return div.getAttribute("disabled") == null;
})) {
addHandle(booleans, function (elem, name, isXML) {
var val;
if (!isXML) {
return elem[name] === true ? name.toLowerCase() :
(val = elem.getAttributeNode(name)) && val.specified ?
val.value :
null;}});}
if (typeof define === "function" && define.amd) {
define(function () { return Sizzle; });
} else if (typeof module !== "undefined" && module.exports) {
module.exports = Sizzle;
} else {
window.Sizzle = Sizzle;}
})(window);
;
(function () {
if (typeof Sizzle !== 'undefined') {
return;}
if (typeof define !== 'undefined' && define.amd) {
window.Sizzle = Prototype._actual_sizzle;
window.define = Prototype._original_define;
delete Prototype._actual_sizzle;
delete Prototype._original_define;
} else if (typeof module !== 'undefined' && module.exports) {
window.Sizzle = module.exports;
module.exports = {};}
})();
;
(function (engine) {
var extendElements = Prototype.Selector.extendElements;
function select(selector, scope) {
return extendElements(engine(selector, scope || document));}
function match(element, selector) {
return engine.matches(selector, [element]).length == 1;}
Prototype.Selector.engine = engine;
Prototype.Selector.select = select;
Prototype.Selector.match = match;
})(Sizzle);
window.Sizzle = Prototype._original_property;
delete Prototype._original_property;
var Form = {
reset: function (form) {
form = prototype$(form);
form.reset();
return form;},
serializeElements: function (elements, options) {
if (typeof options != 'object') options = { hash: !!options };
else if (Object.isUndefined(options.hash)) options.hash = true;
var key, value, submitted = false,
submit = options.submit,
accumulator, initial;
if (options.hash) {
initial = {};
accumulator = function (result, key, value) {
if (key in result) {
if (!Object.isArray(result[key])) result[key] = [result[key]];
result[key] = result[key].concat(value);
} else result[key] = value;
return result;};
} else {
initial = '';
accumulator = function (result, key, values) {
if (!Object.isArray(values)) { values = [values]; }
if (!values.length) { return result; }
var encodedKey = encodeURIComponent(key).gsub(/%20/, '+');
return result + (result ? "&" : "") + values.map(function (value) {
value = value.gsub(/(\r)?\n/, '\r\n');
value = encodeURIComponent(value);
value = value.gsub(/%20/, '+');
return encodedKey + "=" + value;
}).join("&");};}
return elements.inject(initial, function (result, element) {
if (!element.disabled && element.name) {
key = element.name;
value = prototype$(element).getValue();
if (value != null && element.type != 'file' && (element.type != 'submit' || (!submitted &&
submit !== false && (!submit || key == submit) && (submitted = true)))) {
result = accumulator(result, key, value);}}
return result;});}};
Form.Methods = {
serialize: function (form, options) {
return Form.serializeElements(Form.getElements(form), options);},
getElements: function (form) {
var elements = prototype$(form).getElementsByTagName('*');
var element, results = [],
serializers = Form.Element.Serializers;
for (var i = 0; element = elements[i]; i++) {
if (serializers[element.tagName.toLowerCase()])
results.push(Element.extend(element));}
return results;},
getInputs: function (form, typeName, name) {
form = prototype$(form);
var inputs = form.getElementsByTagName('input');
if (!typeName && !name) return $A(inputs).map(Element.extend);
for (var i = 0, matchingInputs = [], length = inputs.length; i < length; i++) {
var input = inputs[i];
if ((typeName && input.type != typeName) || (name && input.name != name))
continue;
matchingInputs.push(Element.extend(input));}
return matchingInputs;},
disable: function (form) {
form = prototype$(form);
Form.getElements(form).invoke('disable');
return form;},
enable: function (form) {
form = prototype$(form);
Form.getElements(form).invoke('enable');
return form;},
findFirstElement: function (form) {
var elements = prototype$(form).getElements().findAll(function (element) {
return 'hidden' != element.type && !element.disabled;});
var firstByIndex = elements.findAll(function (element) {
return element.hasAttribute('tabIndex') && element.tabIndex >= 0;
}).sortBy(function (element) { return element.tabIndex }).first();
return firstByIndex ? firstByIndex : elements.find(function (element) {
return /^(?:input|select|textarea)$/i.test(element.tagName);});},
focusFirstElement: function (form) {
form = prototype$(form);
var element = form.findFirstElement();
if (element) element.activate();
return form;},
request: function (form, options) {
form = prototype$(form), options = Object.clone(options || {});
var params = options.parameters,
action = form.readAttribute('action') || '';
if (action.blank()) action = window.location.href;
options.parameters = form.serialize(true);
if (params) {
if (Object.isString(params)) params = params.toQueryParams();
Object.extend(options.parameters, params);}
if (form.hasAttribute('method') && !options.method)
options.method = form.method;
return new Ajax.Request(action, options);}};
Form.Element = {
focus: function (element) {
prototype$(element).focus();
return element;},
select: function (element) {
prototype$(element).select();
return element;}};
Form.Element.Methods = {
serialize: function (element) {
element = prototype$(element);
if (!element.disabled && element.name) {
var value = element.getValue();
if (value != undefined) {
var pair = {};
pair[element.name] = value;
return Object.toQueryString(pair);}}
return '';},
getValue: function (element) {
element = prototype$(element);
var method = element.tagName.toLowerCase();
return Form.Element.Serializers[method](element);},
setValue: function (element, value) {
element = prototype$(element);
var method = element.tagName.toLowerCase();
Form.Element.Serializers[method](element, value);
return element;},
clear: function (element) {
prototype$(element).value = '';
return element;},
present: function (element) {
return prototype$(element).value != '';},
activate: function (element) {
element = prototype$(element);
try {
element.focus();
if (element.select && (element.tagName.toLowerCase() != 'input' ||
!(/^(?:button|reset|submit)$/i.test(element.type))))
element.select();
} catch (e) {}
return element;},
disable: function (element) {
element = prototype$(element);
element.disabled = true;
return element;},
enable: function (element) {
element = prototype$(element);
element.disabled = false;
return element;}};
var Field = Form.Element;
var $F = Form.Element.Methods.getValue;
Form.Element.Serializers = (function () {
function input(element, value) {
switch (element.type.toLowerCase()) {
case 'checkbox':
case 'radio':
return inputSelector(element, value);
default:
return valueSelector(element, value);}}
function inputSelector(element, value) {
if (Object.isUndefined(value))
return element.checked ? element.value : null;
else element.checked = !!value;}
function valueSelector(element, value) {
if (Object.isUndefined(value)) return element.value;
else element.value = value;}
function select(element, value) {
if (Object.isUndefined(value))
return (element.type === 'select-one' ? selectOne : selectMany)(element);
var opt, currentValue, single = !Object.isArray(value);
for (var i = 0, length = element.length; i < length; i++) {
opt = element.options[i];
currentValue = this.optionValue(opt);
if (single) {
if (currentValue == value) {
opt.selected = true;
return;}
} else opt.selected = value.include(currentValue);}}
function selectOne(element) {
var index = element.selectedIndex;
return index >= 0 ? optionValue(element.options[index]) : null;}
function selectMany(element) {
var values, length = element.length;
if (!length) return null;
for (var i = 0, values = []; i < length; i++) {
var opt = element.options[i];
if (opt.selected) values.push(optionValue(opt));}
return values;}
function optionValue(opt) {
return Element.hasAttribute(opt, 'value') ? opt.value : opt.text;}
return {
input: input,
inputSelector: inputSelector,
textarea: valueSelector,
select: select,
selectOne: selectOne,
selectMany: selectMany,
optionValue: optionValue,
button: valueSelector};
})();
Abstract.TimedObserver = Class.create(PeriodicalExecuter, {
initialize: function ($super, element, frequency, callback) {
$super(callback, frequency);
this.element = prototype$(element);
this.lastValue = this.getValue();},
execute: function () {
var value = this.getValue();
if (Object.isString(this.lastValue) && Object.isString(value) ?
this.lastValue != value : String(this.lastValue) != String(value)) {
this.callback(this.element, value);
this.lastValue = value;}}});
Form.Element.Observer = Class.create(Abstract.TimedObserver, {
getValue: function () {
return Form.Element.getValue(this.element);}});
Form.Observer = Class.create(Abstract.TimedObserver, {
getValue: function () {
return Form.serialize(this.element);}});
Abstract.EventObserver = Class.create({
initialize: function (element, callback) {
this.element = prototype$(element);
this.callback = callback;
this.lastValue = this.getValue();
if (this.element.tagName.toLowerCase() == 'form')
this.registerFormCallbacks();
else
this.registerCallback(this.element);},
onElementEvent: function () {
var value = this.getValue();
if (this.lastValue != value) {
this.callback(this.element, value);
this.lastValue = value;}},
registerFormCallbacks: function () {
Form.getElements(this.element).each(this.registerCallback, this);},
registerCallback: function (element) {
if (element.type) {
switch (element.type.toLowerCase()) {
case 'checkbox':
case 'radio':
Event.observe(element, 'click', this.onElementEvent.bind(this));
break;
default:
Event.observe(element, 'change', this.onElementEvent.bind(this));
break;}}}});
Form.Element.EventObserver = Class.create(Abstract.EventObserver, {
getValue: function () {
return Form.Element.getValue(this.element);}});
Form.EventObserver = Class.create(Abstract.EventObserver, {
getValue: function () {
return Form.serialize(this.element);}});
(function (GLOBAL) {
var DIV = document.createElement('div');
var docEl = document.documentElement;
var MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED = 'onmouseenter' in docEl &&
'onmouseleave' in docEl;
var Event = {
KEY_BACKSPACE: 8,
KEY_TAB: 9,
KEY_RETURN: 13,
KEY_ESC: 27,
KEY_LEFT: 37,
KEY_UP: 38,
KEY_RIGHT: 39,
KEY_DOWN: 40,
KEY_DELETE: 46,
KEY_HOME: 36,
KEY_END: 35,
KEY_PAGEUP: 33,
KEY_PAGEDOWN: 34,
KEY_INSERT: 45};
var isIELegacyEvent = function (event) { return false; };
if (window.attachEvent) {
if (window.addEventListener) {
isIELegacyEvent = function (event) {
return !(event instanceof window.Event);};
} else {
isIELegacyEvent = function (event) { return true; };}}
var _isButton;
function _isButtonForDOMEvents(event, code) {
return event.which ? (event.which === code + 1) : (event.button === code);}
var legacyButtonMap = { 0: 1, 1: 4, 2: 2 };
function _isButtonForLegacyEvents(event, code) {
return event.button === legacyButtonMap[code];}
function _isButtonForWebKit(event, code) {
switch (code) {
case 0:
return event.which == 1 && !event.metaKey;
case 1:
return event.which == 2 || (event.which == 1 && event.metaKey);
case 2:
return event.which == 3;
default:
return false;}}
if (window.attachEvent) {
if (!window.addEventListener) {
_isButton = _isButtonForLegacyEvents;
} else {
_isButton = function (event, code) {
return isIELegacyEvent(event) ? _isButtonForLegacyEvents(event, code) :
_isButtonForDOMEvents(event, code);}}
} else if (Prototype.Browser.WebKit) {
_isButton = _isButtonForWebKit;
} else {
_isButton = _isButtonForDOMEvents;}
function isLeftClick(event) { return _isButton(event, 0) }
function isMiddleClick(event) { return _isButton(event, 1) }
function isRightClick(event) { return _isButton(event, 2) }
function element(event) {
return Element.extend(_element(event));}
function _element(event) {
event = Event.extend(event);
var node = event.target,
type = event.type,
currentTarget = event.currentTarget;
if (currentTarget && currentTarget.tagName) {
if (type === 'load' || type === 'error' ||
(type === 'click' && currentTarget.tagName.toLowerCase() === 'input' &&
currentTarget.type === 'radio'))
node = currentTarget;}
return node.nodeType == Node.TEXT_NODE ? node.parentNode : node;}
function findElement(event, expression) {
var element = _element(event),
selector = Prototype.Selector;
if (!expression) return Element.extend(element);
while (element) {
if (Object.isElement(element) && selector.match(element, expression))
return Element.extend(element);
element = element.parentNode;}}
function pointer(event) {
return { x: pointerX(event), y: pointerY(event) };}
function pointerX(event) {
var docElement = document.documentElement,
body = document.body || { scrollLeft: 0 };
return event.pageX || (event.clientX +
(docElement.scrollLeft || body.scrollLeft) -
(docElement.clientLeft || 0));}
function pointerY(event) {
var docElement = document.documentElement,
body = document.body || { scrollTop: 0 };
return event.pageY || (event.clientY +
(docElement.scrollTop || body.scrollTop) -
(docElement.clientTop || 0));}
function stop(event) {
Event.extend(event);
event.preventDefault();
event.stopPropagation();
event.stopped = true;}
Event.Methods = {
isLeftClick: isLeftClick,
isMiddleClick: isMiddleClick,
isRightClick: isRightClick,
element: element,
findElement: findElement,
pointer: pointer,
pointerX: pointerX,
pointerY: pointerY,
stop: stop};
var methods = Object.keys(Event.Methods).inject({}, function (m, name) {
m[name] = Event.Methods[name].methodize();
return m;});
if (window.attachEvent) {
function _relatedTarget(event) {
var element;
switch (event.type) {
case 'mouseover':
case 'mouseenter':
element = event.fromElement;
break;
case 'mouseout':
case 'mouseleave':
element = event.toElement;
break;
default:
return null;}
return Element.extend(element);}
var additionalMethods = {
stopPropagation: function () { this.cancelBubble = true },
preventDefault: function () { this.returnValue = false },
inspect: function () { return '[object Event]' }};
Event.extend = function (event, element) {
if (!event) return false;
if (!isIELegacyEvent(event)) return event;
if (event._extendedByPrototype) return event;
event._extendedByPrototype = Prototype.emptyFunction;
var pointer = Event.pointer(event);
Object.extend(event, {
target: event.srcElement || element,
relatedTarget: _relatedTarget(event),
pageX: pointer.x,
pageY: pointer.y});
Object.extend(event, methods);
Object.extend(event, additionalMethods);
return event;};
} else {
Event.extend = Prototype.K;}
if (window.addEventListener) {
Event.prototype = window.Event.prototype || document.createEvent('HTMLEvents').__proto__;
Object.extend(Event.prototype, methods);}
var EVENT_TRANSLATIONS = {
mouseenter: 'mouseover',
mouseleave: 'mouseout'};
function getDOMEventName(eventName) {
return EVENT_TRANSLATIONS[eventName] || eventName;}
if (MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED)
getDOMEventName = Prototype.K;
function getUniqueElementID(element) {
if (element === window) return 0;
if (typeof element._prototypeUID === 'undefined')
element._prototypeUID = Element.Storage.UID++;
return element._prototypeUID;}
function getUniqueElementID_IE(element) {
if (element === window) return 0;
if (element == document) return 1;
return element.uniqueID;}
if ('uniqueID' in DIV)
getUniqueElementID = getUniqueElementID_IE;
function isCustomEvent(eventName) {
return eventName.include(':');}
Event._isCustomEvent = isCustomEvent;
function getOrCreateRegistryFor(element, uid) {
var CACHE = GLOBAL.Event.cache;
if (Object.isUndefined(uid))
uid = getUniqueElementID(element);
if (!CACHE[uid]) CACHE[uid] = { element: element };
return CACHE[uid];}
function destroyRegistryForElement(element, uid) {
if (Object.isUndefined(uid))
uid = getUniqueElementID(element);
delete GLOBAL.Event.cache[uid];}
function register(element, eventName, handler) {
var registry = getOrCreateRegistryFor(element);
if (!registry[eventName]) registry[eventName] = [];
var entries = registry[eventName];
var i = entries.length;
while (i--)
if (entries[i].handler === handler) return null;
var uid = getUniqueElementID(element);
var responder = GLOBAL.Event._createResponder(uid, eventName, handler);
var entry = {
responder: responder,
handler: handler};
entries.push(entry);
return entry;}
function unregister(element, eventName, handler) {
var registry = getOrCreateRegistryFor(element);
var entries = registry[eventName] || [];
var i = entries.length,
entry;
while (i--) {
if (entries[i].handler === handler) {
entry = entries[i];
break;}}
if (entry) {
var index = entries.indexOf(entry);
entries.splice(index, 1);}
if (entries.length === 0) {
delete registry[eventName];
if (Object.keys(registry).length === 1 && ('element' in registry))
destroyRegistryForElement(element);}
return entry;}
function observe(element, eventName, handler) {
element = prototype$(element);
var entry = register(element, eventName, handler);
if (entry === null) return element;
var responder = entry.responder;
if (isCustomEvent(eventName))
observeCustomEvent(element, eventName, responder);
else
observeStandardEvent(element, eventName, responder);
return element;}
function observeStandardEvent(element, eventName, responder) {
var actualEventName = getDOMEventName(eventName);
if (element.addEventListener) {
element.addEventListener(actualEventName, responder, false);
} else {
element.attachEvent('on' + actualEventName, responder);}}
function observeCustomEvent(element, eventName, responder) {
if (element.addEventListener) {
element.addEventListener('dataavailable', responder, false);
} else {
element.attachEvent('ondataavailable', responder);
element.attachEvent('onlosecapture', responder);}}
function stopObserving(element, eventName, handler) {
element = prototype$(element);
var handlerGiven = !Object.isUndefined(handler),
eventNameGiven = !Object.isUndefined(eventName);
if (!eventNameGiven && !handlerGiven) {
stopObservingElement(element);
return element;}
if (!handlerGiven) {
stopObservingEventName(element, eventName);
return element;}
var entry = unregister(element, eventName, handler);
if (!entry) return element;
removeEvent(element, eventName, entry.responder);
return element;}
function stopObservingStandardEvent(element, eventName, responder) {
var actualEventName = getDOMEventName(eventName);
if (element.removeEventListener) {
element.removeEventListener(actualEventName, responder, false);
} else {
element.detachEvent('on' + actualEventName, responder);}}
function stopObservingCustomEvent(element, eventName, responder) {
if (element.removeEventListener) {
element.removeEventListener('dataavailable', responder, false);
} else {
element.detachEvent('ondataavailable', responder);
element.detachEvent('onlosecapture', responder);}}
function stopObservingElement(element) {
var uid = getUniqueElementID(element),
registry = GLOBAL.Event.cache[uid];
if (!registry) return;
destroyRegistryForElement(element, uid);
var entries, i;
for (var eventName in registry) {
if (eventName === 'element') continue;
entries = registry[eventName];
i = entries.length;
while (i--)
removeEvent(element, eventName, entries[i].responder);}}
function stopObservingEventName(element, eventName) {
var registry = getOrCreateRegistryFor(element);
var entries = registry[eventName];
if (entries) {
delete registry[eventName];}
entries = entries || [];
var i = entries.length;
while (i--)
removeEvent(element, eventName, entries[i].responder);
for (var name in registry) {
if (name === 'element') continue;
return; // There is another registered event
}
destroyRegistryForElement(element);}
function removeEvent(element, eventName, handler) {
if (isCustomEvent(eventName))
stopObservingCustomEvent(element, eventName, handler);
else
stopObservingStandardEvent(element, eventName, handler);}
function getFireTarget(element) {
if (element !== document) return element;
if (document.createEvent && !element.dispatchEvent)
return document.documentElement;
return element;}
function fire(element, eventName, memo, bubble) {
element = getFireTarget(prototype$(element));
if (Object.isUndefined(bubble)) bubble = true;
memo = memo || {};
var event = fireEvent(element, eventName, memo, bubble);
return Event.extend(event);}
function fireEvent_DOM(element, eventName, memo, bubble) {
var event = document.createEvent('HTMLEvents');
event.initEvent('dataavailable', bubble, true);
event.eventName = eventName;
event.memo = memo;
element.dispatchEvent(event);
return event;}
function fireEvent_IE(element, eventName, memo, bubble) {
var event = document.createEventObject();
event.eventType = bubble ? 'ondataavailable' : 'onlosecapture';
event.eventName = eventName;
event.memo = memo;
element.fireEvent(event.eventType, event);
return event;}
var fireEvent = document.createEvent ? fireEvent_DOM : fireEvent_IE;
Event.Handler = Class.create({
initialize: function (element, eventName, selector, callback) {
this.element = prototype$(element);
this.eventName = eventName;
this.selector = selector;
this.callback = callback;
this.handler = this.handleEvent.bind(this);},
start: function () {
Event.observe(this.element, this.eventName, this.handler);
return this;},
stop: function () {
Event.stopObserving(this.element, this.eventName, this.handler);
return this;},
handleEvent: function (event) {
var element = Event.findElement(event, this.selector);
if (element) this.callback.call(this.element, event, element);}});
function on(element, eventName, selector, callback) {
element = prototype$(element);
if (Object.isFunction(selector) && Object.isUndefined(callback)) {
callback = selector, selector = null;}
return new Event.Handler(element, eventName, selector, callback).start();}
Object.extend(Event, Event.Methods);
Object.extend(Event, {
fire: fire,
observe: observe,
stopObserving: stopObserving,
on: on});
Element.addMethods({
fire: fire,
observe: observe,
stopObserving: stopObserving,
on: on});
Object.extend(document, {
fire: fire.methodize(),
observe: observe.methodize(),
stopObserving: stopObserving.methodize(),
on: on.methodize(),
loaded: false});
if (GLOBAL.Event) Object.extend(window.Event, Event);
else GLOBAL.Event = Event;
GLOBAL.Event.cache = {};
function destroyCache_IE() {
GLOBAL.Event.cache = null;}
if (window.attachEvent)
window.attachEvent('onunload', destroyCache_IE);
DIV = null;
docEl = null;
})(this);
(function (GLOBAL) {
var docEl = document.documentElement;
var MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED = 'onmouseenter' in docEl &&
'onmouseleave' in docEl;
function isSimulatedMouseEnterLeaveEvent(eventName) {
return !MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED &&
(eventName === 'mouseenter' || eventName === 'mouseleave');}
function createResponder(uid, eventName, handler) {
if (Event._isCustomEvent(eventName))
return createResponderForCustomEvent(uid, eventName, handler);
if (isSimulatedMouseEnterLeaveEvent(eventName))
return createMouseEnterLeaveResponder(uid, eventName, handler);
return function (event) {
if (!Event.cache || !Event.cache[uid]) return;
var element = Event.cache[uid].element;
Event.extend(event, element);
handler.call(element, event);};}
function createResponderForCustomEvent(uid, eventName, handler) {
return function (event) {
var cache = Event.cache[uid];
var element = cache && cache.element;
if (Object.isUndefined(event.eventName))
return false;
if (event.eventName !== eventName)
return false;
Event.extend(event, element);
handler.call(element, event);};}
function createMouseEnterLeaveResponder(uid, eventName, handler) {
return function (event) {
var element = Event.cache[uid].element;
Event.extend(event, element);
var parent = event.relatedTarget;
while (parent && parent !== element) {
try { parent = parent.parentNode; } catch (e) { parent = element; }}
if (parent === element) return;
handler.call(element, event);}}
GLOBAL.Event._createResponder = createResponder;
docEl = null;
})(this);
(function (GLOBAL) {
var TIMER;
function fireContentLoadedEvent() {
if (document.loaded) return;
if (TIMER) window.clearTimeout(TIMER);
document.loaded = true;
document.fire('dom:loaded');}
function checkReadyState() {
if (document.readyState === 'complete') {
document.detachEvent('onreadystatechange', checkReadyState);
fireContentLoadedEvent();}}
function pollDoScroll() {
try {
document.documentElement.doScroll('left');
} catch (e) {
TIMER = pollDoScroll.defer();
return;}
fireContentLoadedEvent();}
if (document.readyState === 'complete') {
fireContentLoadedEvent();
return;}
if (document.addEventListener) {
document.addEventListener('DOMContentLoaded', fireContentLoadedEvent, false);
} else {
document.attachEvent('onreadystatechange', checkReadyState);
if (window == top) TIMER = pollDoScroll.defer();}
Event.observe(window, 'load', fireContentLoadedEvent);
})(this);
Element.addMethods();
Hash.toQueryString = Object.toQueryString;
var Toggle = { display: Element.toggle };
Element.addMethods({
childOf: Element.Methods.descendantOf});
var Insertion = {
Before: function (element, content) {
return Element.insert(element, { before: content });},
Top: function (element, content) {
return Element.insert(element, { top: content });},
Bottom: function (element, content) {
return Element.insert(element, { bottom: content });},
After: function (element, content) {
return Element.insert(element, { after: content });}};
var $continue = new Error('"throw $continue" is deprecated, use "return" instead');
var Position = {
includeScrollOffsets: false,
prepare: function () {
this.deltaX = window.pageXOffset ||
document.documentElement.scrollLeft ||
document.body.scrollLeft ||
0;
this.deltaY = window.pageYOffset ||
document.documentElement.scrollTop ||
document.body.scrollTop ||
0;},
within: function (element, x, y) {
if (this.includeScrollOffsets)
return this.withinIncludingScrolloffsets(element, x, y);
this.xcomp = x;
this.ycomp = y;
this.offset = Element.cumulativeOffset(element);
return (y >= this.offset[1] &&
y < this.offset[1] + element.offsetHeight &&
x >= this.offset[0] &&
x < this.offset[0] + element.offsetWidth);},
withinIncludingScrolloffsets: function (element, x, y) {
var offsetcache = Element.cumulativeScrollOffset(element);
this.xcomp = x + offsetcache[0] - this.deltaX;
this.ycomp = y + offsetcache[1] - this.deltaY;
this.offset = Element.cumulativeOffset(element);
return (this.ycomp >= this.offset[1] &&
this.ycomp < this.offset[1] + element.offsetHeight &&
this.xcomp >= this.offset[0] &&
this.xcomp < this.offset[0] + element.offsetWidth);},
overlap: function (mode, element) {
if (!mode) return 0;
if (mode == 'vertical')
return ((this.offset[1] + element.offsetHeight) - this.ycomp) /
element.offsetHeight;
if (mode == 'horizontal')
return ((this.offset[0] + element.offsetWidth) - this.xcomp) /
element.offsetWidth;},
cumulativeOffset: Element.Methods.cumulativeOffset,
positionedOffset: Element.Methods.positionedOffset,
absolutize: function (element) {
Position.prepare();
return Element.absolutize(element);},
relativize: function (element) {
Position.prepare();
return Element.relativize(element);},
realOffset: Element.Methods.cumulativeScrollOffset,
offsetParent: Element.Methods.getOffsetParent,
page: Element.Methods.viewportOffset,
clone: function (source, target, options) {
options = options || {};
return Element.clonePosition(target, source, options);}};
if (!document.getElementsByClassName) document.getElementsByClassName = function (instanceMethods) {
function iter(name) {
return name.blank() ? null : "[contains(concat(' ', @class, ' '), ' " + name + " ')]";}
instanceMethods.getElementsByClassName = Prototype.BrowserFeatures.XPath ?
function (element, className) {
className = className.toString().strip();
var cond = /\s/.test(className) ? $w(className).map(iter).join('') : iter(className);
return cond ? document._getElementsByXPath('.//*' + cond, element) : [];
} : function (element, className) {
className = className.toString().strip();
var elements = [],
classNames = (/\s/.test(className) ? $w(className) : null);
if (!classNames && !className) return elements;
var nodes = prototype$(element).getElementsByTagName('*');
className = ' ' + className + ' ';
for (var i = 0, child, cn; child = nodes[i]; i++) {
if (child.className && (cn = ' ' + child.className + ' ') && (cn.include(className) ||
(classNames && classNames.all(function (name) {
return !name.toString().blank() && cn.include(' ' + name + ' ');
}))))
elements.push(Element.extend(child));}
return elements;};
return function (className, parentElement) {
return prototype$(parentElement || document.body).getElementsByClassName(className);};
}(Element.Methods);
Element.ClassNames = Class.create();
Element.ClassNames.prototype = {
initialize: function (element) {
this.element = prototype$(element);},
_each: function (iterator, context) {
this.element.className.split(/\s+/).select(function (name) {
return name.length > 0;
})._each(iterator, context);},
set: function (className) {
this.element.className = className;},
add: function (classNameToAdd) {
if (this.include(classNameToAdd)) return;
this.set($A(this).concat(classNameToAdd).join(' '));},
remove: function (classNameToRemove) {
if (!this.include(classNameToRemove)) return;
this.set($A(this).without(classNameToRemove).join(' '));},
toString: function () {
return $A(this).join(' ');}};
Object.extend(Element.ClassNames.prototype, Enumerable);
(function () {
window.Selector = Class.create({
initialize: function (expression) {
this.expression = expression.strip();},
findElements: function (rootElement) {
return Prototype.Selector.select(this.expression, rootElement);},
match: function (element) {
return Prototype.Selector.match(element, this.expression);},
toString: function () {
return this.expression;},
inspect: function () {
return "#<Selector: " + this.expression + ">";}});
Object.extend(Selector, {
matchElements: function (elements, expression) {
var match = Prototype.Selector.match,
results = [];
for (var i = 0, length = elements.length; i < length; i++) {
var element = elements[i];
if (match(element, expression)) {
results.push(Element.extend(element));}}
return results;},
findElement: function (elements, expression, index) {
index = index || 0;
var matchIndex = 0,
element;
for (var i = 0, length = elements.length; i < length; i++) {
element = elements[i];
if (Prototype.Selector.match(element, expression) && index === matchIndex++) {
return Element.extend(element);}}},
findChildElements: function (element, expressions) {
var selector = expressions.toArray().join(', ');
return Prototype.Selector.select(selector, element || document);}});
})();
Hash.addMethods({
extend: function(values) {
Object.extend(this._object, values);}});
Hash.addMethods({
clean: function() {
this.each(function(pair){
if (pair.value === undefined || pair.value === null){
this.unset(pair.key);}
}.bind(this));}});
Array.prototype.extend = function(ary) {
ary.each(function(o,i){
this.push(o);
}.bind(this));};
Object.extend(Object, {
deepExtend: function(destination, source) {
com.liquidpixels.utilities.DeepMerge.extend(destination, source, {overrideArrays: true});},
deepClone: function(source, options) {
return com.liquidpixels.utilities.DeepMerge.clone(source, {overrideArrays: true});}});
Date.now = Date.now || function(){return +new Date;};
(function(make) {
Element.addMethods(make());
}(function() {
var xports = {}
, win = typeof window != 'undefined' && window
, doc = typeof document != 'undefined' && document
, docElem = doc && doc.documentElement
, matchMedia = win['matchMedia'] || win['msMatchMedia']
, mq = matchMedia ? function(q) {
return !!matchMedia.call(win, q).matches;
} : function() {
return false;}
, viewportW = xports['viewportW'] = function() {
var a = docElem['clientWidth'], b = win['innerWidth'];
return a < b ? b : a;}
, viewportH = xports['viewportH'] = function() {
var a = docElem['clientHeight'], b = win['innerHeight'];
return a < b ? b : a;};
xports['mq'] = mq;
xports['matchMedia'] = matchMedia ? function() {
return matchMedia.apply(win, arguments);
} : function() {
return {};};
function viewport() {
return {'width':viewportW(), 'height':viewportH()};}
xports['viewport'] = viewport;
xports['scrollX'] = function() {
return win.pageXOffset || docElem.scrollLeft;};
xports['scrollY'] = function() {
return win.pageYOffset || docElem.scrollTop;};
function calibrate(coords, cushion) {
var o = {};
cushion = +cushion || 0;
o['width'] = (o['right'] = coords['right'] + cushion) - (o['left'] = coords['left'] - cushion);
o['height'] = (o['bottom'] = coords['bottom'] + cushion) - (o['top'] = coords['top'] - cushion);
return o;}
function rectangle(el, cushion) {
el = el && !el.nodeType ? el[0] : el;
if (!el || 1 !== el.nodeType) return false;
return calibrate(el.getBoundingClientRect(), cushion);}
xports['rectangle'] = rectangle;
function aspect(o) {
o = null == o ? viewport() : 1 === o.nodeType ? rectangle(o) : o;
var h = o['height'], w = o['width'];
h = typeof h == 'function' ? h.call(o) : h;
w = typeof w == 'function' ? w.call(o) : w;
return w/h;}
xports['aspect'] = aspect;
xports['inX'] = function(el, cushion) {
var r = rectangle(el, cushion);
return !!r && r.right >= 0 && r.left <= viewportW();};
xports['inY'] = function(el, cushion) {
var r = rectangle(el, cushion);
return !!r && r.bottom >= 0 && r.top <= viewportH();};
xports['inViewport'] = function(el, cushion) {
var r = rectangle(el, cushion);
return !!r && r.bottom >= 0 && r.right >= 0 && r.top <= viewportH() && r.left <= viewportW();};
return xports;
}));


String.prototype.parseColor = function() {
var color = '#';
if (this.slice(0,4) == 'rgb(') {
var cols = this.slice(4,this.length-1).split(',');
var i=0; do { color += parseInt(cols[i]).toColorPart() } while (++i<3);
} else {
if (this.slice(0,1) == '#') {
if (this.length==4) for(var i=1;i<4;i++) color += (this.charAt(i) + this.charAt(i)).toLowerCase();
if (this.length==7) color = this.toLowerCase();}}
return (color.length==7 ? color : (arguments[0] || this));};
Element.collectTextNodes = function(element) {
return $A(prototype$(element).childNodes).collect( function(node) {
return (node.nodeType==3 ? node.nodeValue :
(node.hasChildNodes() ? Element.collectTextNodes(node) : ''));
}).flatten().join('');};
Element.collectTextNodesIgnoreClass = function(element, className) {
return $A(prototype$(element).childNodes).collect( function(node) {
return (node.nodeType==3 ? node.nodeValue :
((node.hasChildNodes() && !Element.hasClassName(node,className)) ?
Element.collectTextNodesIgnoreClass(node, className) : ''));
}).flatten().join('');};
Element.setContentZoom = function(element, percent) {
element = prototype$(element);
element.setStyle({fontSize: (percent/100) + 'em'});
if (Prototype.Browser.WebKit) window.scrollBy(0,0);
return element;};
Element.getInlineOpacity = function(element){
return prototype$(element).style.opacity || '';};
Element.forceRerendering = function(element) {
try {
element = prototype$(element);
var n = document.createTextNode(' ');
element.appendChild(n);
element.removeChild(n);
} catch(e) { }};
var Effect = {
_elementDoesNotExistError: {
name: 'ElementDoesNotExistError',
message: 'The specified DOM element does not exist, but is required for this effect to operate'},
Transitions: {
linear: Prototype.K,
sinoidal: function(pos) {
return (-Math.cos(pos*Math.PI)/2) + .5;},
reverse: function(pos) {
return 1-pos;},
flicker: function(pos) {
var pos = ((-Math.cos(pos*Math.PI)/4) + .75) + Math.random()/4;
return pos > 1 ? 1 : pos;},
wobble: function(pos) {
return (-Math.cos(pos*Math.PI*(9*pos))/2) + .5;},
pulse: function(pos, pulses) {
return (-Math.cos((pos*((pulses||5)-.5)*2)*Math.PI)/2) + .5;},
spring: function(pos) {
return 1 - (Math.cos(pos * 4.5 * Math.PI) * Math.exp(-pos * 6));},
none: function(pos) {
return 0;},
full: function(pos) {
return 1;}},
DefaultOptions: {
duration:   1.0,   // seconds
fps:        100,   // 100= assume 66fps max.
sync:       false, // true for combining
from:       0.0,
to:         1.0,
delay:      0.0,
queue:      'parallel'},
tagifyText: function(element) {
var tagifyStyle = 'position:relative';
if (Prototype.Browser.IE) tagifyStyle += ';zoom:1';
element = prototype$(element);
$A(element.childNodes).each( function(child) {
if (child.nodeType==3) {
child.nodeValue.toArray().each( function(character) {
element.insertBefore(
new Element('span', {style: tagifyStyle}).update(
character == ' ' ? String.fromCharCode(160) : character),
child);});
Element.remove(child);}});},
multiple: function(element, effect) {
var elements;
if (((typeof element == 'object') ||
Object.isFunction(element)) &&
(element.length))
elements = element;
else
elements = prototype$(element).childNodes;
var options = Object.extend({
speed: 0.1,
delay: 0.0
}, arguments[2] || { });
var masterDelay = options.delay;
$A(elements).each( function(element, index) {
new effect(element, Object.extend(options, { delay: index * options.speed + masterDelay }));});},
PAIRS: {
'slide':  ['SlideDown','SlideUp'],
'blind':  ['BlindDown','BlindUp'],
'appear': ['Appear','Fade']},
toggle: function(element, effect, options) {
element = prototype$(element);
effect  = (effect || 'appear').toLowerCase();
return Effect[ Effect.PAIRS[ effect ][ element.visible() ? 1 : 0 ] ](element, Object.extend({
queue: { position:'end', scope:(element.id || 'global'), limit: 1 }
}, options || {}));}};
Effect.DefaultOptions.transition = Effect.Transitions.sinoidal;
Effect.ScopedQueue = Class.create(Enumerable, {
initialize: function() {
this.effects  = [];
this.interval = null;},
_each: function(iterator) {
this.effects._each(iterator);},
add: function(effect) {
var timestamp = new Date().getTime();
var position = Object.isString(effect.options.queue) ?
effect.options.queue : effect.options.queue.position;
switch(position) {
case 'front':
this.effects.findAll(function(e){ return e.state=='idle' }).each( function(e) {
e.startOn  += effect.finishOn;
e.finishOn += effect.finishOn;});
break;
case 'with-last':
timestamp = this.effects.pluck('startOn').max() || timestamp;
break;
case 'end':
timestamp = this.effects.pluck('finishOn').max() || timestamp;
break;}
effect.startOn  += timestamp;
effect.finishOn += timestamp;
if (!effect.options.queue.limit || (this.effects.length < effect.options.queue.limit))
this.effects.push(effect);
if (!this.interval)
this.interval = setInterval(this.loop.bind(this), 15);},
remove: function(effect) {
this.effects = this.effects.reject(function(e) { return e==effect });
if (this.effects.length == 0) {
clearInterval(this.interval);
this.interval = null;}},
loop: function() {
var timePos = new Date().getTime();
for(var i=0, len=this.effects.length;i<len;i++)
this.effects[i] && this.effects[i].loop(timePos);}});
Effect.Queues = {
instances: $H(),
get: function(queueName) {
if (!Object.isString(queueName)) return queueName;
return this.instances.get(queueName) ||
this.instances.set(queueName, new Effect.ScopedQueue());}};
Effect.Queue = Effect.Queues.get('global');
Effect.Base = Class.create({
position: null,
start: function(options) {
if (options && options.transition === false) options.transition = Effect.Transitions.linear;
this.options      = Object.extend(Object.extend({ },Effect.DefaultOptions), options || { });
this.currentFrame = 0;
this.state        = 'idle';
this.startOn      = this.options.delay*1000;
this.finishOn     = this.startOn+(this.options.duration*1000);
this.fromToDelta  = this.options.to-this.options.from;
this.totalTime    = this.finishOn-this.startOn;
this.totalFrames  = this.options.fps*this.options.duration;
this.render = (function() {
function dispatch(effect, eventName) {
if (effect.options[eventName + 'Internal'])
effect.options[eventName + 'Internal'](effect);
if (effect.options[eventName])
effect.options[eventName](effect);}
return function(pos) {
if (this.state === "idle") {
this.state = "running";
dispatch(this, 'beforeSetup');
if (this.setup) this.setup();
dispatch(this, 'afterSetup');}
if (this.state === "running") {
pos = (this.options.transition(pos) * this.fromToDelta) + this.options.from;
this.position = pos;
dispatch(this, 'beforeUpdate');
if (this.update) this.update(pos);
dispatch(this, 'afterUpdate');}};
})();
this.event('beforeStart');
if (!this.options.sync)
Effect.Queues.get(Object.isString(this.options.queue) ?
'global' : this.options.queue.scope).add(this);},
loop: function(timePos) {
if (timePos >= this.startOn) {
if (timePos >= this.finishOn) {
this.render(1.0);
this.cancel();
this.event('beforeFinish');
if (this.finish) this.finish();
this.event('afterFinish');
return;}
var pos   = (timePos - this.startOn) / this.totalTime,
frame = (pos * this.totalFrames).round();
if (frame > this.currentFrame) {
this.render(pos);
this.currentFrame = frame;}}},
cancel: function() {
if (!this.options.sync)
Effect.Queues.get(Object.isString(this.options.queue) ?
'global' : this.options.queue.scope).remove(this);
this.state = 'finished';},
event: function(eventName) {
if (this.options[eventName + 'Internal']) this.options[eventName + 'Internal'](this);
if (this.options[eventName]) this.options[eventName](this);},
inspect: function() {
var data = $H();
for(property in this)
if (!Object.isFunction(this[property])) data.set(property, this[property]);
return '#<Effect:' + data.inspect() + ',options:' + $H(this.options).inspect() + '>';}});
Effect.Parallel = Class.create(Effect.Base, {
initialize: function(effects) {
this.effects = effects || [];
this.start(arguments[1]);},
update: function(position) {
this.effects.invoke('render', position);},
finish: function(position) {
this.effects.each( function(effect) {
effect.render(1.0);
effect.cancel();
effect.event('beforeFinish');
if (effect.finish) effect.finish(position);
effect.event('afterFinish');});}});
Effect.Tween = Class.create(Effect.Base, {
initialize: function(object, from, to) {
object = Object.isString(object) ? prototype$(object) : object;
var args = $A(arguments), method = args.last(),
options = args.length == 5 ? args[3] : null;
this.method = Object.isFunction(method) ? method.bind(object) :
Object.isFunction(object[method]) ? object[method].bind(object) :
function(value) { object[method] = value };
this.start(Object.extend({ from: from, to: to }, options || { }));},
update: function(position) {
this.method(position);}});
Effect.Event = Class.create(Effect.Base, {
initialize: function() {
this.start(Object.extend({ duration: 0 }, arguments[0] || { }));},
update: Prototype.emptyFunction});
Effect.Opacity = Class.create(Effect.Base, {
initialize: function(element) {
this.element = prototype$(element);
if (!this.element) throw(Effect._elementDoesNotExistError);
if (Prototype.Browser.IE && (!this.element.currentStyle.hasLayout))
this.element.setStyle({zoom: 1});
var options = Object.extend({
from: this.element.getOpacity() || 0.0,
to:   1.0
}, arguments[1] || { });
this.start(options);},
update: function(position) {
this.element.setOpacity(parseFloat(position));}});
Effect.Move = Class.create(Effect.Base, {
initialize: function(element) {
this.element = prototype$(element);
if (!this.element) throw(Effect._elementDoesNotExistError);
var options = Object.extend({
x:    0,
y:    0,
mode: 'relative'
}, arguments[1] || { });
this.start(options);},
setup: function() {
this.element.makePositioned();
this.originalLeft = parseFloat(this.element.getStyle('left') || '0');
this.originalTop  = parseFloat(this.element.getStyle('top')  || '0');
if (this.options.mode == 'absolute') {
this.options.x = this.options.x - this.originalLeft;
this.options.y = this.options.y - this.originalTop;}},
update: function(position) {
this.element.setStyle({
left: (this.options.x  * position + this.originalLeft).round() + 'px',
top:  (this.options.y  * position + this.originalTop).round()  + 'px'});}});
Effect.MoveBy = function(element, toTop, toLeft) {
return new Effect.Move(element,
Object.extend({ x: toLeft, y: toTop }, arguments[3] || { }));};
Effect.Scale = Class.create(Effect.Base, {
initialize: function(element, percent) {
this.element = prototype$(element);
if (!this.element) throw(Effect._elementDoesNotExistError);
var options = Object.extend({
scaleX: true,
scaleY: true,
scaleContent: true,
scaleFromCenter: false,
scaleMode: 'box',        // 'box' or 'contents' or { } with provided values
scaleFrom: 100.0,
scaleTo:   percent
}, arguments[2] || { });
this.start(options);},
setup: function() {
this.restoreAfterFinish = this.options.restoreAfterFinish || false;
this.elementPositioning = this.element.getStyle('position');
this.originalStyle = { };
['top','left','width','height','fontSize'].each( function(k) {
this.originalStyle[k] = this.element.style[k];
}.bind(this));
this.originalTop  = this.element.offsetTop;
this.originalLeft = this.element.offsetLeft;
var fontSize = this.element.getStyle('font-size') || '100%';
['em','px','%','pt'].each( function(fontSizeType) {
if (fontSize.indexOf(fontSizeType)>0) {
this.fontSize     = parseFloat(fontSize);
this.fontSizeType = fontSizeType;}
}.bind(this));
this.factor = (this.options.scaleTo - this.options.scaleFrom)/100;
this.dims = null;
if (this.options.scaleMode=='box')
this.dims = [this.element.offsetHeight, this.element.offsetWidth];
if (/^content/.test(this.options.scaleMode))
this.dims = [this.element.scrollHeight, this.element.scrollWidth];
if (!this.dims)
this.dims = [this.options.scaleMode.originalHeight,
this.options.scaleMode.originalWidth];},
update: function(position) {
var currentScale = (this.options.scaleFrom/100.0) + (this.factor * position);
if (this.options.scaleContent && this.fontSize)
this.element.setStyle({fontSize: this.fontSize * currentScale + this.fontSizeType });
this.setDimensions(this.dims[0] * currentScale, this.dims[1] * currentScale);},
finish: function(position) {
if (this.restoreAfterFinish) this.element.setStyle(this.originalStyle);},
setDimensions: function(height, width) {
var d = { };
if (this.options.scaleX) d.width = width.round() + 'px';
if (this.options.scaleY) d.height = height.round() + 'px';
if (this.options.scaleFromCenter) {
var topd  = (height - this.dims[0])/2;
var leftd = (width  - this.dims[1])/2;
if (this.elementPositioning == 'absolute') {
if (this.options.scaleY) d.top = this.originalTop-topd + 'px';
if (this.options.scaleX) d.left = this.originalLeft-leftd + 'px';
} else {
if (this.options.scaleY) d.top = -topd + 'px';
if (this.options.scaleX) d.left = -leftd + 'px';}}
this.element.setStyle(d);}});
Effect.Highlight = Class.create(Effect.Base, {
initialize: function(element) {
this.element = prototype$(element);
if (!this.element) throw(Effect._elementDoesNotExistError);
var options = Object.extend({ startcolor: '#ffff99' }, arguments[1] || { });
this.start(options);},
setup: function() {
if (this.element.getStyle('display')=='none') { this.cancel(); return; }
this.oldStyle = { };
if (!this.options.keepBackgroundImage) {
this.oldStyle.backgroundImage = this.element.getStyle('background-image');
this.element.setStyle({backgroundImage: 'none'});}
if (!this.options.endcolor)
this.options.endcolor = this.element.getStyle('background-color').parseColor('#ffffff');
if (!this.options.restorecolor)
this.options.restorecolor = this.element.getStyle('background-color');
this._base  = $R(0,2).map(function(i){ return parseInt(this.options.startcolor.slice(i*2+1,i*2+3),16) }.bind(this));
this._delta = $R(0,2).map(function(i){ return parseInt(this.options.endcolor.slice(i*2+1,i*2+3),16)-this._base[i] }.bind(this));},
update: function(position) {
this.element.setStyle({backgroundColor: $R(0,2).inject('#',function(m,v,i){
return m+((this._base[i]+(this._delta[i]*position)).round().toColorPart()); }.bind(this)) });},
finish: function() {
this.element.setStyle(Object.extend(this.oldStyle, {
backgroundColor: this.options.restorecolor
}));}});
Effect.ScrollTo = function(element) {
var options = arguments[1] || { },
scrollOffsets = document.viewport.getScrollOffsets(),
elementOffsets = prototype$(element).cumulativeOffset();
if (options.offset) elementOffsets[1] += options.offset;
return new Effect.Tween(null,
scrollOffsets.top,
elementOffsets[1],
options,
function(p){ scrollTo(scrollOffsets.left, p.round()); }
);};
Effect.Fade = function(element) {
element = prototype$(element);
var oldOpacity = element.getInlineOpacity();
var options = Object.extend({
from: element.getOpacity() || 1.0,
to:   0.0,
afterFinishInternal: function(effect) {
if (effect.options.to!=0) return;
effect.element.hide().setStyle({opacity: oldOpacity});}
}, arguments[1] || { });
return new Effect.Opacity(element,options);};
Effect.Appear = function(element) {
element = prototype$(element);
var options = Object.extend({
from: (element.getStyle('display') == 'none' ? 0.0 : element.getOpacity() || 0.0),
to:   1.0,
afterFinishInternal: function(effect) {
effect.element.forceRerendering();},
beforeSetup: function(effect) {
effect.element.setOpacity(effect.options.from).show();
}}, arguments[1] || { });
return new Effect.Opacity(element,options);};
Effect.Puff = function(element) {
element = prototype$(element);
var oldStyle = {
opacity: element.getInlineOpacity(),
position: element.getStyle('position'),
top:  element.style.top,
left: element.style.left,
width: element.style.width,
height: element.style.height};
return new Effect.Parallel(
[ new Effect.Scale(element, 200,
{ sync: true, scaleFromCenter: true, scaleContent: true, restoreAfterFinish: true }),
new Effect.Opacity(element, { sync: true, to: 0.0 } ) ],
Object.extend({ duration: 1.0,
beforeSetupInternal: function(effect) {
Position.absolutize(effect.effects[0].element);},
afterFinishInternal: function(effect) {
effect.effects[0].element.hide().setStyle(oldStyle); }
}, arguments[1] || { })
);};
Effect.BlindUp = function(element) {
element = prototype$(element);
element.makeClipping();
return new Effect.Scale(element, 0,
Object.extend({ scaleContent: false,
scaleX: false,
restoreAfterFinish: true,
afterFinishInternal: function(effect) {
effect.element.hide().undoClipping();}
}, arguments[1] || { })
);};
Effect.BlindDown = function(element) {
element = prototype$(element);
var elementDimensions = element.getDimensions();
return new Effect.Scale(element, 100, Object.extend({
scaleContent: false,
scaleX: false,
scaleFrom: 0,
scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
restoreAfterFinish: true,
afterSetup: function(effect) {
effect.element.makeClipping().setStyle({height: '0px'}).show();},
afterFinishInternal: function(effect) {
effect.element.undoClipping();}
}, arguments[1] || { }));};
Effect.SwitchOff = function(element) {
element = prototype$(element);
var oldOpacity = element.getInlineOpacity();
return new Effect.Appear(element, Object.extend({
duration: 0.4,
from: 0,
transition: Effect.Transitions.flicker,
afterFinishInternal: function(effect) {
new Effect.Scale(effect.element, 1, {
duration: 0.3, scaleFromCenter: true,
scaleX: false, scaleContent: false, restoreAfterFinish: true,
beforeSetup: function(effect) {
effect.element.makePositioned().makeClipping();},
afterFinishInternal: function(effect) {
effect.element.hide().undoClipping().undoPositioned().setStyle({opacity: oldOpacity});}});}
}, arguments[1] || { }));};
Effect.DropOut = function(element) {
element = prototype$(element);
var oldStyle = {
top: element.getStyle('top'),
left: element.getStyle('left'),
opacity: element.getInlineOpacity() };
return new Effect.Parallel(
[ new Effect.Move(element, {x: 0, y: 100, sync: true }),
new Effect.Opacity(element, { sync: true, to: 0.0 }) ],
Object.extend(
{ duration: 0.5,
beforeSetup: function(effect) {
effect.effects[0].element.makePositioned();},
afterFinishInternal: function(effect) {
effect.effects[0].element.hide().undoPositioned().setStyle(oldStyle);}
}, arguments[1] || { }));};
Effect.Shake = function(element) {
element = prototype$(element);
var options = Object.extend({
distance: 20,
duration: 0.5
}, arguments[1] || {});
var distance = parseFloat(options.distance);
var split = parseFloat(options.duration) / 10.0;
var oldStyle = {
top: element.getStyle('top'),
left: element.getStyle('left') };
return new Effect.Move(element,
{ x:  distance, y: 0, duration: split, afterFinishInternal: function(effect) {
new Effect.Move(effect.element,
{ x: -distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
new Effect.Move(effect.element,
{ x:  distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
new Effect.Move(effect.element,
{ x: -distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
new Effect.Move(effect.element,
{ x:  distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
new Effect.Move(effect.element,
{ x: -distance, y: 0, duration: split, afterFinishInternal: function(effect) {
effect.element.undoPositioned().setStyle(oldStyle);
}}); }}); }}); }}); }}); }});};
Effect.SlideDown = function(element) {
element = prototype$(element).cleanWhitespace();
var oldInnerBottom = element.down().getStyle('bottom');
var elementDimensions = element.getDimensions();
return new Effect.Scale(element, 100, Object.extend({
scaleContent: false,
scaleX: false,
scaleFrom: window.opera ? 0 : 1,
scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
restoreAfterFinish: true,
afterSetup: function(effect) {
effect.element.makePositioned();
effect.element.down().makePositioned();
if (window.opera) effect.element.setStyle({top: ''});
effect.element.makeClipping().setStyle({height: '0px'}).show();},
afterUpdateInternal: function(effect) {
effect.element.down().setStyle({bottom:
(effect.dims[0] - effect.element.clientHeight) + 'px' });},
afterFinishInternal: function(effect) {
effect.element.undoClipping().undoPositioned();
effect.element.down().undoPositioned().setStyle({bottom: oldInnerBottom}); }
}, arguments[1] || { })
);};
Effect.SlideUp = function(element) {
element = prototype$(element).cleanWhitespace();
var oldInnerBottom = element.down().getStyle('bottom');
var elementDimensions = element.getDimensions();
return new Effect.Scale(element, window.opera ? 0 : 1,
Object.extend({ scaleContent: false,
scaleX: false,
scaleMode: 'box',
scaleFrom: 100,
scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
restoreAfterFinish: true,
afterSetup: function(effect) {
effect.element.makePositioned();
effect.element.down().makePositioned();
if (window.opera) effect.element.setStyle({top: ''});
effect.element.makeClipping().show();},
afterUpdateInternal: function(effect) {
effect.element.down().setStyle({bottom:
(effect.dims[0] - effect.element.clientHeight) + 'px' });},
afterFinishInternal: function(effect) {
effect.element.hide().undoClipping().undoPositioned();
effect.element.down().undoPositioned().setStyle({bottom: oldInnerBottom});}
}, arguments[1] || { })
);};
Effect.Squish = function(element) {
return new Effect.Scale(element, window.opera ? 1 : 0, {
restoreAfterFinish: true,
beforeSetup: function(effect) {
effect.element.makeClipping();},
afterFinishInternal: function(effect) {
effect.element.hide().undoClipping();}});};
Effect.Grow = function(element) {
element = prototype$(element);
var options = Object.extend({
direction: 'center',
moveTransition: Effect.Transitions.sinoidal,
scaleTransition: Effect.Transitions.sinoidal,
opacityTransition: Effect.Transitions.full
}, arguments[1] || { });
var oldStyle = {
top: element.style.top,
left: element.style.left,
height: element.style.height,
width: element.style.width,
opacity: element.getInlineOpacity() };
var dims = element.getDimensions();
var initialMoveX, initialMoveY;
var moveX, moveY;
switch (options.direction) {
case 'top-left':
initialMoveX = initialMoveY = moveX = moveY = 0;
break;
case 'top-right':
initialMoveX = dims.width;
initialMoveY = moveY = 0;
moveX = -dims.width;
break;
case 'bottom-left':
initialMoveX = moveX = 0;
initialMoveY = dims.height;
moveY = -dims.height;
break;
case 'bottom-right':
initialMoveX = dims.width;
initialMoveY = dims.height;
moveX = -dims.width;
moveY = -dims.height;
break;
case 'center':
initialMoveX = dims.width / 2;
initialMoveY = dims.height / 2;
moveX = -dims.width / 2;
moveY = -dims.height / 2;
break;}
return new Effect.Move(element, {
x: initialMoveX,
y: initialMoveY,
duration: 0.01,
beforeSetup: function(effect) {
effect.element.hide().makeClipping().makePositioned();},
afterFinishInternal: function(effect) {
new Effect.Parallel(
[ new Effect.Opacity(effect.element, { sync: true, to: 1.0, from: 0.0, transition: options.opacityTransition }),
new Effect.Move(effect.element, { x: moveX, y: moveY, sync: true, transition: options.moveTransition }),
new Effect.Scale(effect.element, 100, {
scaleMode: { originalHeight: dims.height, originalWidth: dims.width },
sync: true, scaleFrom: window.opera ? 1 : 0, transition: options.scaleTransition, restoreAfterFinish: true})
], Object.extend({
beforeSetup: function(effect) {
effect.effects[0].element.setStyle({height: '0px'}).show();},
afterFinishInternal: function(effect) {
effect.effects[0].element.undoClipping().undoPositioned().setStyle(oldStyle);}
}, options)
);}});};
Effect.Shrink = function(element) {
element = prototype$(element);
var options = Object.extend({
direction: 'center',
moveTransition: Effect.Transitions.sinoidal,
scaleTransition: Effect.Transitions.sinoidal,
opacityTransition: Effect.Transitions.none
}, arguments[1] || { });
var oldStyle = {
top: element.style.top,
left: element.style.left,
height: element.style.height,
width: element.style.width,
opacity: element.getInlineOpacity() };
var dims = element.getDimensions();
var moveX, moveY;
switch (options.direction) {
case 'top-left':
moveX = moveY = 0;
break;
case 'top-right':
moveX = dims.width;
moveY = 0;
break;
case 'bottom-left':
moveX = 0;
moveY = dims.height;
break;
case 'bottom-right':
moveX = dims.width;
moveY = dims.height;
break;
case 'center':
moveX = dims.width / 2;
moveY = dims.height / 2;
break;}
return new Effect.Parallel(
[ new Effect.Opacity(element, { sync: true, to: 0.0, from: 1.0, transition: options.opacityTransition }),
new Effect.Scale(element, window.opera ? 1 : 0, { sync: true, transition: options.scaleTransition, restoreAfterFinish: true}),
new Effect.Move(element, { x: moveX, y: moveY, sync: true, transition: options.moveTransition })
], Object.extend({
beforeStartInternal: function(effect) {
effect.effects[0].element.makePositioned().makeClipping();},
afterFinishInternal: function(effect) {
effect.effects[0].element.hide().undoClipping().undoPositioned().setStyle(oldStyle); }
}, options)
);};
Effect.Pulsate = function(element) {
element = prototype$(element);
var options    = arguments[1] || { },
oldOpacity = element.getInlineOpacity(),
transition = options.transition || Effect.Transitions.linear,
reverser   = function(pos){
return 1 - transition((-Math.cos((pos*(options.pulses||5)*2)*Math.PI)/2) + .5);};
return new Effect.Opacity(element,
Object.extend(Object.extend({  duration: 2.0, from: 0,
afterFinishInternal: function(effect) { effect.element.setStyle({opacity: oldOpacity}); }
}, options), {transition: reverser}));};
Effect.Fold = function(element) {
element = prototype$(element);
var oldStyle = {
top: element.style.top,
left: element.style.left,
width: element.style.width,
height: element.style.height };
element.makeClipping();
return new Effect.Scale(element, 5, Object.extend({
scaleContent: false,
scaleX: false,
afterFinishInternal: function(effect) {
new Effect.Scale(element, 1, {
scaleContent: false,
scaleY: false,
afterFinishInternal: function(effect) {
effect.element.hide().undoClipping().setStyle(oldStyle);
} });
}}, arguments[1] || { }));};
Effect.Morph = Class.create(Effect.Base, {
initialize: function(element) {
this.element = prototype$(element);
if (!this.element) throw(Effect._elementDoesNotExistError);
var options = Object.extend({
style: { }
}, arguments[1] || { });
if (!Object.isString(options.style)) this.style = $H(options.style);
else {
if (options.style.include(':'))
this.style = options.style.parseStyle();
else {
this.element.addClassName(options.style);
this.style = $H(this.element.getStyles());
this.element.removeClassName(options.style);
var css = this.element.getStyles();
this.style = this.style.reject(function(style) {
return style.value == css[style.key];});
options.afterFinishInternal = function(effect) {
effect.element.addClassName(effect.options.style);
effect.transforms.each(function(transform) {
effect.element.style[transform.style] = '';});};}}
this.start(options);},
setup: function(){
function parseColor(color){
if (!color || ['rgba(0, 0, 0, 0)','transparent'].include(color)) color = '#ffffff';
color = color.parseColor();
return $R(0,2).map(function(i){
return parseInt( color.slice(i*2+1,i*2+3), 16 );});}
this.transforms = this.style.map(function(pair){
var property = pair[0], value = pair[1], unit = null;
if (value.parseColor('#zzzzzz') != '#zzzzzz') {
value = value.parseColor();
unit  = 'color';
} else if (property == 'opacity') {
value = parseFloat(value);
if (Prototype.Browser.IE && (!this.element.currentStyle.hasLayout))
this.element.setStyle({zoom: 1});
} else if (Element.CSS_LENGTH.test(value)) {
var components = value.match(/^([\+\-]?[0-9\.]+)(.*)$/);
value = parseFloat(components[1]);
unit = (components.length == 3) ? components[2] : null;}
var originalValue = this.element.getStyle(property);
return {
style: property.camelize(),
originalValue: unit=='color' ? parseColor(originalValue) : parseFloat(originalValue || 0),
targetValue: unit=='color' ? parseColor(value) : value,
unit: unit};
}.bind(this)).reject(function(transform){
return (
(transform.originalValue == transform.targetValue) ||
(
transform.unit != 'color' &&
(isNaN(transform.originalValue) || isNaN(transform.targetValue))
)
);});},
update: function(position) {
var style = { }, transform, i = this.transforms.length;
while(i--)
style[(transform = this.transforms[i]).style] =
transform.unit=='color' ? '#'+
(Math.round(transform.originalValue[0]+
(transform.targetValue[0]-transform.originalValue[0])*position)).toColorPart() +
(Math.round(transform.originalValue[1]+
(transform.targetValue[1]-transform.originalValue[1])*position)).toColorPart() +
(Math.round(transform.originalValue[2]+
(transform.targetValue[2]-transform.originalValue[2])*position)).toColorPart() :
(transform.originalValue +
(transform.targetValue - transform.originalValue) * position).toFixed(3) +
(transform.unit === null ? '' : transform.unit);
this.element.setStyle(style, true);}});
Effect.Transform = Class.create({
initialize: function(tracks){
this.tracks  = [];
this.options = arguments[1] || { };
this.addTracks(tracks);},
addTracks: function(tracks){
tracks.each(function(track){
track = $H(track);
var data = track.values().first();
this.tracks.push($H({
ids:     track.keys().first(),
effect:  Effect.Morph,
options: { style: data }
}));
}.bind(this));
return this;},
play: function(){
return new Effect.Parallel(
this.tracks.map(function(track){
var ids = track.get('ids'), effect = track.get('effect'), options = track.get('options');
var elements = [prototype$(ids) || $$(ids)].flatten();
return elements.map(function(e){ return new effect(e, Object.extend({ sync:true }, options)) });
}).flatten(),
this.options
);}});
Element.CSS_PROPERTIES = $w(
'backgroundColor backgroundPosition borderBottomColor borderBottomStyle ' +
'borderBottomWidth borderLeftColor borderLeftStyle borderLeftWidth ' +
'borderRightColor borderRightStyle borderRightWidth borderSpacing ' +
'borderTopColor borderTopStyle borderTopWidth bottom clip color ' +
'fontSize fontWeight height left letterSpacing lineHeight ' +
'marginBottom marginLeft marginRight marginTop markerOffset maxHeight '+
'maxWidth minHeight minWidth opacity outlineColor outlineOffset ' +
'outlineWidth paddingBottom paddingLeft paddingRight paddingTop ' +
'right textIndent top width wordSpacing zIndex');
Element.CSS_LENGTH = /^(([\+\-]?[0-9\.]+)(em|ex|px|in|cm|mm|pt|pc|\%))|0$/;
String.__parseStyleElement = document.createElement('div');
String.prototype.parseStyle = function(){
var style, styleRules = $H();
if (Prototype.Browser.WebKit)
style = new Element('div',{style:this}).style;
else {
String.__parseStyleElement.innerHTML = '<div style="' + this + '"></div>';
style = String.__parseStyleElement.childNodes[0].style;}
Element.CSS_PROPERTIES.each(function(property){
if (style[property]) styleRules.set(property, style[property]);});
if (Prototype.Browser.IE && this.include('opacity'))
styleRules.set('opacity', this.match(/opacity:\s*((?:0|1)?(?:\.\d*)?)/)[1]);
return styleRules;};
if (document.defaultView && document.defaultView.getComputedStyle) {
Element.getStyles = function(element) {
var css = document.defaultView.getComputedStyle(prototype$(element), null);
return Element.CSS_PROPERTIES.inject({ }, function(styles, property) {
styles[property] = css[property];
return styles;});};
} else {
Element.getStyles = function(element) {
element = prototype$(element);
var css = element.currentStyle, styles;
styles = Element.CSS_PROPERTIES.inject({ }, function(results, property) {
results[property] = css[property];
return results;});
if (!styles.opacity) styles.opacity = element.getOpacity();
return styles;};}
Effect.Methods = {
morph: function(element, style) {
element = prototype$(element);
new Effect.Morph(element, Object.extend({ style: style }, arguments[2] || { }));
return element;},
visualEffect: function(element, effect, options) {
element = prototype$(element);
var s = effect.dasherize().camelize(), klass = s.charAt(0).toUpperCase() + s.substring(1);
new Effect[klass](element, options);
return element;},
highlight: function(element, options) {
element = prototype$(element);
new Effect.Highlight(element, options);
return element;}};
$w('fade appear grow shrink fold blindUp blindDown slideUp slideDown '+
'pulsate shake puff squish switchOff dropOut').each(
function(effect) {
Effect.Methods[effect] = function(element, options){
element = prototype$(element);
Effect[effect.charAt(0).toUpperCase() + effect.substring(1)](element, options);
return element;};}
);
$w('getInlineOpacity forceRerendering setContentZoom collectTextNodes collectTextNodesIgnoreClass getStyles').each(
function(f) { Effect.Methods[f] = Element[f]; }
);
Element.addMethods(Effect.Methods);

com.liquidpixels.event.KeyPress = Class.create({
target:				undefined,
ignoreKeyboard: 	false,
unlessKeys:			undefined,
modifiers:			0,
initialize:	function (target, options) {
this.options = options || {};
this.target = target;
this.registerKeyDownHandler();
this.unlessKeys = [];},
registerKeyDownHandler: function() {
Event.observe(document, 'keydown', this.keyHandler.bind(this), false);
Event.observe(document, 'keyup', this.keyHandler.bind(this), false);},
unRegisterKeyDownHandler: function() {
Event.stopObserving(document, 'keydown');
Event.stopObserving(document, 'keyup');},
keyHandler: function(e) {
if (this.ignoreKeyboard && (this.unlessKeys.length == 0)) {	return;	}
var evt = (e) ? e : (window.event) ? window.event : null;
if(evt) {
evt.cancelBubble = true;
if(evt.stopPropagation) { evt.stopPropagation(); }
var key = (evt.keyCode) ? evt.keyCode : ((evt.which) ? evt.which : 0);
if (this.ignoreKeyboard &&  (this.unlessKeys.indexOf(key) == -1) ) { return; }
var action = true;
if(e.type === 'keydown') {
this.modifiers |= com.liquidpixels.event.KeyPress.map[key];
} else if(e.type === 'keyup') {
if(com.liquidpixels.event.KeyPress.map[key]) {
this.modifiers &= !com.liquidpixels.event.KeyPress.map[key];}
if(this.options.pressActionOnly) { action = false; }}
e.char = this.keyToString(key);
e.modifiers = this.modifiers;
e.modifier = com.liquidpixels.event.KeyPress.map[key];
e.key = key;
e.down = true;
if(!action) {return;}
if(this.target.actOnKey) {
this.target.actOnKey(e);
} else if(this.options.actOnKey) {
this.options.actOnKey(e);}}},
setIgnore: function(ignore, unless) {
if (ignore) {
this.unlessKeys = unless || [];
} else {
this.unlessKeys = [];}
this.ignoreKeyboard = ignore;},
keyToString: function(key) {
return String.fromCharCode(key);},
DESTROY: function() {
this.unRegisterKeyDownHandler();
this.target = null;},
toString: function() { return 'com.liquidpixels.event.KeyPress'; }});
com.liquidpixels.event.KeyPress.map = {
16: 	1,	// Shift
17:		2,	// Control
18:		4,	// Option/Alt
93:		8,	// Command (safari)
224:	8	// Command (firefox)
};
com.liquidpixels.event.KeyPress.keys = {
k_colon:	59,		// :
k_tilde:	192,	// ~
k_plus:		61,	 	// + or =
n_equal:	61,	  	// numpad =
n_plus:		107,	// numpad +
k_minus:	189, 	// might be 109; test for both...
n_minus:	109,	// numpad -
k_delete:	8,
k_bspace:	8,
k_shift:	16,
k_control:	17,
k_alt:		18,
k_space:	32,
k_left:		37,
k_up:		38,
k_right:	39,
k_down:		40,
k_esc:		27,
k_bslash:	220, 	// '\'
k_lcurly:	219, 	// {
k_rcurly:	221, 	// }
k_ocurly:	219, 	// {
k_ccurly:	221, 	// }
k_lesser:	188,	// <
k_greater:	190,	// >
k_enter:	13,
k_return:	13,
n_enter:	13,
n_asterisk:	106,	// numpad *
n_dot:		110		// numpad
};
function _fillEasyKeys() {
for(var i=0; i<10; i++) {
com.liquidpixels.event.KeyPress.keys["k_" + i] = 48 + i;
com.liquidpixels.event.KeyPress.keys["n_" + i] = 96 + i;}
for(var i=65; i<26; i++) {
var kc = String.fromCharCode(i);
com.liquidpixels.event.KeyPress.keys["k_" + kc] = i;}}
_fillEasyKeys();
function $K(value) {
if (com.liquidpixels.event.KeyPress.map[value]) {
return com.liquidpixels.event.KeyPress.map[value];
} else if(com.liquidpixels.event.KeyPress.keys[value]) {
return com.liquidpixels.event.KeyPress.keys[value]
} else {
return 0;}};
com.liquidpixels.utilities.isNaN = function(o) {
if(!o && typeof(o) == "number" && o !== 0) {
return true;
} else {
return false;}};
var $ISNAN = com.liquidpixels.utilities.isNaN;
com.liquidpixels.utilities.isTrue = function(o) {
if(o) {
if(o.toLowerCase) {
var x = o.toLowerCase();
if(x == "no" || x == "false" || x == "0") { return false; }}
return true;}
return false;};
var $ISTRUE = com.liquidpixels.utilities.isTrue;
com.liquidpixels.utilities.objTrue = function(o) {
if(o) {
if(Object.isArray(o)) {
return !!(o.length);
} else if(Object.isHash(o)) {
return !!(o.keys().length);
} else if(typeof(o) === "object") {
return !!(keys(o).length);}
return true;}
return false;};
var $OBJTRUE = com.liquidpixels.utilities.objTrue;
com.liquidpixels.utilities.isDefined = function(a) {
if(typeof(a) == "undefined" || a === null || $ISNAN(a)) {
return false;
} else {
return true;}};
var $DEF = com.liquidpixels.utilities.isDefined;
var $DEFINED = com.liquidpixels.utilities.isDefined;
com.liquidpixels.utilities.ifNullReplace = function(a) {
var len = arguments.length;
for(var i=0; i<len; i++) {
if($DEF(arguments[i])) {
return arguments[i];}}
return arguments[len - 1];};
var $NVL = com.liquidpixels.utilities.ifNullReplace;
com.liquidpixels.utilities.ifNullOrEmptyReplace = function(a) {
var len = arguments.length;
for(var i=0; i<len; i++) {
var arg = arguments[i];
if($DEF(arg) && arg !== "") {
return arg;}}
return arguments[len - 1];};
var $NZS = com.liquidpixels.utilities.ifNullOrEmptyReplace;
com.liquidpixels.utilities.ifNullOrFalseReplace = function(a) {
var len = arguments.length;
for(var i=0; i<len; i++) {
var arg = arguments[i];
if(arg && $DEF(arg)) {
return arg;}}
return arguments[len - 1];};
var $NFV = com.liquidpixels.utilities.ifNullOrFalseReplace;
com.liquidpixels.Console = Class.create( {
pAlert:				undefined,
pConsole:			undefined,
noHeader:			undefined,
pServer:			undefined,
pDatabase:			undefined,
pFile:				undefined,
initialize: function(options) {
if(options) {
this.pAlert = options.allowAlert || false;
var level = options.level || 'none';
this.setMessageLevel(level);
this.noHeader = options.noHeader || false;}},
setMessageLevel: function(level) {
this.pConsole = (window.console && level == 'all' ? true : false);},
useMessageHeader: function(useOn) {
this.noHeader = !(useOn);},
log: function() { this.consoleMethod('log', arguments); },
debug: function() { this.consoleMethod('debug', arguments); },
warn: function() { this.consoleMethod('warn', arguments); },
info: function() { this.consoleMethod('info', arguments); },
error: function() { this.consoleMethod('error', arguments); },
trace: function() {	this.consoleStackTrace(arguments); },
consoleMethod: function(type, args) {
if(!this.pConsole) { return }
var method = type;
if(!this.hasMethod(method)) {
if(this.hasMethod('log')) {
method = "log";
} else {
if(this.pAlert) {
alert(args);
} else {
return;}}}
var header = this.getHeader(type);
if(header) {
args[0] = header + " " + args[0];}
this.consoleApply(method, args);},
consoleStackTrace: function(args) {
if(this.hasMethod('trace')) {
this.consoleMethod('trace', args);
} else if(com.eriwen) {
var trace = printStackTrace();
this.consoleMethod('log', trace);};},
consoleApply: function(method, args, context) {
context = context || window.console || this;
try {
window.console[method].apply(context, args);
} catch(e) {
window.console[method](args);}},
hasMethod: function(method) {
return !!(window.console && window.console[method]);},
emptyFunction: function() {/* EMPTY, FINAL	*/},
subPrintFunction: function(method, args) {
$A(args).each(function(o,i) {
window.console[method](o);});},
getHeader: function(method) {
if(! com.eriwen) { return '' };
if(this.noHeader) { return '' };
if(method == 'log') { return ''};
var i = 6; // deep
var trace = printStackTrace();
var trstr = trace[i];
var func = trstr.slice(0,trstr.indexOf('@')) || "";
func = func.replace(/^klass./,''); // chrome
func = func.replace('Class.create.', ''); // chrome
func = func.replace('<', ''); // FF
var line = trstr.slice(trstr.search(/:\d+/)+1) || "";
var funcLine = "["+method+"] "+func+" ["+line+"]";
return funcLine;},
toString: function() {return "com.liquidpixels.Console"}});
if(typeof _console == 'undefined') {
var _console = new com.liquidpixels.Console({level: "none"});};
com.liquidpixels.Mixable = Class.create( {
options:		undefined, // {}
mixName:		undefined, // {}
target:			undefined, //
exports:		undefined, // array of items to export
overrides:		undefined, // array of items to
initialize: function(options) {
this.options = {};
this.setDefaults();
this.exports = [];
this.overrides = [];
this.prepareExportList();
this.prepareOverridesList();
Object.extend(this.options, options);
if(this.options.mixOpts.setOverrides) {
this.overrides = this.options.mixOpts.setOverrides;}
if(this.options.mixOpts.addOverrides) {
this.overrides.push(this.options.mixOpts.addOverrides);
this.overrides = this.overrides.flatten();}
if(this.options.mixOpts.remOverrides) {
var ovs = this.overrides;
(this.options.mixOpts.remOverrides).each(function(o, i) {
ovs = ovs.without(o);});
this.overrides = ovs;}
if(!this.target) {
this.target = this.options.target || this.options.mixOpts.mixObject;}},
setDefaults: function() { /* VIRTUAL */ },
prepareEvents: function() { /* VIRTUAL */ },
prepare: function() {/* VIRTUAL */ },
clearEvents: function() { /* VIRTUAL */ },
clearEvent: function(eventName) { /* VIRTUAL */ },
prepareExportList: function(list) {
this.addToExportList(['options', 'target', 'mixName', 'exports',
'overrides', 'prepare', 'prepareEvents',
'clearEvents', 'clearEvent',
'toString', 'DESTROY']);
if(list) {
this.addToExportList(list);}},
addToExportList: function(list){
if(list) {
$A(list).each(function(o,i) {
this.exports.push(o);
}.bind(this));}},
getExportList: function() { return this.exports; },
prepareOverridesList: function(list) {
if(list) {
this.addToOverridesList(list);}},
addToOverridesList: function(list) {
if(list) {
$A(list).each(function(o,i) {
this.overrides.push(o);
}.bind(this));}},
getOverrideList: function() { return this.overrides; },
toString: function() { return "com.liquidpixels.Mixable"; },
DESTROY: function() {
this.clearEvents();
this.options = null;}});
com.liquidpixels.Mixable.applyTo = function(object, mixClass, options) {
if(!object) { return false; }
var _Mixer, mixer, mixName, mixOptions;
if(mixClass) {
var mcType = typeof(mixClass);
if(mcType == "function") {
mixer   = mixClass;
mixOptions = options || {};
} else if(mcType == "object") {
mixer = mixClass.mixOpts.mixClass;
mixOptions = mixClass;}
} else {
if(!options) {return false};
mixer   = options.mixOpts.mixClass;
mixOptions = options;}
if(!mixOptions.mixOpts) { mixOptions.mixOpts = {}; }
if(mixer) {
mixOptions.mixOpts.mixObject = object;
_Mixer = new mixer(mixOptions);
mixName = mixOptions.mixOpts.mixName || _Mixer.mixName || mixer.toString();
mixName.replace(/\./g, '_');
if(typeof object[mixName] !== 'undefined') { return false; }
object[mixName] = {};
} else {
_Mixer = new com.liquidpixels.Mixable(mixOptions);
object.Mixable = {};
return false;}
var classExports = _Mixer.getExportList();
if(classExports) {
if(classExports.constructor === Array) {
$A(classExports).each(function(o, i) {
if(_Mixer[o] !== null) {
object[mixName][o] = _Mixer[o];}});
} else {
$H(classExports).each(function(p) {
if(_Mixer[o] !== null) {
object[mixName][p.key] = _Mixer[p.value];}});}}
var classOverrides = _Mixer.getOverrideList();
if(classOverrides) {
if(classOverrides.constructor === Array) {
$A(classOverrides).each(function(o, i) {
if(_Mixer[o] !== null) {
object[o] = _Mixer[o];}});
} else {
$H(classOverrides).each(function(p) {
if(_Mixer[o] !== null) {
object[p.key] = _Mixer[p.value];}});}}
var _MixerName = _Mixer.toString() || _Mixer.mixName || mixOptions.mixOpts.mixName;
object[mixName]._MixClassName = _MixerName;
return true;};
com.liquidpixels.utilities.typeOf = function(thing) {
var instList = com.liquidpixels.utilities.Type.INSTOF;
if(thing == undefined) {
return "Undefined"}
var rtn;
var backupCheck;
var constrBy = "Unknown";
try{
if (thing.constructor.toString().match(/function\s*([^\(]*)/)){
backupCheck = thing.constructor.toString().match(/function\s*([^\(]*)/)[1];
}else if (thing.constructor.toString().match(/\[object\s*([^\]]*)]/)){
backupCheck = thing.constructor.toString().match(/\[object\s*([^\]]*)]/)[1];}
constrBy = thing.constructor.name || backupCheck || "Unknown";
}catch(e){}
if(constrBy == 'Number') {
rtn = (isNaN(thing) ? "NaN" : "Number");
} else if(thing instanceof Hash) {
rtn = "Hash";
} else if(constrBy == 'klass') {
rtn = 'KlassInstance';
} else if(constrBy == 'Function') {
if(thing.name && thing.name == 'klass') {
rtn = 'Klass';
} else {
rtn = 'Function';}}
rtn = rtn || constrBy;
return rtn;};
com.liquidpixels.Basic = Class.create( {
parent:     undefined,
options:    undefined,
initialize: function(parent, options) {
this.parent = parent;
if( !this.options ) { this.options = {}; }
this.setDefaults();
this.initializeSpecific();
this.optionsExtend(options);},
optionsExtend: function(options) {
Object.deepExtend(this.options, options);},
setDefaults: function() {/* VIRTUAL */ },
initializeSpecific: function() {/* VIRTUAL */ },
DESTROY: function() {
this.parent = null;
this.options = null;},
toString: function() { return 'com.liquidpixels.Basic'; }});

com.liquidpixels.consts.Style.getStates = function() {
var states = {
CLR:	{id: 1, name: 'Clear'}, // off, not over, etc.
SET:	{id: 2, name: 'Selected'}, // selected, on, etc.
OVR:	{id: 3, name: 'Over'}, // mouse-over, highlighted, etc.
SOV:	{id: 4, name: 'SelectedOver'}, // selected, mouse-over
DWN:	{id: 5, name: 'Down'}, // not-selected, mouse-down
SDW:	{id: 6, name: 'SelectedDown'}, // selected, mouse-down
DIS:	{id: 7, name: 'Disabled'}, // disabled
ENA:	{id: 8, name: 'Enabled'}  // ==> CLR visual
};
return states;};
com.liquidpixels.consts.Style.getFields = function() {
var fields = new Array(
'cssClass',		// string
'cssStyle',		// {}
'value',		// Hash??
'src',			// string || Chain
'uic',			// UIComponent
'onApply',		// call back
'onRevoke'		// call back
);
return fields;};
if(typeof com.liquidpixels.event === 'undefined') {
com.liquidpixels.event = {};}
com.liquidpixels.utilities.cssEasingFunctions = {
linear: "cubic-bezier(0, 0, 0, 0)",
easeInSine: "cubic-bezier(0.47, 0, 0.745, 0.715)",
easeOutSine: "cubic-bezier(0.39, 0.575, 0.565, 1)",
easeInOutSine: "cubic-bezier(0.445, 0.05, 0.55, 0.95)",
easeInQuad: "cubic-bezier(0.55, 0.085, 0.68, 0.53)",
easeOutQuad: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
easeInOutQuad: "cubic-bezier(0.455, 0.03, 0.515, 0.955)",
easeInCubic: "cubic-bezier(0.55, 0.055, 0.675, 0.19)",
easeOutCubic: "cubic-bezier(0.215, 0.61, 0.355, 1)",
easeInOutCubic: "cubic-bezier(0.645, 0.045, 0.355, 1)",
easeInQuart: "cubic-bezier(0.895, 0.03, 0.685, 0.22)",
easeOutQuart: "cubic-bezier(0.165, 0.84, 0.44, 1)",
easeInOutQuart: "cubic-bezier(0.77, 0, 0.175, 1)",
easeInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
easeOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
easeInOutQuint: "cubic-bezier(0.86, 0, 0.07, 1)",
easeInExpo: "cubic-bezier(0.95, 0.05, 0.795, 0.035)",
easeOutExpo: "cubic-bezier(0.19, 1, 0.22, 1)",
easeInOutExpo: "cubic-bezier(1, 0, 0, 1)",
easeInCirc: "cubic-bezier(0.6, 0.04, 0.98, 0.335)",
easeOutCirc: "cubic-bezier(0.075, 0.82, 0.165, 1)",
easeInOutCirc: "cubic-bezier(0.785, 0.135, 0.15, 0.86)",
easeInBack: "cubic-bezier(0.6, -0.28, 0.735, 0.045)",
easeOutBack: "cubic-bezier(0.175, 0.885, 0.32, 1.275)",
easeInOutBack: "cubic-bezier(0.68, -0.55, 0.265, 1.55)"};

com.liquidpixels.Exception = Class.create( {
type: 					'Exception',		// static, final
target:					undefined,
severity:				'warning',
e:						undefined,
message:				undefined,
fileName:				undefined,
lineNumber:				undefined,
exceptionClass:			undefined,
initialize: function(e) {
if(e) {
this.e = e;
this.target 		  = e.target;
this.severity 		  = e.severity;
this.lineNumber 	  = e.lineNumber;
this.message 		  = e.message;
this.fileName 		  = e.fileName;
this.execeptionClass  = e.exceptionClass;};},
toString: function() {
return this.type + ": " + this.message + "\n" +
(this.fileName ? this.fileName + ":" : "") + (this.lineNumber || "");}});
com.liquidpixels.UserAgent = {};
com.liquidpixels.UserAgent.get = function(uatest) {
var uaStr = uatest || navigator.userAgent;
var ieTridentMap = {
"7.0": "11",
"6.0": "10",
"5.0": "9",
"4.0": "8"};
var rtn = {
device:			"browser",
mobile:			false,
pixelRatio:		window.devicePixelRatio || 1,
uaStr:			uaStr};
var cap;
rtn.retina = rtn.pixelRatio > 1;
rtn.modern = false;
var testUAString = navigator.userAgent||navigator.vendor||window.opera
if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(testUAString)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(testUAString.substr(0,4))){
rtn.mobile = true;}
var bInfo=uaStr.match( /(Presto\/)*[0-9.]* Version\/([0-9.]*)( Safari\/| Mobile\/)*|(MSIE|Trident|Firefox|Android|Chrome)[\/ ]([0-9.]*)( Safari\/)?([0-9.])*( OPR\/)*([0-9.]*)*/ );
if(bInfo){
if(bInfo[8]){
rtn.browser=bInfo[8];
rtn.bVer=bInfo[9];}
else if(bInfo[5]){
rtn.browser=bInfo[4];
rtn.bVer=bInfo[5];
}else{
if(bInfo[1]){
rtn.bVer=bInfo[2];
rtn.browser=" OPR/";
}else{
rtn.bVer=bInfo[2];
rtn.browser=bInfo[3];
if(bInfo[3]==" Mobile/"||bInfo[3]==" Safari/"){
rtn.browser="Safari";}}}
var bVerArray = rtn.bVer.split('.');
rtn.bVerMajor = bVerArray[0];
rtn.bVerMinor = bVerArray[1];
rtn.bVerPatch = bVerArray.slice(2,bVerArray.length).join('.');}
rtn.touch = (!!('ontouchstart' in window) || (navigator.msMaxTouchPoints > 0));
rtn.canvas = (!!document.createElement('canvas').getContext);
if(uaStr.match(/android/i)) {
var ver = uaStr.match(/android\s([0-9.]+)/i);
if (ver){
rtn.deviceVer = ver[1];}
rtn.device  =  "Android";
rtn.os = "Android";
rtn.android = true;
rtn.mobile = true;
}else if(uaStr.match(/iphone/i) ) {
rtn.device  =  "iPhone";
rtn.os = "iOS";
rtn.ios = true;
rtn.mobile = true;
} else if(uaStr.match(/ipad/i)) {
rtn.device  =  "iPad";
rtn.os = "iOS";
rtn.ios = true;
rtn.mobile = true;
} else if(uaStr.match(/ipod/i)) {
rtn.device  =  "iPod";
rtn.os = "iOS";
rtn.ios = true;
rtn.mobile = true;
} else if(uaStr.match(/blackberry|bb10|rim/i)) {
rtn.device  =  "BlackBerry";
rtn.os = "Blackberry";
rtn.blackberry = true;
rtn.mobile = true;
} else if (uaStr.match(/windows\sphone/i)){
rtn.device  =  "Windows Phone";
rtn.os = "Windows Phone";
rtn.windowsPhone = true;
rtn.mobile = true;}
if (Math.max(window.innerHeight, window.innerWidth) >= 768 && rtn.mobile){
rtn.tablet = true;}
if( (cap = uaStr.match(/MSIE\s*([0-9.]+)/)) ) {
var v = cap[1];
rtn.ie = true;
rtn.ver = v;
rtn.device  = "browser";
rtn.agent   =  "IE" + Number(v);
rtn.engine = rtn.agent;
rtn.bVer = rtn.ver;
rtn.modern = parseInt(rtn.ver) >= 10;
} else if( (cap = uaStr.match(/Trident\/([0-9.]*);/)) ) {    //New way to get modern IE
var v = cap[1];
rtn.ie = true;
rtn.ver = ieTridentMap[v];
rtn.device  = "browser";
rtn.agent   =  "IE" + Number(ieTridentMap[v]);
rtn.engine = rtn.agent;
rtn.modern = parseInt(rtn.ver) >= 10;
} else if( (cap = uaStr.match(/Edge\/(\S+)/)) ) {    //New way to get edge
var v = cap[1];
rtn.ie = true;
rtn.ver = v;
rtn.device  = "browser";
rtn.agent   =  "Edge"
rtn.engine = rtn.agent;
rtn.modern = true;
} else if( (cap = uaStr.match(/Firefox\/([0-9.]+)/)) ) {
rtn.firefox = true;
rtn.device  = "browser";
rtn.agent   = "Firefox";
rtn.ver		= cap[1];
rtn.engine =  'Gecko';
rtn.bVer = rtn.ver;
rtn.modern = parseInt(rtn.ver) >= 10;
if (uaStr.match(/tablet/i)){
rtn.mobile = true;}
} else if(uaStr.match(/Opera/)) {
rtn.opera = true;
rtn.device  = "browser";
rtn.agent   =  "Opera";
rtn.engine  = rtn.agent;
}else if( (cap = uaStr.match(/Apple\s?WebKit\/([0-9.]+)/))) {
rtn.engine  =  "AppleWebKit";
rtn.webkit = true;
rtn.ver		= cap[1];
rtn.agent   =  "AppleWebKit";
if(uaStr.match(/opr/i)) {
rtn.opera = true;
rtn.agent   =  "Opera";
rtn.modern = true;
} else if(uaStr.match(/(chrome|crios)/i)) {
rtn.chrome = true;
rtn.agent   =  "Chrome";
rtn.modern = true;
} else if (uaStr.match(/safari/i) && !rtn.android && !rtn.blackberry && !rtn.windowsPhone) {
rtn.safari = true;
rtn.agent = "Safari"
rtn.modern = parseInt(rtn.ver) >= 535;
} else{
rtn.modern = parseInt(rtn.ver) >= 535;}}
var platform = navigator.platform;
if (platform){
if (platform.match(/Win/)){
rtn.os = "Windows";
}else if (platform.match(/Mac/)){
rtn.os = "Mac";
}else if (platform.match(/iPhone/) || platform.match(/iPad/)){
rtn.os = "iOS";
rtn.ios = true;
rtn.mobile = true;
rtn.touch = true;
}else if (uaStr.match(/Android/)){
rtn.os = "Android";
rtn.mobile = true;
rtn.touch = true;
}else if (platform.match(/Linux/)){
rtn.os = "Linux";}}
var browser = rtn.browser;
var version = rtn.bVerMajor;
rtn.sad_browser=true;
if(browser){
switch(browser){
case "MSIE":
if(version>=8){
rtn.sad_browser=false;}
break;
case "Firefox":
if(version>=40){
rtn.sad_browser=false;}
break;
case " OPR/":
if(version>=18||version==12){
rtn.sad_browser=false;}
break;
case "Android":
if(version>=4){
rtn.sad_browser=false;
}else if(version==2&&rtn.bVerMinor==3){
rtn.sad_browser=false;}
break;
case"Safari":
if(version>=7){
rtn.sad_browser=false;}
break;
case "Chrome":
rtn.sad_browser=false;
break;}}
if(rtn.agent=="Edge"){rtn.sad_browser=false;}
var versionArray = $DEF(rtn.ver) ? rtn.ver.split('.') : [];
rtn.verMajor = versionArray.length > 0 ? parseInt(versionArray[0]) : 0;
rtn.verMinor = versionArray.length > 1 ? parseInt(versionArray[1]) : 0;
rtn.verPatch = versionArray.length > 2 ? parseInt(versionArray[2]) : 0;
$DEF(rtn.ie) ? rtn.IE = rtn.ie : 0;
$DEF(rtn.firefox) ? rtn.FF = rtn.firefox : 0;
$DEF(rtn.opera) ? rtn.Opera = rtn.opera : 0;
$DEF(rtn.safari) ? rtn.Safari = rtn.safari : 0;
if (0){
var text = "";
$H(rtn).each(function(pair){
text += pair.key + ": " + pair.value + "\n";
console.debug(pair.key + ": " + pair.value);
}.bind(this));
alert(text);}
return rtn;};
var $UAQ = com.liquidpixels.UserAgent.get;
Object.extend(Effect.Transitions, (function() {
function reverse(eq, t)
{
return 1 - eq(1 - t);}
function easeInToEaseInOut(easeIn, t)
{
t = 2 * t;
return 0.5 * (t < 1 ? easeIn(t) : 2 - easeIn(2 - t));}
function easeOutToEaseInOut(easeOut, t)
{
t = 2 * t;
return 0.5 * (t < 1 ? 1 - easeOut(1 - t) : 1 + easeOut(t - 1));}
function easeInOutPairToEaseInOut(easeIn, easeOut, t)
{
t = 2 * t;
return 0.5 * (t < 1 ? easeIn(t) : 1 + easeOut(t - 1));}
function functionSet(easeIn, easeOut, easeInOut)
{
return {
easeIn   : easeIn,
easeOut  : easeOut,
easeInOut: easeInOut};}
function functionSetFromEaseIn(easeIn)
{
return {
easeIn   : easeIn,
easeOut  : reverse.curry(easeIn),
easeInOut: easeInToEaseInOut.curry(easeIn)};}
function functionSetFromEaseOut(easeOut)
{
return {
easeIn   : reverse.curry(easeOut),
easeOut  : easeOut,
easeInOut: easeOutToEaseInOut.curry(easeOut)};}
function functionSetFromEaseInOutPair(easeIn, easeOut)
{
return {
easeIn   : easeIn,
easeOut  : easeOut,
easeInOut: easeInOutPairToEaseInOut.curry(easeIn, easeOut)};}
function customizableFunctionSetFromEaseIn()
{
var args = $A(arguments);
var easeIn = args.shift();
function customEaseIn()
{
var args = [0].concat($A(arguments));
return function(t)
{
args[0] = t;
return easeIn.apply(this, args);};}
function customEaseOut()
{
return reverse.curry(customEaseIn.apply(this, arguments));}
function customEaseInOut()
{
return easeInToEaseInOut.curry(customEaseIn.apply(this, arguments));}
var myEaseIn = customEaseIn.apply(this, args);
myEaseIn.custom = customEaseIn;
var myEaseOut = reverse.curry(myEaseIn);
myEaseOut.custom = customEaseOut;
var myEaseInOut = easeInToEaseInOut.curry(myEaseIn);
myEaseInOut.custom = customEaseInOut;
return {
easeIn   : myEaseIn,
easeOut  : myEaseOut,
easeInOut: myEaseInOut};}
var HALF_PI = Math.PI / 2;
var TWO_PI  = 2 * Math.PI;
function Quad_easeIn(t)
{
return t * t;}
function Cubic_easeIn(t)
{
return t * t * t;}
function Quart_easeIn(t)
{
return t * t * t * t;}
function Quint_easeIn(t)
{
return t * t * t * t * t;}
function Pow_easeIn(t, p)
{
return Math.pow(t, p);}
function Back_easeIn(t, s)
{
return t * t * ((s + 1) * t - s);}
function Bounce_easeOut(t)
{
if (t < (1 / 2.75))
return 7.5625 * t * t;
if (t < (2 / 2.75))
return 7.5625 * (t-= (1.5 / 2.75)) * t + 0.75;
if (t < (2.5 / 2.75))
return 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;
return 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;}
function Circ_easeIn(t)
{
return -1 * (Math.sqrt(1 - t * t) - 1);}
function Circ_easeOut(t)
{
t -= 1;
return Math.sqrt(1 - t * t);}
function Elastic_easeIn(t, a, p)
{
if (t == 0) return 0;
if (t == 1) return 1;
if (a < 1)
{
a = 1;
var s = p / 4;}
else
{
var s = p / TWO_PI * Math.asin(1 / a);}
return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TWO_PI / p));}
function Expo_easeIn(t)
{
return (t == 0) ? 0 : Math.pow(2, 10 * (t - 1));}
function Expo_easeOut(t)
{
return (t == 1) ? 1 : 1 - Math.pow(2, -10 * t);}
function Sine_easeIn(t)
{
return Math.cos(t * HALF_PI) + 1;}
function Sine_easeOut(t)
{
return Math.sin(t * HALF_PI);}
function Sine_easeInOut(t)
{
return -0.5 * (Math.cos(Math.PI * t) - 1);}
var transitionHash = new Hash({
Sine   : functionSet(Sine_easeIn, Sine_easeOut, Sine_easeInOut),
Quad   : functionSetFromEaseIn(Quad_easeIn),
Cubic  : functionSetFromEaseIn(Cubic_easeIn),
Quart  : functionSetFromEaseIn(Quart_easeIn),
Quint  : functionSetFromEaseIn(Quint_easeIn),
Pow    : customizableFunctionSetFromEaseIn(Pow_easeIn, 2), // Defaults to Quad
Back   : customizableFunctionSetFromEaseIn(Back_easeIn, 1.70158),
Bounce : functionSetFromEaseOut(Bounce_easeOut),
Circ   : functionSetFromEaseInOutPair(Circ_easeIn, Circ_easeOut),
Elastic: customizableFunctionSetFromEaseIn(Elastic_easeIn, 1, 0.3),
Expo   : functionSetFromEaseInOutPair(Expo_easeIn, Expo_easeOut)});
var easyNameHash = new Hash();
transitionHash.each(function(pair){
easyNameHash.set("easeIn" + pair.key, pair.value.easeIn);
easyNameHash.set("easeOut" + pair.key, pair.value.easeOut);
easyNameHash.set("easeInOut" + pair.key, pair.value.easeInOut);
}.bind(this));
var returnHash = transitionHash.toObject();
Object.extend(returnHash, easyNameHash.toObject());
return returnHash;
})());
com.liquidpixels.utilities.DeepMerge.object = function(destination, source, options) {
options = options || {};
var clone = {};
if(options.extendDestination) {
clone = destination;
} else {
for (var property in destination){
clone[property] = destination[property];}}
for (var property in source){
clone[property] = com.liquidpixels.utilities.DeepMerge.value(destination[property], source[property], options);}
return clone;};
com.liquidpixels.utilities.DeepMerge.array = function(destination, source, options) {
options = options || {};
var clone = [];
if(options.extendDestination) {
clone = destination;
} else {
for(var i=0; i<destination.length; i++) {
clone[i] = destination[i];}}
for(var i=0; i<source.length; i++) {
clone[i] = com.liquidpixels.utilities.DeepMerge.value(destination[i], source[i], options);}
return clone;};
com.liquidpixels.utilities.DeepMerge.extend = function(destination, source, options) {
options = options || {};
options.extendDestination = true;
com.liquidpixels.utilities.DeepMerge.object(destination, source, options);};
com.liquidpixels.utilities.DeepMerge.clone = function(source, options) {
options = options || {};
options.extendDestination = false;
return com.liquidpixels.utilities.DeepMerge.object({}, source, options);};
com.liquidpixels.utilities.DeepMerge.value = function(destination, source, options) {
var type = com.liquidpixels.utilities.typeOf;
if(type(destination) == "Array" && type(source) == "Array" && !options.overrideArrays) {
return com.liquidpixels.utilities.DeepMerge.array(destination, source, options);
} else if (source && type(source) == "Array"){
return com.liquidpixels.utilities.DeepMerge.array([], source, options);
} else if(destination && type(destination) == "Object" && source && type(source) == "Object") {
return com.liquidpixels.utilities.DeepMerge.object(destination, source, options);
} else if (options.extendDestination){ //We do this so we can still keep object pointers for extend.
return source;
}else{
if(source && type(source) == "Object") {
return com.liquidpixels.utilities.DeepMerge.object({}, source, options);
} else {
return source;}}};
com.liquidpixels.liquifire.LiquiFire = Class.create( {
server:			undefined,
uri:			undefined,
port:			undefined,
valid:			undefined,
revision: "$Revision: 7156 $",
Version: function() {
return revision.substr(11).substr(0, -2);},
initialize: function(server, uri, port, options) {
this.options = {};
this.setDefaults();
Object.extend(this.options, options);
this.setServer(server);
this.setURI(uri);
this.setPort(port);},
setDefaults: function(){
Object.extend(this.options, {
alwaysUseSSL: false,
neverUseSSL: false});},
getServer: function() {
return this.server || "";},
setServer: function(s) {
this.server = s || "";},
getURI: function() {
return this.uri || "";},
setURI: function(u) {
this.uri = u || "";},
getPort: function() {
return this.port || "";},
setPort: function(p) {
var pstr = p + "";
pstr === '80' ? this.port = "" : this.port = p;},
getZapDir: function() {
return this.httpProtocalCheck() + '//' + this.getServer() + this.getPortAsString() + '/zap';
},
validate: function() {
if(this.server && this.uri) {
this.valid = true;
} else {
this.valid = false;}},
isValid: function() {
this.validate();
return this.valid;},
getPortAsString: function() {
if(this.port && this.port != 80) {
return ":" + this.port;
} else {
return "";}},
escape: function(v) {
v = v.replace(/\'/g, 'U2019');
v = v.replace(/&/g, 'U0026amp;');
v = v.replace(/[\-][\-]/g, 'U2014');
v = v.replace(/\(/g, 'U0026lp;');
v = v.replace(/\)/g, 'U0026rp;');
return v;},
toURL: function() {
return this.httpProtocalCheck() + '//' + this.getServer() + this.getPortAsString() +
'/' + this.getURI();},
asURL: function() { return this.toURL(); },
toString: function() {
var s = "[LiquiFire Connection] ";
if(this.isValid()) {
s += this.getServer();
s += this.getPortAsString();
s += "/" + this.getURI();
} else {
s += "(invalid connection!)";}
return s;},
toQueryString: function() {
var port = this.getPort();
var str = "server=" + this.getServer() +
"&uri=" + this.getURI() +
(port ? "&port=" + port : "");
return str;},
httpProtocalCheck: function(){
var protocal = window.location.protocol;
if (this.options.alwaysUseSSL){
protocal = "https:";}
if (this.options.neverUseSSL){
protocal = "http:"}
return protocal;}});
com.liquidpixels.liquifire.Command = Class.create( {
revision: "$Revision: 6649 $",
Version: function() {
return revision.substr(11).substr(0, -2);},
name:		undefined,
atts:		undefined,
keys:		undefined,
options:	undefined,
initialize: function(name, atts, options) {
this.name = name;
this.atts = {};
this.keys = new Array();
if( !this.options ) { this.options = {sortAttribs: true}; }
Object.extend(this.options, options);
if(atts) {
Object.extend(this.atts, atts);
$H(this.atts).each(function(pair) {
this.keys.push(pair.key);
}.bind(this));
if (this.options.sortAttribs) {
this.keys.sort();}}},
clone: function() {
var to = new com.liquidpixels.liquifire.Command(this.name, this.atts);
return to;},
asString: function() {
var i;
var c = "" + this.name + '=';
var atts = this.atts;
var katts = this.keys;
var len = katts.length;
for(var i=0; i < len; ++i ) {
var key = katts[i];
c +=  key + '[' + atts[key] + '],';};
return c.substring(0, c.length - 1);},
asHtml: function() {
var c = '<span class="lfcommand">';
var atts = this.atts;
var katts = this.keys;
var len = katts.length;
if(this.name.match(/^#/)) {
c += '<span class="comment">' + this.name;
c += '=';
for(var i=0; i < len; ++i ) {
var key = katts[i];
c +=  key + '[' + atts[key] + '],';};
c = c.substring(0, c.length);
c = c.replace(/=$/, "");
} else {
c += '<span class="name">' + this.name + '</span>';
c += '<span class="op">=</span>';
for(var i=0; i < len; ++i ) {
var key = katts[i];
var value = String(atts[key]);
if(value) {
value = value.replace(/</g, "&lt;");
value = value.replace(/>/g, "&gt;");}
c += '<span class="argName">' + key + '</span>';
c += '<span class="op">[</span>';
c += '<span class="argValue">' + value + '</span>';
c += '<span class="op">],</span>';};
c = c.substring(0, c.length - 8);}
c += "</span></span>";
return c;},
get: function(key) {
return this.atts[key];},
getAtt: function(key) { return this.get(key); },
set: function(key, value) {
if(!$DEF(this.atts[key])) {
this.keys.push(key);
if (this.options.sortAttribs) {
this.keys.sort();}}
this.atts[key] = value;},
addAtt: function(key, value) { this.set(key, value); },
setAtt: function(key, value) { this.set(key, value); },
removeAtt: function(key) {
this.atts[key] = null;
this.keys = this.keys.without(key);},
getName: function() {
return this.name;},
setName: function(newName) {
this.name = newName;},
attributes: function(key) {
return this.atts;},
parse2: function(s) {
var state = 'name';
this.name = '';
this.atts = {};
var k = '';
var v = '';
var l = s.length;
for(var i=0; i<l; i++) {
var c = s.substring(i, i+1);
var c1 = s.substring(i+1, i+2);
switch(state) {
case 'name':
if(c == '=') {
state = 'key';
break;}
this.name += c;
break;
case 'key':
if(c == '[') {
state = 'val';
break;}
k += c;
break;
case 'val':
if( ((c == ']') && (c1 == ',')) || ((c == ']') && (c1 == '')) ) {
this.set(k, v);
state = 'haveatt';
break;}
v += c;
break;
case 'haveatt':
k = '';
v = '';
if(c == ',')
state = 'key';
break;}}},
parse: function(s) {
this.name = '';
this.atts = {};
var parts = s.split('=');
if(parts[0]) {
this.name = parts.shift();}
if(parts[0]) {
var args = parts.join('=').split('],');
var l = args.length;
for(var i = 0; i < l; i++) {
arg = args[i];
var argParts = arg.match(/^([^\[]*)(.*)/);
if(argParts) {
if(argParts[2].charAt(0) == '[') {
argParts[2] = argParts[2].substr(1);}
if(argParts[2].charAt(argParts[2].length - 1) == ']') {
argParts[2] = argParts[2].substr(0, argParts[2].length - 1);}
if (argParts[1]){
this.set(argParts[1], argParts[2]);}}}}},
sortKeys: function() {
this.keys.sort();}});
com.liquidpixels.liquifire.Chain = Class.create( {
revision: "$Revision: 5739 $",
Version: function() {
return revision.substr(11).substr(0, -2);},
lf:			undefined,
commands:	undefined,
initialize: function(server, uri, port, options) {
if(typeof(server) == 'object') {
this.setLiquiFire(server);
} else {
var lf = new com.liquidpixels.liquifire.LiquiFire(server, uri, port, options);
this.setLiquiFire(lf);}
this.commands = new Array();},
clone: function() {
var to = new com.liquidpixels.liquifire.Chain(this.lf);
$A(this.commands).each(function(o,i) {
to.commands[i] = o.clone();});
return to;},
shallowClone: function() {
var to = new com.liquidpixels.liquifire.Chain(this.lf);
Object.extend(to.commands, this.commands);
return to;},
cloneFromString: function() {
var to = new com.liquidpixels.liquifire.Chain(this.lf);
to.parse(this.asString());
return to;},
setLiquiFire: function(lfc) {
if(lfc.isValid()) { this.lf = lfc; }},
getLiquiFire: function() {
return this.lf;},
setServer: function(s) {
this.lf.setServer(s);},
getServer: function() {
if(this.lf) { return this.lf.getServer(); }
return "";},
setPort: function(n) {
if(this.lf) { this.lf.setPort(n); }},
getPort: function() {
if(this.lf) { return this.lf.getPort(); }
return "";},
setURI: function(u) {
if(this.lf) { this.lf.setURI(u); }},
getURI: function() {
if(this.lf) { return this.lf.getURI(); }
return "";},
addCommand: function(command, args) {
var cmd;
if(typeof(command) == "object") {
cmd = command;
} else {
cmd = new com.liquidpixels.liquifire.Command(command, args);}
var pos = this.commands.length;
this.commands.push(cmd);
return pos;},
addSink: function(args) {
this.addCommand("sink", args);},
insertCommand: function(position, command, args) {
var cmd, pos;
if(Object.isString(position)) {
pos = this.findCommand(position) || this.length();
} else {
pos = position;}
if(typeof(command) == "object") {
cmd = command;
} else {
cmd = new com.liquidpixels.liquifire.Command(command, args);}
if(!pos && pos != 0) {return null;}
this.commands.splice(pos, 0, cmd);
return pos;},
hasCommand: function(name, count) {
var pos = this.findCommand(name, count);
return ($DEF(pos) ? true : false);},
deleteCommand: function(pos) {
if($DEF(pos)) { this.commands.splice(pos, 1); }},
getCommand: function(pos) {
return this.commands[pos];},
getCommandByName: function(name, count) {
var pos = this.findCommand(name, count);
if($DEF(pos)) {
return this.getCommand(pos);
} else {
return null;}},
findCommand: function(name, count) {
var c = 0;
if(!count && count != 0) { count = -1 }
for(var i=0; i<this.commands.length; i++) {
if(this.commands[i].getName() == name) {
if(++c > count) {
return i;}}}
return null;},
getCommands: function() {
return this.commands;},
setCommand: function(pos, command, opts) {
var cmd;
if(typeof(command) == "object") {
cmd = command;
} else {
cmd = new com.liquidpixels.liquifire.Command(command, opts);}
this.commands[pos] = cmd;},
numCommands: function() {
return this.commands.length;},
length: function() {
return this.commands.length;},
asString: function() {
var i;
var chain = '';
for(i=0; i<this.commands.length; i++) {
chain += this.commands[i].asString() + '&';}
return chain.substring(0, chain.length -1);},
asURL: function() {
var chain = this.asURLVariable();
if(this.lf && this.lf.isValid()) {
return this.lf.toURL() + '?' + chain;
} else {
return "";}},
asURLVariable: function() {
var s = this.asString();
var chain = encodeURI(s);
chain = chain.replace(/\+/g,"%2B");
chain = chain.replace(/#/g,"%23");
return chain;},
parse: function(s) {
this.commands = new Array();
this._parseString(s);},
parseAdd: function(s) {
this._parseString(s);},
_parseString: function(s) {
var cStrings = s.split('&');
for(var i = 0; i < cStrings.length; i++) {
var c = new com.liquidpixels.liquifire.Command();
c.parse(cStrings[i]);
this.addCommand(c);}},
applyTransform: function(t) {
t.applyToChain(this);},
toString: function() { return "com.liquidpixels.liquifire.Chain" }});
com.liquidpixels.event.Event = Class.create( {
type:			'Event',		// static, final
target:			undefined,		// Eventee
UAevent:		undefined,		// Browser's Event object
options:		undefined,
initialize: function(options) {
this.options = {};
Object.extend(this.options, options);
if(this.options.target) { this.target = this.options.target }
if(this.options.UAevent) { this.UAevent = this.options.UAevent }},
typeize: function(type) { this.type = this.type + "." + type },
toString: function() { return this.type; }});
com.liquidpixels.event.TypedEvent = Class.create(com.liquidpixels.event.Event, {
initialize: function($super, type, options) {
$super(options);
this.typeize(type);}});


com.liquidpixels.zap.Simple = Class.create( {
getView: function(){return this.frame.engine.getView()},
loadImage: function(source) { this.frame.engine.loadImage(source) },
loadChain: function(source, options) { this.frame.engine.loadChain(source, options) },
dimensions: function() {  this.frame.engine.dimensions() },
home: function() { this.frame.engine.home() },
zoomToPoint: function(scale, x, y) { this.frame.engine.zoomToPoint(scale, x, y) },
panToPoint: function(x, y) { this.frame.engine.panToPoint(x, y) },
panByAmount: function(panX, panY) { this.frame.engine.panByAmount(panX, panY) },
panByPercent: function(pctX, pctY) { this.frame.engine.panByPercent(pctX, pctY) },
zoomToRegion: function(x1, y1, x2, y2) { this.frame.engine.zoomToRegion(x1, y1, x2, y2) },
setChainMetadata: function(params, update){ this.frame.engine.setChainMetadata(params, update)},
getChainMetadata: function(){ return this.frame.engine.getChainMetadata()},
zoomIn: function(amt)	{ this.zoomToPoint(amt || 2) },
zoomOut: function(amt)	{ this.zoomToPoint(amt || .5) },
panDown: function(amt)	{ this.panByPercent(0, (amt || .20) * -1) },
panUp: function(amt)	{ this.panByPercent(0, (amt || .20)) },
panRight: function(amt)	{ this.panByPercent((amt || .20) * -1) },
panLeft: function(amt)	{ this.panByPercent((amt || .20))},
zoomReset: function() { this.frame.engine.zoomReset() },
collectionViewport: function(source, x1, y1, x2, y2) { this.frame.engine.collectionViewport(source, x1, y1, x2, y2) },
whoAmI: function(){
return "zoom";},
isReady: function(){
if (this.frame && this.frame.engine){
return this.frame.engine.isReady();
}else{
return false;}},
viewPane:			undefined,
frame:			undefined,
options:			undefined,
busy:				undefined,
initialize: function(parent, options) {
this.options = {};
this.setDefaults();
Object.extend(this.options, options);
if(typeof(parent) === "string") {
this.viewPane = new com.liquidpixels.wui.Pane(this, {
incID:			parent});
} else if(typeof(parent) === "object") {
this.viewPane = parent;
} else {
this.viewPane = new com.liquidpixels.wui.Pane(this, { });}
this.busy = true;
this.buildFrame();},
setDefaults: function() {
Object.extend(this.options, {
width:			400,
height:			400,
displayMode:	'fill',
identity: this.whoAmI()});},
buildFrame: function() {
this.options.engineType = (this.options.stitched ?
'com.liquidpixels.zap.stitched.SimpleEngine' :
'com.liquidpixels.zap.tiled.SimpleEngine'
);
this.options.cssr = "com.liquidpixels.zap.SimpleEngine.cssr";
this.frame = new com.liquidpixels.zap.Frame(this, this.options);
this.frame.addEventListener("loaded", this.prepareFrame.bind(this));
this.viewPane.appendChild(this.frame);},
prepareFrame: function() {
this.frame.element.observe("touchstart", function (e) {
Event.stop(e);});
this.frame.element.observe("touchmove", function (e) {
Event.stop(e);});
this.frame.element.observe("touchend", function (e) {
Event.stop(e);});
this.frame.addEventListener(this.frame.events.started, this.handleFrameLoaded.bind(this));
this.frame.addEventListener(this.frame.events.ready, this.handleFrameReady.bind(this));
this.frame.addEventListener(this.frame.events.loaded, this.handleFrameReady.bind(this));
this.frame.addEventListener(this.frame.events.waiting, this.handleFrameReady.bind(this));
this.frame.addEventListener(this.frame.events.error, this.handleFrameError.bind(this));
this.frame.addEventListener(this.frame.events.blur, this.blurViewer.bind(this));
this.frame.startIframe();},
blurViewer: function(){
window.focus();},
handleFrameLoaded: function(e) {
this.handleFrameReady(e);},
handleFrameReady: function(e) {
this.busy = false;
if(this.options.handleZapEvent) {
this.options.handleZapEvent(e.response, e.data);}
else if(this.options.handleZoomEvent) {
this.options.handleZoomEvent(e.response, e.data);}
else if(this.options.handleEvent) {
this.options.handleEvent(e.response, e.data);}},
handleFrameError: function(e) {
if(this.options.handleZapError) {
this.options.handleZapError(e.response, e.data);}
if(this.options.handleZoomEvent) {
this.options.handleZoomEvent(e.response, e.data);}
else if(this.options.handleEvent) {
this.options.handleEvent(e.response, e.data);}},
refresh: function(options){
var info = {
exisitingId: this.viewPane.id,
existingChain: this.frame.engine.zapManager.options.chain,
existingImage: this.frame.engine.zapManager.options.image,
exisitingViewport: this.frame.engine.zapManager.options.collectionViewport,
exisitingOptions: Object.deepClone(this.options)}
this.frame.DESTROY();
this.frame = null;
this.viewPane.destroyChildren();
this.viewPane = null;
var newOptions = Object.deepClone(this.options);
Object.extend(newOptions, options);
this.initialize(info.exisitingId, newOptions);
setTimeout(function(e){
this._refresh(newOptions, info);
}.bind(this),1);},
_refresh: function(options, info){
if (this.isReady()){
if (info.existingChain && !info.exisitingOptions.chain){
if (info.exisitingViewport){
this.collectionViewport(info.existingChain, info.exisitingViewport.x1, info.exisitingViewport.y1, info.exisitingViewport.x2, info.exisitingViewport.y2);
}else{
this.loadChain(info.existingChain);}
}else if (info.existingImage && !info.exisitingOptions.image){
this.loadImage(info.existingImage);}
}else{
setTimeout(function(){
this._refresh(options, info);
}.bind(this),250);}},
DESTROY: function() {
this.frame.DESTROY();
this.frame = null;
this.viewPane.destroyChildren();
this.viewPane = null;
this.options = null;},
toString: function() { return "com.liquidpixels.zap.Simple"}});
com.liquidpixels.zap.ZapManager = Class.create({
options: undefined, // {}
pane: undefined, // isa wui.Pane
viewPort: undefined, // isa wui.Pane
overlay: undefined, // isa Pane::Overlayable
waitImg: undefined,
layers: undefined, // Hash of layers
currentLayer: undefined, // current view layer
prevLayer: undefined, // previous layer (could be visible...)
imgOrigW: undefined,
imgOrigH: undefined,
imgLFInfo: undefined,
imgCurrW: undefined,
imgCurrH: undefined,
curScale: undefined,
homeScale: undefined,
chain: undefined,
showControls: undefined,
state: undefined,
initialize: function (parent, options) {
this.parent = parent;
this.options = {};
this.layers = new Hash();
com.liquidpixels.event.EventDispatcher.makeDispatcher(this);
this.setDefaults();
Object.extend(this.options, options);
var viewerText = "Interactive Zoom Viewer: ";
if (this.options.description) {
this.options.description += ". ";
} else {
this.options.description = "";}
this.ariaText = {
start: viewerText + this.options.description + "Keyboard navigation: zero to return home, minus to zoom out, equal to zoom in, arrow keys to pan image.",
zoomIn: "Zoom in.",
zoomOut: "Zoom out.",
zoom: "Zoom image.",
panLeft: "Pan image left.",
panRight: "Pan image right.",
panUp: "Pan image up.",
panDown: "Pan image down.",
pan: "Pan image.",
home: "reset to default view.",
loadImage: "new image loaded.",
exit: viewerText + "exit.",};
if (this.options.keyboardControl) {
this.keyPress = new com.liquidpixels.event.KeyPress(this, {});}
if (this.options.zoomFactor <= 0) {
this.options.zoomFactor = 1.5;}
this.userAgent = Application.get("uaq");
if (this.userAgent.device === "Android" && this.userAgent.deviceVer.charAt(0) < 4) {
this.options.touchClick = true;}
if (this.options.pane) {
this.pane = this.options.pane;}
this.fireStartedEvent();
this.build();},
setDefaults: function () {
Object.extend(this.options, {
initScale: 1.0,
displayMode: "fill",
zoomFactor: 1.5,
minScale: 0.5,
maxScale: 1.0,
touchClick: false,
homeIcon: true,
touchScrollPassthrough: false,
keyboardControl: true,
description: "",
easingFunction: "easeOutCubic",
chainMetadata: {},});
this.viewerName = "Zoom";
this.accounting = {
seed: undefined,
version: "1.22",};},
build: function () {
this.buildViewPort();
this.buildLayerPane();
this.buildWaitImg();
this.buildLFInfo();
this.buildSource();
this.buildWatermark();
this.buildOverlay();
this.buildHomeIcon();
this.buildStatusText();},
buildLFInfo: function () {
this.lfQuery = new com.liquidpixels.query.LFQuery({
format: "json2",});},
buildSource: function () {
this.setState("busy");
this.getLFImgInfo();},
buildHomeIcon: function () {
if (!this.options.homeIcon) {
return;}
if (this.homeIcon) {
this.homeIcon.hide();
return;}
var baseDir = Application.get("zap.baseDir");
this.homeIcon = new com.liquidpixels.wui.Pane(this, {
id: "homeIcon",
cssClass: "homeIcon",});
var button = new com.liquidpixels.wui.Button(this, {
tagType: "div",
cssClass: "homeIcon",
src: baseDir + "images/home.png",
accessibility: true,
attributes: {
"aria-label": "reset interactive viewer button",
alt: "Home Button",},
cssStyle: {
zIndex: 10,},
click: this.goHome.bind(this),});
this.homeIcon.appendChild(button);
this.viewPort.appendChild(this.homeIcon);
this.homeIcon.hide();},
goHome: function (e) {
if (this.state != "tweening") {
if (this.parent.collectionHome) {
this.zoomToRegion(this.parent.collectionHome);
} else {
this.zoomToPoint(
{
x: this.imgOrigW / 2,
y: this.imgOrigH / 2,
scale: this.homeScale,},
{
absolute: true,}
);}
this.homeIcon.fade({
duration: this.tweenDuration,});
this.setStatusText("home");}},
checkHome: function (location, scale) {
if (this.homeIcon === undefined) {
return;}
if (location == "start") {
if (this.homeScale == this.options.minScale) {
if (scale != this.homeScale) {
this.homeIcon.appear({
duration: this.tweenDuration,});}
} else if (!this.homeIcon.visible) {
this.homeIcon.appear({
duration: this.tweenDuration,});}
} else if (location == "end") {
if (this.homeScale == this.options.minScale && this.curScale == this.homeScale) {
if (this.homeIcon.visible) {
this.homeIcon.fade({
duration: this.tweenDuration,});}}}},
getLFImgInfo: function () {
var lf = this.options.lf;
var infoChain;
if (this.options.chain) {
var chType = typeof this.options.chain;
if (chType == "object") {
var str = unescape(this.options.chain.asURLVariable());
infoChain = new com.liquidpixels.liquifire.Chain(lf);
infoChain.parse(str);
} else if (chType == "string") {
var str = unescape(this.options.chain);
infoChain = new com.liquidpixels.liquifire.Chain(lf);
infoChain.parse(str);
} else {
this.fireErrorEvent({
message: "Bad chain type",});
return;}
} else if (this.options.image) {
var imgType = typeof this.options.image;
if (imgType == "object") {
infoChain = this.options.image.srcToChain(lf);
} else if (imgType == "string") {
var str = "source=url[" + unescape(this.options.image) + "]&sink";
infoChain = new com.liquidpixels.liquifire.Chain(lf);
infoChain.parse(str);}
if (!infoChain) {
this.fireErrorEvent({
message: "Bad image type",});
return;}
} else {
_console.debug("No Image or Chain set: stopping gracefully and waiting patiently.");
this.fireWaitingEvent({
message: "No image or chain loaded. Viewer is waiting",});
return;}
this.showPixelLoader({
noWait: true,});
if ($DEF(this.options.chainMetadata)) {
$H(this.options.chainMetadata).each(
function (pair, i) {
infoChain.insertCommand(i, "set", {
key: pair.key,
value: pair.value,});
}.bind(this)
);}
this.chain = infoChain.clone();
if (!this.chain.hasCommand("sink")) {
this.chain.addSink();}
infoChain.insertCommand("sink", "zap", {
ver: "2.0",
viewer: this.viewerName,
mode: "info",});
var currentTime = new Date().getTime();
infoChain.insertCommand("sink", "set", {
cacheKill: currentTime,});
this.lfQuery.addEventListener("WUI.Event.LFQuery.Loaded", this.onLFQueryLoaded, this);
this.lfQueryTime = Date.now();
clearTimeout(this.lfQueryTimeout);
this.lfQueryTimeout = setTimeout(
function (e) {
this.state = "apiReady";
}.bind(this),
5000
);
this.lfQuery.chainToGlobal(infoChain);},
onLFQueryLoaded: function (e) {
if (Date.now() - this.lfQueryTime < 5000) {
clearTimeout(this.lfQueryTimeout);}
var imgError = this.lfQuery.hasError();
if (imgError) {
this.fireErrorEvent({
message: "LiquiFire Error",});
if (this.options.displayError) {
var src = this.options.errorImage || this.chain;
var img = new com.liquidpixels.wui.Image(this, {
src: src,});
this.viewPort.appendChild(img);}
this.hidePixelLoader();
} else {
this.imgOrigH = Math.round(this.lfQuery.getValue("image", "height") * 1);
this.imgOrigW = Math.round(this.lfQuery.getValue("image", "width") * 1);
this.accounting.seed = this.lfQuery.getSeed();
if (this.accounting.seed) {
this.accounting.version = "2.0";}
this.sendAccounting();
this.startZap();}},
sendAccounting: function () {
var chain = this.chain.clone();
var vals = {
height: 100,
width: 100,
vsize: 100,
x: 0,
y: 0,};
Object.extend(vals, this.accounting.seed ? { seed: this.accounting.seed } : {});
chain.insertCommand("sink", "viewport", vals);
chain.insertCommand("sink", "set", {
viewer: "Data_" + this.viewerName,});
var image = new com.liquidpixels.wui.Image(this, {
src: chain,});
image.addEventListener("WUI.Event.Image.Loaded", this.accountingImageHandler.bind(this));
image.addEventListener("WUI.Event.Image.Error", this.accountingImageHandler.bind(this));},
accountingImageHandler: function (e) {
if (e && e.target) {
e.target.DESTROY();}},
onLayerLoaded: function (e) {
this.fireLoadedEvent();},
hidePrevLayers: function (opts) {
this.layers.each(
function (pair) {
if (opts && opts.showPrevLayer) {
if (pair.value.id != this.currentLayer.id && pair.value.id != this.prevLayer.id) {
pair.value.hide();}
} else {
if (pair.value.id != this.currentLayer.id) {
pair.value.hide();}}
}.bind(this)
);},
showPrevLayers: function () {
this.layers.each(
function (pair) {
if (pair.value.id !== this.currentLayer.id) {
pair.value.show();}
}.bind(this)
);},
buildViewPort: function () {
this.viewPort = new com.liquidpixels.wui.Pane(this, {
cssClass: "viewport",
id: "viewPort",
attributes: {
role: "application",
tabindex: 1,},});
this.viewPort.setSize(this.options.vpWidth, this.options.vpHeight);
this.pane.appendChild(this.viewPort);},
buildStatusText: function () {
var style = {
color: "rgba(0,0,0,0)",
position: "absolute",
top: "0",
width: "100%",
left: "0",
height: "100%",
overflow: "hidden",};
if (this.userAgent.ie && this.userAgent.verMajor < 9) {
delete style.color;
style.filter = "alpha(opacity=0)";}
this.statusText = new com.liquidpixels.wui.Pane(this, {
cssClass: "statusText",
id: "statusText",
cssStyle: style,
attributes: {
"aria-live": "assertive",},});
this.viewPort.insertChild(this.statusText, 0);
this.setStatusText("start");},
setStatusText: function (action) {
this.statusText.destroyChildren();
if (action) {
var text = new com.liquidpixels.wui.Label(this, {
text: this.ariaText[action],
cssStyle: {
width: "100%",
height: "100%",},});
this.statusText.appendChild(text);}},
buildWatermark: function () {
this.waterMark = new com.liquidpixels.wui.Pane(this, {
cssClass: "watermark",
id: "watermark",});
this.waterMark.setSize(this.options.vpWidth, this.options.vpHeight);},
buildWaitImg: function () {
if (this.userAgent.modern) {
this.waitImg = new com.liquidpixels.wui.loader.Pixels(this, {});
this.waitImg.setStyle({
top: this.options.vpHeight / 2 - 10 + "px",
left: this.options.vpWidth / 2 - 60 + "px",});
} else {
var lf = this.options.lf;
var baseDir = Application.get("zap.baseDir");
this.waitImg = new com.liquidpixels.wui.Pane(this, {
id: "loader",});
var img = new com.liquidpixels.wui.Image(this, {
id: "waitimg",
src: baseDir + "images/Wait.gif",});
this.waitImg.appendChild(img);
this.waitImg.setStyle({
top: this.options.vpHeight / 2 - 25 + "px",
left: this.options.vpWidth / 2 - 50 + "px",});}
this.viewPort.appendChild(this.waitImg);
this.waitImg.hide();},
showPixelLoader: function (options) {
clearTimeout(this.waitImgTimer);
if (!this.waitImg.isVisible()) {
if (options && options.noWait) {
this.waitImg.appear({
duration: 0.2,});
} else {
this.waitImgTimer = setTimeout(
function (e) {
this.waitImg.appear({
duration: 0.2,});
}.bind(this),
2000
);}}},
hidePixelLoader: function (options) {
clearTimeout(this.waitImgTimer);
if (this.waitImg.isVisible()) {
this.waitImg.fade({
duration: 0.2,});}},
doesShowControls: function () {
return false;},
buildOverlay: function () {
this.overlay = new com.liquidpixels.wui.Pane(this, {
cssClass: "overlay",
id: "overlay",});
this.viewPort.appendChild(this.overlay);},
buildLayerPane: function () {
this.layerPane = new com.liquidpixels.wui.Pane(this, {
cssClass: "layerPane",
id: "layerPane",});
this.viewPort.appendChild(this.layerPane);},
prepareImage: function () {
var dH = this.imgOrigH - this.options.vpHeight;
var dW = this.imgOrigW - this.options.vpWidth;
this.options.minScale = Math.min(this.options.vpWidth / this.imgOrigW, this.options.vpHeight / this.imgOrigH);
if (this.options.displayMode === "full") {
this.imgCurrW = this.imgOrigW;
this.imgCurrH = this.imgOrigH;
this.curScale = this.options.maxScale;
} else if (this.options.displayMode === "fit") {
this.curScale = this.options.minScale;
if (dH <= dW) {
this.imgCurrW = this.options.vpWidth;
this.imgCurrH = Math.round(this.imgOrigH * this.curScale);
} else {
this.imgCurrH = this.options.vpHeight;
this.imgCurrW = Math.round(this.imgOrigW * this.curScale);}
} else if (this.options.displayMode === "fill") {
if (dH >= dW) {
this.imgCurrW = this.options.vpWidth;
this.curScale = this.options.vpWidth / this.imgOrigW;
this.imgCurrH = Math.round(this.imgOrigH * this.curScale);
if (this.imgCurrH < this.options.vpHeight) {
this.imgCurrH = this.options.vpHeight;
this.curScale = this.options.vpHeight / this.imgOrigH;
this.imgCurrW = Math.round(this.imgOrigW * this.curScale);}
} else {
this.imgCurrH = this.options.vpHeight;
this.curScale = this.options.vpHeight / this.imgOrigH;
this.imgCurrW = Math.round(this.imgOrigW * this.curScale);
if (this.imgCurrW < this.options.vpWidth) {
this.imgCurrW = this.options.vpWidth;
this.curScale = this.options.vpWidth / this.imgOrigW;
this.imgCurrH = Math.round(this.imgOrigH * this.curScale);}}}},
prepareOverlay: function () {
com.liquidpixels.Mixable.applyTo(this.overlay, com.liquidpixels.zap.Gestureable, {
actionTouchStart: this.startingMove.bind(this),
actionTouchMove: this.doTranslation.bind(this),
actionTouchFinish: this.finishedMove.bind(this),
actionOnStart: this.startingMove.bind(this),
actionOnMove: this.doTranslation.bind(this),
actionOnFinish: this.finishedMove.bind(this),
actionGestureStart: this.doGestureStart.bind(this),
actionGestureMove: this.doGestureZoom.bind(this),
actionGestureEnd: this.doGestureEnd.bind(this),
actionOnClick: this.doClick.bind(this),
actionOnPress: this.options.touchClick ? this.doTouchClick.bind(this) : null,
actionOnTwoFingerPress: this.options.touchClick ? this.doTwoTouchClick.bind(this) : null,
width: this.imgCurrW,
height: this.imgCurrH,});
this.overlay.Gestureable.prepare();
var vpDims = this.viewPort.getSize();
this.overlay.setSize(vpDims.width, vpDims.height);
this.determineTouchScrollPassthrough();},
determineTouchScrollPassthrough: function (force) {
if (this.options.touchScrollPassthrough && $DEF(this.overlay) && $DEF(this.overlay.Gestureable)) {
if ($DEF(force)) {
this.overlay.Gestureable.setTouchScrollPassthrough(force);
} else if (this.curScale <= this.options.minScale) {
this.overlay.Gestureable.setTouchScrollPassthrough(true);
} else {
this.overlay.Gestureable.setTouchScrollPassthrough(false);}}},
startingMove: function (e) {
this.focusViewer();
if (e.touches) {
this.initialTouchPoint = e.touches[0];
} else {
if (this.state != "tweening") {
this.state = "busy";}}
this.startingMoveStatusUpdate();},
startingMoveStatusUpdate: function () {
this.setStatusText("pan");},
finishedMove: function (e) {
if (this.state != "tweening") {
this.layers.each(
function (pair) {
if (pair.value.id == this.currentLayer.id || pair.value.id == this.prevLayer.id) {
pair.value.Transformable.update();}
}.bind(this)
);
this.fireReadyEvent();}},
doNormalize: function (e) {
this.currentLayer.Transformable.normalizeOffset(e);},
setLayer: function (id, layer) {
return this.layerSet.set(id, layer);},
getLayer: function (id) {
return this.layerSet.get(id);},
loadImage: function (image) {
this.state = "loading";
this.homeIcon ? this.homeIcon.hide() : 0;
this.parent.collectionHome = null;
this.destroyLayers();
this.overlay.Gestureable ? this.overlay.Gestureable.clearEvents() : 0;
this.options.image = image;
this.options.chain = null;
this.options.collectionViewport = null;
var queue = Effect.Queues.get("global");
queue.each(function (e) {
e.cancel();});
queue = Effect.Queues.get("cacheImage");
queue.each(function (e) {
e.cancel();});
queue = Effect.Queues.get("baseImage");
queue.each(function (e) {
e.cancel();});
this.buildSource();
this.focusViewer();},
loadChain: function (chain, options) {
this.state = "loading";
this.homeIcon ? this.homeIcon.hide() : 0;
this.parent.collectionHome = null;
this.destroyLayers();
this.overlay.Gestureable ? this.overlay.Gestureable.clearEvents() : 0;
this.options.image = null;
this.options.chain = chain;
this.options.collectionViewport = null;
this.options.caption = null;
Object.extend(this.options, options || {});
var queue = Effect.Queues.get("global");
queue.each(function (e) {
e.cancel();});
queue = Effect.Queues.get("cacheImage");
queue.each(function (e) {
e.cancel();});
queue = Effect.Queues.get("baseImage");
queue.each(function (e) {
e.cancel();});
this.buildSource();
this.focusViewer();},
getView: function () {
return this.layerPane;},
reloadSource: function () {
this.setState("reloading");
this.destroyLayers();
this.startZap();
this.focusViewer();},
startZap: function () {
this.prepareImage();
this.buildStartingLayer();},
doClick: function (e) {
var ariaValue = "zoomIn";
this.focusViewer();
if (this.state == "tweening") {
return;}
if (e.altKey && e.shiftKey) {
this.popupVersion();
return;}
if (!this.currentLayer.loaded) {
return;}
this.setState("busy");
this.hidePrevLayers();
var cs = this.curScale;
var ns;
if (e.shiftKey) {
ariaValue = "zoomOut";
ns = cs * (1 / this.options.zoomFactor);
} else {
ns = cs * this.options.zoomFactor;}
if (ns > this.options.maxScale) {
ns = this.options.maxScale;}
if (ns < this.options.minScale) {
ns = this.options.minScale;}
var pos = this.currentLayer.getPosition();
var point = {
x: e.clientX - pos.left,
y: e.clientY - pos.top,
mx: e.clientX,
my: e.clientY,};
this.checkHome("start", ns);
this.scaleLayer(ns, point);
this.checkHome("end");
this.setStatusText(ariaValue);},
doTouchClick: function (e) {}, //Virtual
doTwoTouchClick: function (e) {}, //Virtual
zoomBy: function (data) {},
zoomToPoint: function (data, opts) {
var ariaValue = "";
this.focusViewer();
this.setState("busy");
var ds = data.scale;
if (ds < 1) {
ariaValue = "zoomOut";
} else if (ds > 1) {
ariaValue = "zoomIn";}
var ns;
var pos = this.currentLayer.getPosition();
var ctr = this.currentLayer.Transformable.getBoundCenter();
var ptx = $NZS(data.x) ? Math.round(data.x * this.curScale) : ctr.x - pos.left;
var pty = $NZS(data.y) ? Math.round(data.y * this.curScale) : ctr.y - pos.top;
var point = {
x: ptx,
y: pty,};
if ($DEF(ds)) {
ns = opts && opts.absolute ? ds : ds * this.curScale;
if (ns > this.options.maxScale) {
ns = this.options.maxScale;}
if (ns < this.options.minScale) {
ns = this.options.minScale;}
} else {
ns = this.curScale;}
opts && opts.ignoreCheckHome ? 0 : this.checkHome("start", ns);
this.scaleLayer(ns, point, opts);
opts && opts.ignoreCheckHome ? 0 : this.checkHome("end");
this.setStatusText(ariaValue);},
panByAmount: function (data) {
this.focusViewer();
if (this.options.maxScale == this.options.minScale) {
return;}
this.setState("busy");
var mvx = Math.round(data.x || 0);
var mvy = Math.round(data.y || 0);
var pos = {
x: 0,
y: 0,};
if (this.currentLayer.width < this.options.vpWidth) {
pos.x = Math.round((this.options.vpWidth - this.currentLayer.width) / 2);}
if (this.currentLayer.height < this.options.vpHeight) {
pos.y = Math.round((this.options.vpHeight - this.currentLayer.height) / 2);}
this.currentLayer.Transformable.translate(mvx, mvy, {
centered: pos,
tween: true,
duration: 0.5,
easingFunction: this.options.easingFunction,
afterLayout: this.afterPan.bind(this),});
this.setStatusText("pan");},
panByPercent: function (data) {
this.focusViewer();
if (this.options.maxScale == this.options.minScale) {
return;}
this.setState("busy");
var sz = this.currentLayer.getSize();
var pos = this.currentLayer.getPosition();
var mvx = Math.round((data.px || 0) * sz.width);
var mvy = Math.round((data.py || 0) * sz.height);
var pos = {
x: 0,
y: 0,};
if (this.currentLayer.width < this.options.vpWidth) {
pos.x = Math.round((this.options.vpWidth - this.currentLayer.width) / 2);}
if (this.currentLayer.height < this.options.vpHeight) {
pos.y = Math.round((this.options.vpHeight - this.currentLayer.height) / 2);}
this.currentLayer.Transformable.translate(mvx, mvy, {
centered: pos,
tween: true,
duration: 0.5,
easingFunction: this.options.easingFunction,
afterLayout: this.afterPan.bind(this),});
this.setStatusText("pan");},
zoomToRegion: function (data) {
var ariaValue = "";
this.focusViewer();
this.setState("busy");
var vals;
var scale;
if (data.region) {
vals = {
x: 0,
y: 0,};
} else {
var region = {
x1: parseInt(data.x1, 10),
y1: parseInt(data.y1, 10),
x2: parseInt(data.x2, 10),
y2: parseInt(data.y2, 10),};
var w = region.x2 - region.x1;
var h = region.y2 - region.y1;
var cx = (region.x2 + region.x1) / 2;
var cy = (region.y2 + region.y1) / 2;
var xscale = this.options.vpWidth / w;
var yscale = this.options.vpHeight / h;
scale = xscale <= yscale ? yscale : xscale;
var ts = scale / this.curScale;
if (ts > this.curScale) {
ariaValue = "zoomIn";
} else if (ts < this.curScale) {
ariaValue = "zoomOut";}
this.zoomToPoint(
{
scale: ts,
x: cx,
y: cy,},
{
ignoreCheckHome: data.collectionViewport,}
);
this.setStatusText(ariaValue);}},
afterPan: function () {}, // VIRTUAL
afterLayout: function () {
this.determineTouchScrollPassthrough();
this.currentLayer.Transformable.update();
this.fireReadyEvent();},
doTranslation: function (e) {
this.focusViewer();
if (this.state == "tweening") {
return;}
if (!this.currentLayer.isLoaded()) {
return;}
this.hidePrevLayers();
var mv = this.getAmountMoved(e);
if (!mv) {
return;}
var pos = {
x: 0,
y: 0,};
if (this.currentLayer.width < this.options.vpWidth) {
pos.x = Math.round((this.options.vpWidth - this.currentLayer.width) / 2);}
if (this.currentLayer.height < this.options.vpHeight) {
pos.y = Math.round((this.options.vpHeight - this.currentLayer.height) / 2);}
this.currentLayer.Transformable.translate(mv.x, mv.y, {
centered: pos,});
if (this.homeScale == this.options.minScale && this.curScale == this.options.minScale) {
} else {
this.checkHome("start");}},
doGestureStart: function (e) {
this.focusViewer();
this.determineTouchScrollPassthrough(false);},
doGestureZoom: function (e) {},
doGestureEnd: function (e) {},
getAmountMoved: function (e) {
if (e.touches) {
if (e.touches.length != 1) {
return null;
} else {
return this.overlay.Gestureable.getMove();}
} else {
return this.overlay.Gestureable.getMoveFromStart();}},
getImgData: function () {
var vals = {};
if (this.currentLayer) {
var Pnow = this.currentLayer.getPosition();
var Pctr = this.currentLayer.Transformable.getCenterPosition();
var imgx = Math.round(this.imgOrigW / 2 - (Pnow.left - Pctr.x) / this.curScale);
var imgy = Math.round(this.imgOrigH / 2 - (Pnow.top - Pctr.y) / this.curScale);
var bounds = this.currentLayer.Transformable.getBounds();
vals = {
x: imgx,
y: imgy,
height: this.imgOrigH,
width: this.imgOrigW,
scale: this.curScale,
atMinScale: !!(this.curScale == this.options.minScale),
atMaxScale: !!(this.curScale == this.options.maxScale),
atMinX: !!(Pnow.left >= bounds.maxX),
atMaxX: !!(Pnow.left <= bounds.minX),
atMinY: !!(Pnow.top >= bounds.maxY),
atMaxY: !!(Pnow.top <= bounds.minY),};
if (Pnow.left > 0) {
vals.atMinX = true;
vals.atMaxX = true;}
if (Pnow.top > 0) {
vals.atMinY = true;
vals.atMaxY = true;}
var sz = this.currentLayer.getSize();
var pos = this.currentLayer.getPosition();}
return vals;},
fireReadyEvent: function (data) {
this.setState("ready");
this.fireZapEvent("ready", data);},
fireLoadedEvent: function (data) {
this.fireZapEvent("loaded", data);},
fireWaitingEvent: function (data) {
this.setState("waiting");
this.fireZapEvent("waiting", data);},
fireDimensionsEvent: function (data) {
this.setState("ready");
this.fireZapEvent("dimensions", data);},
fireStartedEvent: function (data) {
this.fireZapEvent("started", data);},
fireErrorEvent: function (data) {
this.setState("error");
this.fireZapEvent("error", data);},
fireZapEvent: function (response, data) {
var vals;
if (this.state === "error" || response === "waiting") {
vals = data;
} else {
vals = this.getImgData();
Object.extend(vals, data);}
this.parent.sendEvent(response, vals);},
destroyLayers: function () {
this.layers.each(
function (pair) {
this.layers.unset(pair.key);
pair.value.DESTROY();
}.bind(this)
);
this.currentLayer = null;},
getState: function () {
return this.state || "notready";},
isReady: function () {
return !!(this.state === "ready");},
isApiReady: function () {
return !!(this.state === "apiReady");},
isError: function () {
return !!(this.state === "error");},
setState: function (state) {
var toState = state;
var hideWait = true;
var showWait = false;
var layerLoaded = false;
if (state == "delayed" || state == "waiting") {
toState = "ready";
} else if (state == "ready") {
layerLoaded = true;
} else if (state == "busy" || state == "reloading" || state == "tweening") {
showWait = true;}
if (showWait) {
this.showPixelLoader();
} else if (hideWait) {
this.hidePixelLoader();}
this.state = toState;
if (this.currentLayer) {
this.currentLayer.loaded = layerLoaded;}},
popupVersion: function () {
var version = com.liquidpixels.ResourceServer.Flags["com.liquidpixels.zap"].version || "Unavailable";
var version2 = com.liquidpixels.ResourceServer.Flags["com.liquidpixels.viewers-html"].version || "Unavailable";
alert("Resource Version: " + version + "\nHTML Version: " + version2);
this.displayedVersion = true;
this.state = "ready";},
actOnKey: function (e) {
Event.stop(e);
if (!this.isReady()) {
return;}
var width = Math.round(this.options.vpWidth / 2);
var height = Math.round(this.options.vpHeight / 2);
if (e.keyCode == 48 && e.type == "keyup") {
this.goHome();
} else if (e.keyCode == 187 && e.type == "keyup") {
this.zoomToPoint({ scale: 2 });
} else if (e.keyCode == 189 && e.type == "keyup") {
this.zoomToPoint({ scale: 0.5 });
} else if (e.keyCode == 37 && e.type == "keyup") {
this.panByAmount({ x: width });
} else if (e.keyCode == 38 && e.type == "keyup") {
this.panByAmount({ y: height });
} else if (e.keyCode == 39 && e.type == "keyup") {
this.panByAmount({ x: -width });
} else if (e.keyCode == 40 && e.type == "keyup") {
this.panByAmount({ y: -height });
} else if (e.keyCode == 27 && e.type == "keyup") {
this.blurViewer();}},
focusViewer: function () {
window.focus();},
blurViewer: function () {
this.setStatusText("exit");
setTimeout(
function () {
this.fireZapEvent("blur");
this.setStatusText("start");
}.bind(this),
2000
);},
buildStartingLayer: function () {},
buildLayer: function () {},
scaleLayer: function () {},
toString: function () {
return "com.liquidpixels.zap.ZapManager";},
DESTROY: function () {
clearTimeout(this.waitImgTimer);
clearTimeout(this.lfQueryTimeout);
this.viewPort.DESTROY();
this.viewPort = null;
this.overlay.Gestureable.DESTROY();
this.overlay.DESTROY();
this.overlay = null;
this.layerSet = null;
this.currentLayer = null;},});
com.liquidpixels.application.Exception = Class.create(com.liquidpixels.Exception, {
type: 		'Application.Exception'	// static, final
});
com.liquidpixels.application.Exception.DelegateNotDefined = Class.create(com.liquidpixels.application.Exception, {
type: 		'Application.DelegateNotDefined'	// static, final
});
com.liquidpixels.application.Event = Class.create(com.liquidpixels.event.TypedEvent, {
type: 		'Application.Event'	// static, final
});
com.liquidpixels.query.Exception = Class.create(com.liquidpixels.Exception, {
type: 		'Query.Exception'		// static, final
});
com.liquidpixels.query.Event = Class.create(com.liquidpixels.event.TypedEvent, {
type: 		'Query.Event'	// static, final
});
com.liquidpixels.wui.Exception = Class.create(com.liquidpixels.Exception, {
type: 			'wui.Exception'	// static, final
});
com.liquidpixels.wui.Event = Class.create(com.liquidpixels.event.TypedEvent, {
type: 		'WUI.Event'	// static, final
});
com.liquidpixels.zap.stitched.Manager = Class.create(com.liquidpixels.zap.ZapManager, {
tweenDuration: undefined,
curScale: undefined,
proxyImageScale: undefined,
setDefaults: function($super) {
$super();
Object.extend(this.options, {
stitchedBackgroundColor: 'white'});
this.viewerName = 'Zoom_Stitched';},
buildViewPort: function($super) {
$super();
this.viewPort.addClassName("stitched");},
prepareImage: function() {
var dH = this.imgOrigH - this.options.vpHeight;
var dW = this.imgOrigW - this.options.vpWidth;
this.options.minScale = Math.min(this.options.vpWidth / this.imgOrigW, this.options.vpHeight / this.imgOrigH);
if (dH >= dW) {
this.imgCurrW = this.options.vpWidth;
this.curScale = this.options.vpWidth / this.imgOrigW;
this.imgCurrH = Math.round(this.imgOrigH * this.curScale);
if (this.imgCurrH < this.options.vpHeight) {
this.imgCurrH = this.options.vpHeight;
this.curScale = this.options.vpHeight / this.imgOrigH;
this.imgCurrW = Math.round(this.imgOrigW * this.curScale);}
} else {
this.imgCurrH = this.options.vpHeight;
this.curScale = this.options.vpHeight / this.imgOrigH;
this.imgCurrW = Math.round(this.imgOrigW * this.curScale);
if (this.imgCurrW < this.options.vpWidth) {
this.imgCurrW = this.options.vpWidth;
this.curScale = this.options.vpWidth / this.imgOrigW;
this.imgCurrH = Math.round(this.imgOrigH * this.curScale);}}},
buildStartingLayer: function() {
this.tweenDuration = this.options.tweenDuration ? this.options.tweenDuration : 0.5;
this.retina = this.options.retina !== undefined ? this.options.retina : true;
this.proxyImageScale = this.curScale;
var cl_layer = com.liquidpixels.zap.stitched.Image;
var params = {
src: this.chain,
baseH: this.imgOrigH,
baseW: this.imgOrigW,
imgCurrH: this.imgCurrH,
imgCurrW: this.imgCurrW,
vpW: this.options.vpWidth,
vpH: this.options.vpHeight,
xPos: 0,
yPos: 0,
tScale: this.curScale,
cssClass: 'stitchedView',
tweenDuration: this.tweenDuration,
retina: this.retina,
baseImageFunction: this.baseImageSetup.bind(this),
accounting: this.accounting};
var layer = new cl_layer(this, params);
this.layers.set(layer.id, layer);
this.layerPane.appendChild(layer);
com.liquidpixels.event.EventDispatcher.makeDispatcher(layer);
layer.addEventListener("WUI.Event.StitchedImage.Loaded", this.onLayerLoaded.bind(this));
layer.prepare({
imgOrigH: this.imgOrigH,
imgOrigW: this.imgOrigW,
boundW: this.options.vpWidth,
boundH: this.options.vpHeight});
this.currentLayer = layer;
this.currentLayer.layout('center', {
afterLayout: function() {
this.prepareOverlay();
if (this.options.displayMode === 'fill') {
this.fireReadyEvent();}
var uaq = Application.get("uaq");
if (uaq.IE && (uaq.agent == "IE6" || uaq.agent == "IE7" || uaq.agent == "IE8") && this.currentLayer.baseImage.element.complete) {
this.baseImageSetup();}
}.bind(this)});},
baseImageSetup: function(e) {
this.currentLayer.baseImage.appear({
duration: 0.5, //this.tweenDuration,
queue: {
scope: 'baseImage'},
afterFinish: function() {
if (this.options.displayMode === 'fill') {
this.currentLayer.allLoaded = true;
this.homeScale = this.curScale;
this.onLayerLoaded();}
}.bind(this)});
var ctr = this.currentLayer.Transformable.getBoundCenter();
var pos = this.currentLayer.getPosition();
var ptx = (ctr.x - pos.left);
var pty = (ctr.y - pos.top);
var point = {
x: ptx,
y: pty};
if (this.options.displayMode === 'full') {
this.scaleLayer(this.options.maxScale, point, {
tween: false});
} else if (this.options.displayMode === 'fit') {
this.scaleLayer(this.options.minScale, point, {
tween: false});}
this.homeScale = this.curScale;},
startingMove: function($super, e) {
$super(e);
var queue = Effect.Queues.get('cacheImage');
queue.each(function(e) {
e.cancel();
e.element.style.opacity = 1;
e.element.style.display = 'none';});
this.currentLayer.cacheImage.setSrc("");
this.currentLayer.cacheImage.hide();},
finishedMove: function($super, e) {
$super(e);
if (this.curScale > this.proxyImageScale) {
var stitchedVals = this.calcNewStitchValues(this.curScale);
this.currentLayer.updateStitchedImage(stitchedVals, this.curScale);
} else {
this.currentLayer.allLoaded = true;
this.onLayerLoaded();}},
afterPan: function() {
this.finishedMove();},
scaleLayer: function(scale, toPos, opts) {
opts = opts || {};
this.setState("tweening");
var curPos = this.currentLayer.getPosition();
var curSz = this.currentLayer.getSize();
this.currentLayer.allLoaded = false;
var queue = Effect.Queues.get('cacheImage');
queue.each(function(e) {
e.cancel();
e.element.style.opacity = 1;
e.element.style.display = 'none';});
this.currentLayer.cacheImage.setSrc("");
this.currentLayer.cacheImage.hide();
var tween = $NZS(opts.tween, true);
if (scale === this.curScale) {
if (this.currentLayer.width <= this.options.vpWidth || this.currentLayer.height <= this.options.vpHeight) {
toPos = 'center';}
this.currentLayer.layout(toPos, {
tween: tween,
duration: this.tweenDuration,
easingFunction: this.options.easingFunction,
afterLayout: function() {
this.afterLayout();
if (this.curScale > this.proxyImageScale) {
var stitchedVals = this.calcNewStitchValues(this.curScale);
this.currentLayer.updateStitchedImage(stitchedVals, this.curScale);
} else {
this.currentLayer.allLoaded = true;
this.onLayerLoaded();}
}.bind(this)});
} else {
var prevScale = this.curScale;
var newScale = scale;
this.curScale = scale;
var curPos = this.currentLayer.getPosition();
var leftTweenFrom = curPos.left;
var topTweenFrom = curPos.top;
var finW = (this.imgOrigW * scale);
var finH = (this.imgOrigH * scale);
this.currentLayer.setSize(finW, finH);
this.currentLayer.Transformable.update();
var cof = this.currentLayer.Transformable.getCenteredAt(
(toPos.x * newScale / prevScale), (toPos.y * newScale / prevScale));
var leftTweenTo = Math.round(cof.x);
var topTweenTo = Math.round(cof.y);
if (finW < this.options.vpWidth) {
leftTweenTo = Math.round((this.options.vpWidth - finW) / 2);}
if (finH < this.options.vpHeight) {
topTweenTo = Math.round((this.options.vpHeight - finH) / 2);}
var finalParams = {
size: {
width: finW,
height: finH},
position: {
left: leftTweenTo,
top: topTweenTo},
options: opts};
if (tween) {
if (this.userAgent.modern) {
var transition = "transform " + this.tweenDuration + "s " + com.liquidpixels.utilities.cssEasingFunctions[this.options.easingFunction];
var webkitTransition = "-webkit-transform " + this.tweenDuration + "s " + com.liquidpixels.utilities.cssEasingFunctions[this.options.easingFunction];
this.currentLayer.setStyle({
webkitTransition: webkitTransition,
transition: transition,
webkitTransformOrigin: "left top",
transformOrigin: "left top",
webkitTransform: "translate3d(0, 0, 0) scale3d(1,1,1)",
transform: "translate3d(0, 0, 0) scale3d(1,1,1)"});
var cssScale = (this.curScale / prevScale);
var transitionendFunc = function(e) {
this.currentLayer.element.stopObserving("transitionend");
this.currentLayer.element.stopObserving("webkitTransitionEnd");
this.currentLayer.setStyle({
webkitTransition: "none",
transition: "none",
webkitTransform: "none",
transform: "none"});
this.afterScaleLayerFinish(finalParams);
}.bind(this);
this.cssTransitionTimeout = setTimeout(function(e) {
this.currentLayer.element.observe("transitionend", transitionendFunc);
this.currentLayer.element.observe("webkitTransitionEnd", transitionendFunc);
this.currentLayer.setStyle({
webkitTransform: "translate3d(" + (leftTweenTo - leftTweenFrom) + "px, " + (topTweenTo - topTweenFrom) + "px, 0) scale3d(" + cssScale + "," + cssScale + ", 1)",
transform: "translate3d(" + (leftTweenTo - leftTweenFrom) + "px, " + (topTweenTo - topTweenFrom) + "px, 0) scale3d(" + cssScale + "," + cssScale + ", 1)"});
}.bind(this), 10);
} else {
var effectArr = [];
effectArr.push(
new Effect.Tween(null, leftTweenFrom, leftTweenTo, {
sync: true
}, function(mv) {
this.currentLayer.setPosition( /*Math.round*/ (mv), "", opts);
}.bind(this))
);
effectArr.push(
new Effect.Tween(null, topTweenFrom, topTweenTo, {
sync: true
}, function(mv) {
this.currentLayer.setPosition("", /*Math.round*/ (mv), opts);
}.bind(this))
);
effectArr.push(
new Effect.Scale(this.currentLayer.baseImage.element, (this.curScale / prevScale) * 100, {
sync: true
})
);
new Effect.Parallel(effectArr, {
afterFinish: this.afterScaleLayerFinish.bind(this, finalParams),
transition: Effect.Transitions[this.options.easingFunction],
duration: this.tweenDuration,
queue: {
scope: 'baseImage'}});}
} else {
this.afterScaleLayerFinish(finalParams);}}},
afterScaleLayerFinish: function(values) {
this.currentLayer.setPosition(values.position.left, values.position.top, values.options);
this.currentLayer.baseImage.setSize(values.size.width, values.size.height);
this.afterLayout();
if (this.curScale > this.proxyImageScale) {
var stitchedVals = this.calcNewStitchValues(this.curScale);
this.currentLayer.updateStitchedImage(stitchedVals, this.curScale);
} else {
this.currentLayer.allLoaded = true;
this.onLayerLoaded();}},
calcNewStitchValues: function(scale) {
var layerPos = this.currentLayer.getPosition();
var rtn = {
x: Math.round(Math.abs(layerPos.x / scale)),
y: Math.round(Math.abs(layerPos.y / scale)),
width: Math.round(this.options.vpWidth / scale),
height: Math.round(this.options.vpHeight / scale),
vsize: this.options.vpWidth,
color: this.options.stitchedBackgroundColor};
return rtn;},
doTouchClick: function(e, twoTouch) {
var ariaValue = "";
if (this.state == "tweening") {
return;}
if (!this.currentLayer.loaded) {
return;}
this.setState("tweening");
this.hidePrevLayers();
var cs = this.curScale;
var ns;
if (twoTouch) {
ariaValue = "zoomIn";
ns = cs * (1 / this.options.zoomFactor);
} else {
ariaValue = "zoomOut";
ns = cs * this.options.zoomFactor;}
if (ns > this.options.maxScale) {
ns = this.options.maxScale;}
if (ns < this.options.minScale) {
ns = this.options.minScale;}
var pos = this.currentLayer.getPosition();
var ctr = this.currentLayer.Transformable.getBoundCenter();
var point = {
x: this.initialTouchPoint.clientX ? this.initialTouchPoint.clientX - pos.left : ctr.x - pos.left,
y: this.initialTouchPoint.clientY ? this.initialTouchPoint.clientY - pos.top : ctr.y - pos.top,
mx: this.initialTouchPoint.clientX ? this.initialTouchPoint.clientX : ctr.x,
my: this.initialTouchPoint.clientY ? this.initialTouchPoint.clientY : ctr.y};
this.checkHome("start", ns);
this.scaleLayer(ns, point);
this.checkHome("end");
this.setStatusText(ariaValue);},
doTwoTouchClick: function(e) {
this.doTouchClick(e, true);},
doGestureStart: function($super, e) {
$super(e);
var cs = this.curScale;
this.adjMaxScale = this.options.maxScale / cs;
this.adjMinScale = this.options.minScale / cs;
this.currentLayer.Transformable.centerOrigin();
this.setStatusText("zoom");},
doGestureZoom: function(e) {
this.currentLayer.Transformable.cssTransformScale(e.scale);},
doGestureEnd: function(e) {
var ns = e.scale;
if (ns > this.adjMaxScale) {
ns = this.adjMaxScale;
} else if (ns < this.adjMinScale) {
ns = this.adjMinScale;}
var ctr = this.currentLayer.Transformable.getBoundCenter();
var pos = this.currentLayer.getPosition();
var size = this.currentLayer.getSize();
if (ns != e.scale) {
var imgCtrX = ctr.x - pos.left;
var imgCtrY = ctr.y - pos.top;
var deltaX = imgCtrX - (size.width / 2);
var deltaY = imgCtrY - (size.height / 2);
var effectArr = [];
effectArr.push(
new Effect.Tween(null, e.scale, ns, {
sync: true
}, function(mv) {
this.currentLayer.Transformable.cssTransformScale(mv);
}.bind(this))
);
if (e.scale < ns) {
this.setState("tweening");
var x = Math.round(deltaX * this.options.minScale / this.curScale);
var y = Math.round(deltaY * this.options.minScale / this.curScale);
effectArr.push(
new Effect.Tween(null, 0, x, {
sync: true
}, function(mv) {
this.currentLayer.Transformable.cssTransformTranslateX(mv);
}.bind(this))
);
effectArr.push(
new Effect.Tween(null, 0, y, {
sync: true
}, function(mv) {
this.currentLayer.Transformable.cssTransformTranslateY(mv);
}.bind(this))
);}
new Effect.Parallel(effectArr, {
afterFinish: function() {
this.setState("busy");
this.afterGestureEnd();
this.currentLayer.Transformable.cssTransformReset();
this.zoomToPoint({
scale: ns
}, {
tween: false});
this.currentLayer.Transformable.centerOrigin();
}.bind(this),
duration: 0.2});
} else {
this.afterGestureEnd();
this.currentLayer.Transformable.cssTransformReset();
this.zoomToPoint({
scale: ns
}, {
tween: false});
this.currentLayer.Transformable.centerOrigin();}},
afterGestureEnd: function() {},
toString: function() {
return 'com.liquidpixels.zap.stitched.Manager';},
DESTROY: function($super) {
clearTimeout(this.cssTransitionTimeout);
$super();}});
com.liquidpixels.zap.tiled.Manager = Class.create(com.liquidpixels.zap.ZapManager, {
thresholds: undefined,
factors: undefined,
setDefaults: function($super) {
$super();
Object.extend(this.options, {
tileSize: 128});
this.thresholds = [100, 50, 25, 13, 7, 4, 2, 1];
this.factors = [1, 2, 4, 8, 16, 32, 64, 128];
this.viewerName = "Zoom_Tiled";},
buildViewPort: function($super) {
$super();
this.viewPort.addClassName("tiled");},
buildBackgroundImageChain: function() {
this.backgroundImageChain = this.chain.clone();
var sink = this.backgroundImageChain.findCommand("sink");
if (sink) {
this.backgroundImageChain.deleteCommand(sink);}
var vals = {
x: 0,
y: 0,
width: this.imgOrigW,
height: this.imgOrigH,
vsize: this.options.vpWidth,
color: "white"};
Object.extend(vals, this.accounting.seed ? { seed: this.accounting.seed } : {});
this.backgroundImageChain.addCommand("viewport", vals);
this.backgroundImageChain.addCommand("blur", {
width: "2",
sigma: "2.0"});
this.backgroundImageChain.addSink({
format: "jpeg",
quality: "50"});
return this.backgroundImageChain;},
buildStartingLayer: function() {
var tv = this.getTileValues(this.curScale);
var mintv = this.getTileValues(this.options.minScale);
this.minLayer = mintv.tLayer;
this.currentLayer = this.buildLayer(tv); // layerValues
this.currentLayer.layout("center", {
afterLayout: this.initialLayerStartup.bind(this)});},
initialLayerStartup: function(e) {
if (this.currentLayer.backgroundImage.loaded) {
this.currentLayer.appear({
duration: 0.5,
afterFinish: function(e) {
this.currentLayer.drawTiles();
this.prepareOverlay();
this.fireReadyEvent();
this.homeScale = this.curScale;
}.bind(this)});
} else {
this.initialStartupTimer = setTimeout(
function() {
this.initialLayerStartup();
}.bind(this),
100
);}},
buildLayer: function(layerValues) {
this.tweenDuration = this.options.tweenDuration ? this.options.tweenDuration : 0.5;
var cl_layer = com.liquidpixels.zap.tiled.Image;
var params = {
src: this.chain,
baseH: this.imgOrigH,
baseW: this.imgOrigW,
vpW: this.options.vpWidth,
vpH: this.options.vpHeight,
tileSize: this.options.tileSize,
xPos: 0,
yPos: 0,
tScale: this.curScale,
tweenDuration: this.tweenDuration,
tFactor: layerValues.tFactor,
tLayer: layerValues.tLayer,
cssClass: "tileImage",
accounting: this.accounting,
easingFunction: this.options.easingFunction,
backgroundImageChain: this.buildBackgroundImageChain()};
var layer = new cl_layer(this, params);
layer.hide();
this.layers.set(layer.id, layer);
this.layerPane.appendChild(layer);
com.liquidpixels.event.EventDispatcher.makeDispatcher(layer);
layer.addEventListener("WUI.Event.TiledImage.Loaded", this.onLayerLoaded.bind(this));
layer.prepare({
imgOrigH: this.imgOrigH,
imgOrigW: this.imgOrigW,
boundW: this.options.vpWidth,
boundH: this.options.vpHeight});
return layer;},
getTileValues: function(atScale) {
var pct = Math.ceil(atScale * 100);
var info;
var i = this.thresholds.length - 1;
if (pct < 1) {
tlayer = 1;
} else {
while (pct >= this.thresholds[i] && i > 0) {
i--;}}
info = {
tLayer: this.thresholds[i],
tFactor: this.factors[i]};
return info;},
scaleLayer: function(scale, toPos, opts) {
opts = opts || {};
this.setState("tweening");
var curPos = this.currentLayer.getPosition();
var curSz = this.currentLayer.getSize();
var tween = $NZS(opts.tween, true);
var ctrPt = {
x: curSz.width / 2,
y: curSz.height / 2};
var tv = this.getTileValues(scale);
var curLayerValues = this.currentLayer.getLayerValues();
if (scale === this.curScale) {
if (this.currentLayer.tilesHidden) {
this.currentLayer.showAllTiles({
appear: true});}
if (this.currentLayer.width <= this.options.vpWidth || this.currentLayer.height <= this.options.vpHeight) {
toPos = "center";}
this.currentLayer.layout(toPos, {
tween: tween,
duration: this.tweenDuration,
easingFunction: this.options.easingFunction,
afterLayout: this.afterLayout.bind(this)});
return;}
if (tv.tLayer < this.minLayer) {
this.currentLayer.layout("center", {
tween: tween,
duration: this.tweenDuration,
easingFunction: this.options.easingFunction,
afterLayout: this.afterLayout.bind(this)});
return;}
var cs = this.curScale;
this.curScale = scale;
var repos = {
x: Math.round((toPos.x * scale) / cs),
y: Math.round((toPos.y * scale) / cs)};
layer = this.buildLayer(tv);
layer.resizeTilesNonTween(scale, repos);
this.currentLayer.hideAllTiles();
this.currentLayer.resizeTiles(scale, repos, {
tween: tween,
duration: this.tweenDuration,
easingFunction: this.options.easingFunction,
prevLayerValues: curLayerValues,
afterFinish: function() {
this.afterLayerScaleFinish(layer);
}.bind(this),
size: layer.tsize,
layerFactor: layer.options.tFactor});},
afterLayerScaleFinish: function(layer) {
this.layers.unset(this.currentLayer.id);
this.currentLayer.DESTROY();
this.currentLayer = null;
layer.show();
this.currentLayer = layer;
this.afterLayout();},
afterSameLayerScaleFinish: function() {
this.currentLayer.showAllTiles({
appear: true,
afterFinish: function() {
this.afterLayout();
}.bind(this)});},
doTranslation: function(e) {
if (this.state == "tweening") {
return;}
var mv = this.getAmountMoved(e);
if (!mv) {
return;}
var pos = { x: 0, y: 0 };
if (this.currentLayer.width < this.options.vpWidth) {
pos.x = Math.round((this.options.vpWidth - this.currentLayer.width) / 2);}
if (this.currentLayer.height < this.options.vpHeight) {
pos.y = Math.round((this.options.vpHeight - this.currentLayer.height) / 2);}
this.currentLayer.Transformable.translate(mv.x, mv.y, { centered: pos });
if (this.homeScale == this.options.minScale && this.curScale == this.options.minScale) {
} else {
this.checkHome("start");}},
afterPan: function() {
this.currentLayer.Transformable.update();
this.fireReadyEvent();
this.currentLayer.drawTiles();},
afterLayout: function() {
this.determineTouchScrollPassthrough();
this.currentLayer.Transformable.update();
this.fireReadyEvent();
this.currentLayer.drawTiles();},
finishedMove: function(e) {
if (this.state != "tweening") {
this.currentLayer.Transformable.update();
this.fireReadyEvent();
this.currentLayer.drawTiles();}},
hidePrevLayers: function() {
return;},
doTouchClick: function(e, twoTouch) {
var ariaValue = "";
if (this.state == "tweening") {
return;}
if (!this.currentLayer.loaded) {
return;}
this.setState("tweening");
this.hidePrevLayers();
var cs = this.curScale;
var ns;
if (twoTouch) {
ariaValue = "zoomOut";
ns = cs * (1 / this.options.zoomFactor);
} else {
ariaValue = "zoomIn";
ns = cs * this.options.zoomFactor;}
if (ns > this.options.maxScale) {
ns = this.options.maxScale;}
if (ns < this.options.minScale) {
ns = this.options.minScale;}
var pos = this.currentLayer.getPosition();
var ctr = this.currentLayer.Transformable.getBoundCenter();
var point = {
x: this.initialTouchPoint.clientX ? this.initialTouchPoint.clientX - pos.left : ctr.x - pos.left,
y: this.initialTouchPoint.clientY ? this.initialTouchPoint.clientY - pos.top : ctr.y - pos.top,
mx: this.initialTouchPoint.clientX ? this.initialTouchPoint.clientX : ctr.x,
my: this.initialTouchPoint.clientY ? this.initialTouchPoint.clientY : ctr.y};
this.checkHome("start", ns);
this.scaleLayer(ns, point);
this.checkHome("end");
this.setStatusText(ariaValue);},
doTwoTouchClick: function(e) {
this.doTouchClick(e, true);},
doGestureStart: function($super, e) {
$super(e);
var cs = this.curScale;
this.adjMaxScale = this.options.maxScale / cs;
this.adjMinScale = this.options.minScale / cs;
this.currentLayer.Transformable.centerOrigin();
this.currentLayer.hideAllTiles();
this.currentLayer.setStyle({
webkitTransition: "none",
transition: "none",
webkitTransform: "translate3d(0, 0, 0) scale3d(1, 1, 1)",
transform: "translate3d(0, 0, 0) scale3d(1, 1, 1)"});
this.setStatusText("zoom");},
doGestureZoom: function(e) {
var ns = e.scale;
if (ns > this.adjMaxScale) {
ns = this.adjMaxScale;
} else if (ns < this.adjMinScale) {
ns = this.adjMinScale;}
this.currentLayer.Transformable.cssTransformScale(ns);},
doGestureEnd: function(e) {
this.currentLayer.Transformable.cssTransformReset();
this.zoomToPoint({ scale: e.scale }, { tween: false });},
DESTROY: function($super) {
clearTimeout(this.initialStartupTimer);
$super();},
toString: function() {
return "com.liquidpixels.zap.tiled.Manager";}});
com.liquidpixels.application._UniversalListeners = new Hash();
com.liquidpixels.application.EventManageable = Class.create(com.liquidpixels.Mixable, {
revision: "$Revision: 6630 $",
Version: function() {
return revision.substr(11).substr(0, -2);},
events:					undefined,
exceptions:				undefined,
handlers:				undefined,
listeners:				undefined,
universalListeners:     undefined,
prepare: function() {
this.events			= new Hash();
this.handlers		= new Hash();
this.exceptions		= new Hash();
this.listeners		= new Hash();			// hears only with ref
this.acuteListeners		= new Hash();		// hears all types...
this.universalListeners		= new Hash();	// hears without ref
if(this.options.fires) {
$H(this.options.fires).each(function(pair) {
this.addEventClass(pair.key, pair.value);});}
if(this.options.handles) {
$H(this.options.handles).each(function(pair) {
this.addHandler(pair.key, pair.value);});}
if(this.options.throws) {
$H(this.options.throws).each(function(pair) {
this.addException(pair.key, pair.value);});}
if(this.options.legacy) {
this.addLegacySet();}},
setDefaults: function() {
this.mixName = 'EventManageable';},
getException: function(exception) {
if(!exception.type) { return null; }
var exc = this.exceptions.get(exception.type) || com.liquidpixels.Exception;
var exi = new exc(exception);
return exi;},
addException: function(exceptionType, exceptionClass) {
this.exceptions.set(exceptionType, exceptionClass);},
throwException: function(exception) {
var ex = this.getException(exception);
throw ex;},
dispatch: function(event, handler) {
if(!event) { return; }
if( event.ignore) { return;	}
if(!event.target) { event.target = this; }
if(handler) {
var hQ = new Array(handler);
this.broadcastTo(hQ, event);
} else {
var eType = event.type || "Untyped";
var rQ = this.listeners.get(eType);
if(rQ) { this.broadcastTo(rQ, event); }
var uQ = com.liquidpixels.application._UniversalListeners.get(eType);
if(uQ) { this.broadcastTo(uQ, event); }
var aQ = this.acuteListeners.get("__ALL_EVENTS__");
if(aQ) { this.broadcastTo(aQ, event); }}},
dispatchUniversal: function(event) {
if(!event) { return; }
if( event.ignore) { return;	}
if(!event.target) { event.target = this.target; }
var eType = event.type || "Untyped";
var uQ = com.liquidpixels.application._UniversalListeners.get(eType);
if(uQ) { this.broadcastTo(uQ, event); }},
dispatchRegistered: function(event) {
if(!event) { return; }
if( event.ignore) { return;	}
if(!event.target) { event.target = this.target; }
var eType = event.type || "Untyped";
var rQ = this.listeners.get(eType);
if(rQ) { this.broadcastTo(rQ, event); }},
broadcastTo: function(queue, event) {
if(!event) { return; }
if(!queue) { return; }
var uEvent;
var eventData = this.events.get(event.type);
if(eventData) {
var eventClass = eventData.eventClass || this.options.defaultEvent;
if(eventClass) {
Object.extend(eventData, event);
uEvent = new eventClass(this.target, eventData);
} else {
uEvent = event;}
} else {
uEvent = event;}
queue.each(function(o, i) {
if(o.func) {
o.func(uEvent);
} else if(o.handler) {
var func = o.handler.EventManageable.handlers.get(event.type);
if(func) {func(uEvent)};}});},
addListenerTo: function(listeners, eventType, handler, bindVar) {
if(!listeners) { return; }
if(!eventType) { return; }
if(!handler) { return; }
var q = listeners.get(eventType) ||
listeners.set(eventType, new Array());
var localQueue;
if (listeners === com.liquidpixels.application._UniversalListeners){
var localQueue = this.universalListeners.get(eventType) || this.universalListeners.set(eventType, new Array());}
var addToQ = true;
q.each(function(o,i) {
if(handler === o.handler) {
addToQ = false;
return;}});
if(addToQ) {
var func;
if(typeof(handler.handle) === 'function') {
func = handler.handle;
} else if(typeof(handler) === 'function') {
if(bindVar) {
func = handler.bind(bindVar);
} else {
func = handler;}}
var data = {
handler: handler,
bindVar: bindVar,
func:	 func};
q.push(data);
if (localQueue){
localQueue.push(data);}}},
removeListenerFrom: function(listeners, eventType, handler) {
if(!listeners) { return; }
if(!eventType) { return; }
var q = listeners.get(eventType);
if (!q) { return; }
var localQueue;
if (listeners === com.liquidpixels.application._UniversalListeners){
localQueue = this.universalListeners.get(eventType);}
if(handler) {
q.each(function(o,i) {
if(handler === o || handler === o.handler) {
listeners.set(eventType,(q).without(o));
if (localQueue){
this.universalListeners.set(eventType, (localQueue).without(o));}
return;}
}.bind(this));
} else {
listeners.unset(eventType);
if (listeners === com.liquidpixels.application._UniversalListeners){
this.universalListeners.unset(eventType);}}},
addListener: function(eventType, handler, bindVar)	{
this.addListenerTo(this.listeners, eventType, handler, bindVar);},
addAcuteListener: function(handler, bindVar) {
this.addListenerTo(this.acuteListeners, '__ALL_EVENTS__', handler, bindVar);},
addUniversalListener: function(eventType, handler, bindVar)	{
this.addListenerTo(com.liquidpixels.application._UniversalListeners, eventType, handler, bindVar);},
addListeners: function(eventTypes, handlers, bindVar) {
$A(eventTypes).each(function(eo,ei) {
$A(handlers).each(function(ho,hi) {
this.addListenerTo(this.listeners, eo, ho, bindVar);
}.bind(this))
}.bind(this));},
addUniversalListeners: function(eventTypes, handlers, bindVar) {
$A(eventTypes).each(function(eo,ei) {
$A(handlers).each(function(ho,hi) {
this.addListenerTo(com.liquidpixels.application._UniversalListeners, eo, ho, bindVar);
}.bind(this))
}.bind(this));},
removeListener: function(eventType, handler) {
this.removeListenerFrom(this.listeners, eventType, handler);},
removeAcuteListener: function(handler) {
this.removeListenerFrom(this.acuteListeners, '__ALL_EVENTS__', handler);},
removeUniversalListener: function(eventType, handler) {
this.removeListenerFrom(com.liquidpixels.application._UniversalListeners, eventType, handler);},
observe: function(eventType, object) {
if(object && object.EventManageable) {
(object.EventManageable).addListener(eventType, this);
} else {
this.addUniversalListener(eventType);}},
addEventClass: function(eventType, eventClass) {
this.events.set(eventType, eventClass);},
removeEventClass: function(eventType) {
this.events.unset(eventType);},
addHandler: function(eventType, handler) {
this.handlers.set(eventType, handler);},
addHandlers: function(handles) {
$H(handles).each(function(pair) {
this.addHandler(pair.key, pair.value);});},
removeHandler: function(eventType) {
return ( this.handlers.unset(eventType) );},
getHandler: function(eventType) {
return ( this.handlers.get(eventType) );},
handle: function(e) {
if(e.ignore) { return; }
var fn = this.handlers.get(e.type);
if(typeof(fn) === "function") {
fn(e);}},
report: function(e) {
_console.debug("Event: %o (%o) on %o (%s)", e.type, e, e.target, e.description);},
notify: function(e) {
this.handle(e);},
prepareExportList: function($super) {
$super(['listeners', 'events', 'handling', 'acuteListeners',
'dispatch', 'dispatchUniversal', 'dispatchRegistered',
'broadcastTo', 'addListenerTo', 'removeListenerFrom',
'addListener',  'addUniversalListener', 'addAcuteListener',
'addListeners', 'addUniversalListeners',
'removeListener', 'removeUniversalListener', 'removeBlindEventListener',
'removeAcuteListener',
'observe', 'addEventClass', 'removeEventClass',
'addHandler', 'removeHandler', 'getHandler',
'handle', 'report', 'notify',
'exceptions', 'getException', 'throwException', 'addLegacySet', 'destroyListeners'
]);},
addLegacySet: function() {
this.target.dispatchEvent = this.dispatch.bind(this);
this.target.addEventListener = this.addListener.bind(this);
this.target.addEventListeners = this.addListeners.bind(this);
this.target.removeEventListener = this.removeListener.bind(this);
this.target.removeBlindEventListener = this.removeUniversalListener.bind(this);
this.target.dispatchBlindEvent =  this.dispatchUniversal.bind(this);
this.target.addBlindEventListener =  this.addUniversalListener.bind(this);
this.target.addUIEventHandler = this.addHandler.bind(this);
this.target.handleUIEvent = this.handle.bind(this);
this.target.reportUIEvent = this.report.bind(this);
this.target.notifyEvent = this.notify.bind(this);},
destroyListeners: function(){
var uListerners = this.universalListeners.clone();
uListerners.each(function(pair){
pair.value.each(function(o,i){
this.removeUniversalListener(pair.key, o.handler);
}.bind(this));
}.bind(this));
var localListeners = this.listeners.clone();
localListeners.each(function(pair){
pair.value.each(function(o,i){
this.removeListener(pair.key, o.handler);
}.bind(this));
}.bind(this));
var acuteListeners = this.acuteListeners.clone();
acuteListeners.each(function(pair){
pair.value.each(function(o,i){
this.removeAcuteListener(o.handler);
}.bind(this));
}.bind(this));},
clearEvents: function($super) {
this.destroyListeners();
$super();},
toString: function() {
return "com.liquidpixels.application.EventManageable";}});
com.liquidpixels.event.EventDispatcher.makeDispatcher = function(target, options) {
com.liquidpixels.Mixable.applyTo(target, com.liquidpixels.application.EventManageable, (options || {}));
target.EventManageable.addLegacySet();
target.EventManageable.prepare();};
com.liquidpixels.event.EventManageable.applyTo = function(target, options) {
com.liquidpixels.Mixable.applyTo(target, com.liquidpixels.application.EventManageable, (options || {}));
target.EventManageable.prepare();};
com.liquidpixels.viewers.shared.Application = Class.create( {
status:			undefined,  // Status object (optional)
dombody:		undefined,  // the Body Element of the DOM
appPane:		undefined,  // main Pane of the Application
forePane:		undefined,  // Pane that sits just out from Application
delegate:		undefined,
d:				undefined,  // alias to delegate
started:		undefined,
values:			undefined,  // holds named stuff (one-layer abstraction from this)
initialize: function(delegate) {
this.values = {};
this.resources = new Hash();
this.setDelegate(delegate);
try {
if (document.loaded){
setTimeout(function(){
this.handleDomLoaded();
}.bind(this),5);
}else{
document.observe("dom:loaded", this.handleDomLoaded.bind(this));}
} catch(e) {
this.catchException(e);}},
start: function() {
this.handleDomLoaded();},
handleDomLoaded: function(e) {
if(this.started) { return; }
this.started = true;
this.domhead = window.document.getElementsByTagName('head')[0];
var bodies = window.document.getElementsByTagName('body');
if(bodies.length) {
this.dombody = bodies[0];
} else {
var framesets = window.document.getElementsByTagName('frameset');
if(framesets.length) {
this.dombody = framesets[0];
} else {
this.dombody = window.document.createElement('body');
htmls[0].appendChild(this.body);}}
var paneOpts = {};
var foreOpts = {};
if(this.get('ApplicationPaneIncID')) {
paneOpts.incID = this.get('ApplicationPaneIncID');
} else if(prototype$('_application_pane')) {
paneOpts.incID = '_application_pane';
} else {
paneOpts.id = this.get('ApplicationPaneID') || '_application_pane';}
if(this.get('ApplicationForeIncID')) {
foreOpts.incID = this.get('ApplicationForeIncID');
} else if(prototype$('_application_fore')) {
foreOpts.incID = '_application_fore';
} else {
foreOpts.id = this.get('ApplicationForeID') || '_application_fore';}
this.appPane = new com.liquidpixels.wui.Pane(this, paneOpts);
this.forePane = new com.liquidpixels.wui.Pane(this, foreOpts);
this.dombody.appendChild(this.appPane.element);
this.dombody.appendChild(this.forePane.element);
if($DEF(this.delegate)) {
this.delegate.autoconfig();
} else {
if( !this.get('empty') ) {
throw new com.liquidpixels.application.Exception.DelegateNotDefined();}}},
catchException: function(e) {
_console.log("Application got uncaught Exception: '%o' %o", e.message, e);},
getFore: function() {
return ( this.forePane );},
getBody: function() {
return ( this.appPane );},
getPane: function() {
return ( this.appPane );},
getStatus: function() {
return this.status;},
setStatus: function(status) {
this.status = status;},
doStatus: function() { // (method, params)
var params = $A(arguments);
var method = params.shift();
if(this.status && this.status[method]) {
this.status[method].apply(null, params);
} else {
this.d.statusNonGratis(method, params);}},
append: function(pane) {
this.appPane.appendChild(pane);},
appendChild: function(pane) {
this.appPane.appendChild(pane);},
removeChild: function(pane){
this.appPane.removeChild(pane);},
appendForeChild: function(pane) {
this.forePane.appendChild(pane);},
removeForeChild: function(pane){
this.forePane.removeChild(pane);},
setDelegate: function(d) {
if(this.delegate) {
throw new com.liquidpixels.Exception({
message: "ERR: Delegate already defined.",
target: this});
return;}
this.delegate = new d();
this.d = this.delegate;},
get: function(name, from) {
var dots = name.split(".");
if(dots[1] || dots[1] === 0) {
name = dots[1];
from = dots[0];}
var data;
if(from || from === 0) {
if(this.values[from] && typeof(this.values[from]) == 'object') {
data = this.values[from][name];}
} else {
data = this.values[name];}
return data;},
set: function(name, val, into) {
var dots = name.split(".");
if(dots[1] || dots[1] === 0) {
name = dots[1];
into = dots[0];}
if(into || into === 0) {
if(!this.values[into]) { this.values[into] = {};}
this.values[into][name] = val;
} else {
this.values[name] = val;}},
unset: function(name, from) {
var dots = name.split(".");
if(dots[1] || dots[1] === 0) {
name = dots[1];
from = dots[0];}
var prev;
if(from || from === 0) {
if(this.values[from] && typeof(this.values[from] == "object")) {
prev = this.values[from][name];
this.values[from][name] = null;}
} else {
prev = this.values[name];
this.values[name] = null;}
return prev;},
extend: function(values, into) {
var vals;
if(typeof(values) != "object") { return; }
if(into || into === 0) {
$H(values).each(function(p) {
this.set(p.key, p.value, into);
}.bind(this));
} else {
Object.extend(this.values, values);}},
setQueryParams: function(querystr, into) {
into = into || "queryParams";
var qvals = querystr.toString().toQueryParams();
if(!this.values[into]) { this.values[into] = {}; }
Object.extend(this.values[into], qvals);},
configure: function() {
com.liquidpixels.application.Config.apply();},
buildURL: function(source, params){
if (params){
var first = true;
var h = $H(params);
if (source.indexOf('?') != -1){
first = false;}
h.each(function(pair){
if (first){
source += "?";
first = false;
}else{
source += "&";}
source += pair.key + "=" + pair.value;});}
return source;},
addScript: function(source,e,params) {
var script = window.document.createElement('script');
script.type = 'text/javascript';
script.src = this.buildURL(source,params);
if (e){
script.onload = e;}
this.domhead.appendChild(script);},
setRSLoaderPath: function(rsLoaderPath) {
this.rsLoaderPath = rsLoaderPath;},
addJSR: function(source, e, params){
var rsLoader = this.rsLoaderPath;
if (rsLoader){
var loadedJSRs = com.liquidpixels.ResourceServer.Loaded.JSR;
var src = rsLoader + "?rsLoad=" + source;
src = this.buildURL(src,params);
$H(loadedJSRs).each(function(p) {
src += "&rsPreloaded=" + p.key;});
this.addScript(src,e);
} else {
throw new com.liquidpixels.Exception({
message: "ERR: No rsLoader present.",
target: this});}}});
com.liquidpixels.application.Config.apply = function() { /* VIRTUAL */ };
com.liquidpixels.query.Query = Class.create(com.liquidpixels.Basic, {
callOpts:		undefined,
threwException: undefined,
requestObject:	undefined,
parser:			undefined,
initialize:	function ($super, options) {
$super(null, options);
if(this.options.src) {
this.setSrc(this.options.src);}
this.createParser();},
createParser: function() {
if(this.options.parser) {
this.parser = this.options.parser;}},
setDefaults: function() {
Object.extend(this.options, {
method: 'get',
encoding: '',
asynchronous: true,
src:		'',
statusLock:	'',	// used in virtual functions
statusText:	'', // used in virtual functions
create:	    this.queryCreate.bind(this),
success:	this.querySuccess.bind(this),
failure: 	this.queryException.bind(this),
complete:	this.queryComplete.bind(this),
exception:	this.queryException.bind(this),
params:		{},	// pass here, in the src, or during request()
parser:		undefined,
format:		'xml'});},
queryException: function(r, e) {
this.threwException = true;
var message = (e ? (e.message || r.message) : r.message);
message = "com.liquidpixels.query.Query Exception: " + message;
throw new com.liquidpixels.query.Exception({
message: message,
error:	e,
response: r});},
queryCreate:	function(o) { /* empty */ },
querySuccess:	function(o) { /* empty */ },
queryComplete:	function(o) { /* empty */ },
// fires for all 200 codes, even if xml not-well-formed, etc.
onSuccess: function(r) {
this.clearStatus(r);
this.options.success(r);},
onCreate: function(r) {
this.clearStatus(r);
this.options.create(r);},
onFailure: function(r) {
this.clearStatus(r);
this.options.failure(r);},
onException: function(r,e) {
this.clearStatus(r, e);
this.threwException = true;
if(this.parser) {
this.parser.onException(r, e);
} else {
this.options.exception(r, e);}},
onComplete: function(r) {
if(this.threwException) { return; }
this.clearStatus(r);
if(this.parser) {
this.parser.onComplete(r);
} else {
this.options.complete(r);}},
_doRequest: function(params, statusData) {
var pset = {};
if(params && params.toObject){
params = params.toObject();}
if(this.options.params && this.options.params.toObject){
this.options.params = this.options.params.toObject();}
Object.extend(pset, this.options.params);
Object.extend(pset, params);
if(statusData) {
this.setStatus(statusData);}
this.prepareCallOpts(pset);
this.requestObject = new Ajax.Request(this.src, this.callOpts);},
request: function(params, statusData) { this._doRequest(params, statusData)},
abort: function(){
if (this.requestObject && this.requestObject.transport && this.requestObject.transport.abort){
this.requestObject.transport.abort();}},
makeAjaxCall: function(params, statusData) { this.request(params, statusData) },
load: function(params, statusData) { this.request(params, statusData) },
postRequest: function(body, statusData) {
this.options.postBody = body;
this._doRequest({}, statusData);},
prepareCallOpts: function(params) {
var list = Array('method', 'encoding', 'asynchronous', 'postBody',
'contentType', 'encoding', 'requestHeaders', 'evalJS',
'evalJSON', 'sanitizeJSON');
var callOpts = {
onCreate: 		this.onCreate.bind(this),
onSuccess: 		this.onSuccess.bind(this),
onComplete: 	this.onComplete.bind(this),
onException: 	this.onException.bind(this),
onFailure:	 	this.onFailure.bind(this),
parameters: 	params};
options = this.options;
list.each(function(o,i) {
if($DEF(options[o])) {
callOpts[o] = options[o];}});
this.callOpts = callOpts;},
isAsynchronous: function() {
return !!(this.options.asynchronous);},
setSrc: function(src) {
this.src = src;},
setStatus: function(r, data) { /* VIRTUAL */ },
clearStatus: function(r, data) { /* VIRTUAL */ },
toString: function() { return "com.liquidpixels.query.Query"}});
com.liquidpixels.query.Parser = Class.create(com.liquidpixels.Basic, {
handlers:	undefined,
response:	undefined,
dataType:	undefined,
document:	undefined,
initialize: function($super, options) {
$super(null, options);
this.prepareHandlers();},
setDefaults: function() {
Object.extend(this.options, {
verbose:	false,
format:		'xml'});},
prepareHandlers: function() {
this.handlers = {
image:		this.imageResponseHandler.bind(this),
json:		this.jsonResponseHandler.bind(this),
xml:		this.xmlResponseHandler.bind(this),
text:		this.textResponseHandler.bind(this),
unknown:	this.unknownResponseHandler.bind(this)};},
onComplete: function(r) {
this.parse(r);},
parse: function(r) {
this.response = r;
this.calcDataType(r);
var handler = this.handlers[this.dataType];
handler(r);},
onException: function(r, e) {
throw new com.liquidpixels.query.Exception({
message: r.message,
error:	e});},
calcDataType: function(r) {
var contentType = (r ? r.getHeader('Content-Type') : this.options.format);
var dataType;
if(contentType) {
$H(this.handlers).each(function(p){
var ty = p.key;
if(contentType.match(ty)) {
dataType = ty;
return;}});}
if(dataType) {
this.dataType = dataType;
} else {
if(r.responseXML && r.responseXML.documentElement) {
this.dataType = "xml";
} else if(r.responseJSON) {
this.dataType = "json";
} else if(r.responseText) {
this.dataType = "text";
} else {
this.dataType = "unknown";}}},
xmlResponseHandler: function(r) {
if(this.options.verbose) {_console.debug("xml response: '%o'", r);}
this.document = r.responseXML.documentElement;
this.xmlParse(this.document);},
jsonResponseHandler: function(r) {
if(this.options.verbose) {_console.debug("json response: '%o'", r);};
this.document = r.responseJSON;
this.jsonParse(this.document);},
textResponseHandler: function(r) {
this.document = r.responseText;
_console.debug("text response: '%o'", this.data);},
unknownResponseHandler: function(r) {
_console.debug("unknown response: '%o'", r);},
imageResponseHandler: function(r) {
_console.debug("Image Handler (not defined)");},
xmlParse: function(xmlDoc) { /* VIRTUAL */ },
jsonParse: function(jsonDoc) { /* VIRTUAL */ }});
com.liquidpixels.wui.UIEvent = Class.create(com.liquidpixels.wui.Event, {
parameters:	undefined,
initialize: function($super, type, options) {
this.type = 'WUI.UIEvent';
$super(type, options);
delete(options.target);
delete(options.UAevent);
this.parameters = {};
Object.extend(this.parameters, options);}});

com.liquidpixels.wui.Stylable = Class.create(com.liquidpixels.Mixable, {
styleObj:			undefined,
addFuncs:			undefined,  // hash of functions to use to add...
remFuncs:			undefined,  // hash of functions to use to remove...
currentState:		undefined,
styleSet:			undefined,
oldSrc:				undefined,
initialize: function($super, options) {
$super(options);
this.setupFuncs();},
setDefaults: function() {
this.mixName = 'Stylable';},
prepare: function() {
this.styleObj = this.options.style;},
setupFuncs: function() {
this.remFuncs = $H({
cssClass:		this.options.removeCssClass || this.removeCssClass.bind(this),	// string
cssStyle:		this.options.removeCssStyle || this.removeCssStyle.bind(this),	// {}
value:			this.options.removeValue || this.removeValue.bind(this),	// Hash??
src:			this.options.removeSrc || this.removeSrc.bind(this),	// string || Chain
uic:			this.options.removeUIC || this.removeUIC.bind(this)		// UIComponent
});
this.addFuncs = $H({
cssClass:		this.options.addCssClass || this.addCssClass.bind(this),	// string
cssStyle:		this.options.addCssStyle || this.addCssStyle.bind(this),	// {}
value:			this.options.addValue || this.addValue.bind(this),	// Hash??
src:			this.options.addSrc || this.addSrc.bind(this),	// string || Chain
uic:			this.options.addUIC || this.addUIC.bind(this)		// UIComponent
});},
applyStyle: function(styleName, target) {
this.Stylable.switchState(styleName, target);},
getStates: function() {
var styleStates = $H(this.styleObj.getStates()).keys();
return styleStates;},
switchState: function(name, target) {
if(!target) { target = this.target };
var style = this.getState(name);
var dontRevokeState = false;
if (style){
dontRevokeState = style.noRevoke || false;}
if(this.currentState && !dontRevokeState) {
this.revokeState(this.currentState, target);}
this.applyState(name, target);},
applyState: function(name, target) {
var style = this.getState(name);
if(style) {
(this.addFuncs).each(function(pair) {
if($DEF(style[pair.key])) {
pair.value(style, target);}});
this.currentState = name;
if(style.onApply) {
style.onApply(style, target);}}},
revokeState: function(name, target) {
var style = this.getState(name);
if(style) {
(this.remFuncs).each(function(pair) {
if($DEF(style[pair.key])) {
pair.value(style, target);}});
if(this.currentState === name) { this.currentState = null };
if(style.onRevoke) {
style.onRevoke(style, target);}}},
getState: function(name) {
var style;
if(name) {
style = this.styleObj.getState(name);
} else {
style = this.styleObj.getDefaultState();}
return style;},
addCssClass: function(style, target) {
if(!target) { target = this.target };
target.addClassName(style.cssClass);},
removeCssClass: function(style, target) {
if(!target) { target = this.target };
target.removeClassName(style.cssClass);},
addCssStyle: function(style, target) {
if(!target) { target = this.target };
target.setStyle(style.cssStyle);},
removeCssStyle: function(style, target) {
if(!target) { target = this.target };
var currentStyles = target.getStyles();
$H(style.cssStyle).each(function(p) {
currentStyles.unset(p.key);});
target.setStyle(currentStyles);},
addValue: function(style, target) {
if(!target) { target = this.target };
var value = style.value;
if(target[value.method]) {
target[value.method](value.value);
} else {
target.setValue(value.value);}},
removeValue: function(style, target) {},
addSrc: function(style, target) {
if(!target) { target = this.target };
this.oldSrc = target.getSrc();
target.setSrc(style.src);},
removeSrc: function(style, target) {
if(!target) { target = this.target };
target.setSrc(this.oldSrc);},
addUIC: function(style, target) {
if(!target) { target = this.target };
target.setContent(style.uic);},
removeUIC: function(style, target) {},
prepareExportList: function($super) {
$super([
'applyState', 'revokeState', 'switchState',
'currentState', 'getState', 'getCurrentState',
'styleObject', 'addFuncs', 'remFuncs',
'addCssClass', 'removeCssClass',
'addCssStyle', 'removeCssStyle',
'addValue', 'removeValue',
'addSrc', 'removeSrc',
'addUIC', 'removeUIC',
'getStates'
]);},
prepareOverridesList: function($super) {
$super(['applyStyle']);}});
com.liquidpixels.wui.UIComponent = Class.create(com.liquidpixels.Basic, {
id:						undefined,
element:				undefined,
visualStates:			undefined,
currentVisualState:		undefined,
enabled:				undefined,  // can mouse
visible:				undefined,  // can see
posX:					undefined,
posY:					undefined,
width:					undefined,
height:					undefined,
preLoadedIntoDOM:		undefined,
notAppendable:			undefined, // easy check...
initialize: function($super, parent, options) {
this.options = {
tagType:			'div',
uicNspace:			'uic_',
visible:			true,
defaultCssClass:	''};
$super(parent, options);
if(typeof com.liquidpixels.wui._UIComponent == 'undefined') {
com.liquidpixels.wui._UIComponent = {
elements:	new Hash(),
id:			0,
counted:	0};}
if(this.options.id) {
this.id = this.options.id;
if( com.liquidpixels.wui._UIComponent.elements.get(this.id) ) {
this.errorBadID();
return;
} else if( this.options.element ) {
if(this.options.element.id && prototype$(this.options.element.id) ) {
this.preLoadedIntoDOM = true;}
this.element = this.options.element;
if (this.id != this.options.element.id) {
this.element.setAttribute("id", this.id);}
} else {
if( prototype$(this.options.id) ) {
this.errorBadElement();
return;
} else {
this.element = this._createElement();}}
} else if(this.options.incID) {
this.id = this.options.incID;
this.element = prototype$(this.id);
this.preLoadedIntoDOM = true;
if( !this.element ) {
this.errorIncID();}
} else { // no id
this.id = this.makeID();
if( prototype$(this.id) ) {
this.errorBadElement();
return;}
if(this.options.element) {
this.element = this.options.element;
this.preLoadedIntoDOM = true;
this.element.setAttribute("id", this.id);
} else {
this.element = this._createElement();}}
com.liquidpixels.wui._UIComponent.elements.set(this.id, this);
com.liquidpixels.wui._UIComponent.counted++;
if(!this.element) { return; }
var theSrc = this.options.imgSrc || this.options.src;
if(theSrc) { this.setSrc(theSrc); }
this.setStyle(this.options.cssStyle);
if(this.options.defaultCssClass) {
this.setCssClass(this.options.defaultCssClass);}
if(this.options.cssClass) {
this.addClassName(this.options.cssClass);}
this.setAttributes(this.options.attributes);
this.prepareElement();
this.prepareVisible();
this.prepareEnabled();
this.visualStates = this.options.visualStates || {};
if(this.preLoadedIntoDOM) {
this.postAppendChild();}
var domParent = this.options.domParent;
if(domParent) {
if(this.preLoadedIntoDOM) {
if(domParent.incChild) {
domParent.incChild(this);}
} else {
if(domParent.appendChild) {
domParent.appendChild(this);}}}
return;},
initializeSpecific: function() { /* VIRTUAL */ },
// ALWAYS call this as $super in your subclasses or provide the info.
setDefaults:	function() { /* VIRTUAL */ },
makeID: function() {
return this.options.uicNspace + com.liquidpixels.wui._UIComponent.id++;},
setSrc: function(src) {
this.setAttribute('src', src);},
_createElement: function() {
var el;
var builder;
if(this.ElementBuilder) {
builder = this.ElementBuilder;
} else if (this.parent && this.parent.ElementBuilder) {
builder = this.parent.ElementBuilder;}
if(builder && !this.ignoreElementBuilder) {
var btype = typeof(builder);
if(btype === "function" ) {
el = builder();
} else if(btype === "object") {
el = builder.createElement();}}
if(this.parent &&
this.parent.createElement &&
!this.parent.ignoreParentCreateElement &&
typeof(this.parent.createElement) == "function") {
el = this.parent.createElement(this);}
if(!el) { el = this.createElement(this); }
return el;},
createElement: function(thingy) {
var el = new Element(thingy.options.tagType, {
id: thingy.id});
return el;},
postAppendChild: function() { /* VIRTUAL */ },
wasPreloadedIntoDOM: function() {
return  !!( this.preLoadedIntoDOM );},
prepareElement: function() {},
prepareVisible: function() {
if(this.options.visible) {
this.visible = true;
} else {
this.visible = false;
this.setVisible(this.visible);}},
prepareEnabled: function() {
this.enabled = $NVL(this.options.enabled, true);},
setAttribute: function (attrib, value) {
if($DEF(value)) {
this.element.setAttribute(attrib, value);}},
setAttributes: function(attHash) {
if(attHash) {
$H(attHash).each(function(o) {
if($DEF(o.value)){
this.element.setAttribute(o.key, o.value);}
}.bind(this));}},
getAttribute: function (attrib) {
return this.element.readAttribute(attrib);},
removeAttribute: function(attrib){
this.element.removeAttribute(attrib);},
removeAttributes: function(arr) {
if(arr) {
$A(arr).each(function(o) {
if($DEF(o)){
this.element.removeAttribute(o);}
}.bind(this));}},
getValues: function() {	},
setMetadataItem: function(object){
Element.store(this.element, object);},
getMetadataItem: function(key){
return Element.retrieve(this.element, key);},
getMetadata: function(){
return Element.getStorage(this.element);},
makeUnselectable: function() {
this.element.onselectstart = function() { return false; };
this.element.style.MozUserSelect = "none";
this.element.style.KhtmlUserSelect = "none";
this.element.unselectable = "on";},
getDimensions: function() {
return this.element.getDimensions();},
getOffsetPosition: function() {
return this.element.positionedOffset();},
setPosition: function(left, top, opts) {
var vals = this.updatePositionValues(left, top, opts);
this.setStyle(vals);},
updatePositionValues: function(left, top, opts) {
var vals = {};
if(left || left === 0) {
if(!(opts && opts.tweening)) {
this.posX = left;}
vals.left = left + "px";}
if(top || top === 0) {
if(!(opts && opts.tweening)) {
this.posY = top;}
vals.top = top + "px";}
return vals;},
getPosition: function() {
var pos = {
left:	this.posX,
top:	this.posY,
x:		this.posX,
y:		this.posY};
return pos;},
setSize: function(w,h,opts) {
var style = {};
opts = opts || {};
if(w || w === 0) {
if(!opts.tweening) { this.width  = w; }
style.width = w + "px";}
if(h || h === 0) {
if(!opts.tweening) { this.height = h; }
style.height = h + "px";}
this.setStyle(style);},
getSize: function() {
var dims = {
width:	this.width,
height:	this.height};
return dims;},
resize: function(scale) {
if(this.height) { // skips 0, too
this.height *= scale;}
if(this.width) {
this.width *= scale;}},
reposition: function(addX, addY) {
this.posX += addX;
this.posY += addY;},
appendChild: function(child) {
var thingy = child;
if(typeof child == "object" && child.element) {
thingy = child.element;}
this.element.insert(thingy);},
appendValue: function(value) {
this.appendChild(value);},
setValue: function(content) {
this.element.update(content);},
getValue: function() {
return this.element.innerHTML;},
destroyChildren: function() {
var inner = this.element.innerHTML;
this.element.update();
return inner;},
removeChildren: function() { return this.destroyChildren(); },
setStyle: function(style) {
var typeofStyle = typeof(style);
if(typeofStyle == 'string') {
this.setAttribute("style", style);
} else if(typeofStyle == 'object') {
this.element.setStyle(style);
} else {}},
setCssClass: function(css) {
this.setAttribute("class", css);},
getStyle: function (attrib) {
return this.element.getStyle(attrib);},
getStyles: function() {
var cssStyle = this.element.style;
var styles = new Hash();
for(var i = 0; i < cssStyle.length; i++) {
var key = cssStyle.item(i);
styles.set(key, cssStyle.getPropertyValue(key));}
return styles;},
addClassName: function(className) {
this.element.addClassName(className);},
hasClassName: function(className) {
return this.element.hasClassName(className);},
removeClassName: function(className) {
this.element.removeClassName(className);},
removeClassNames: function(classNames) {
$A(classNames).each(function(name,i){
this.removeClassName(name);
}.bind(this));},
errorBadElement: function(elm) {
throw new com.liquidpixels.Exception({
message: "ERR: This element in use; must destroy it first: '" + this.id + "'",
target: this});},
errorBadID: function() {
throw new com.liquidpixels.Exception({
message: "ERR: This id in use; must destroy it first: '" + this.id+ "'",
target: this});},
errorIncID: function() {
throw new com.liquidpixels.Exception({
message: "ERR: This include not found: '" + this.id+ "'",
target: this});},
getVisible: function() {
return ( this.visible );},
isVisible: function() { return this.getVisible(); },
setVisible:  function(isVisible) {
if(isVisible) {
this.show();
} else {
this.hide();}},
addTip: function(content, title, options){
try{
return this.element.addTip(content, title, options);
}catch(e){
new com.liquidpixels.Exception({
message: e.type + ' - Opentip is not installed correctly',
target: this});}},
show: function() {
this.element.show();
this.visible = true;
return this.element;},
hide: function() {
this.element.hide();
this.visible = false;
return this.element;},
fade: function(opts) {
Effect.Fade(this.element, opts);
this.visible = false;},
appear: function(opts) {
Effect.Appear(this.element, opts);
this.visible = true;},
getEnabled: function() {
return ( this.enabled );},
isEnabled: function() { return this.getEnabled(); },
enable: function() {
this.setEnabled(true);},
disable: function() {
this.setEnabled(false);},
setEnabled: 	function(isEnabled) { /* VIRTUAL */ },
isLocked: function() {
if( this.options.lockOnStatus && (typeof(Application) !== 'undefined') && Application.status && Application.status.isBusy() ) {
return true;
} else {
return ( !this.enabled );}},
setLockOnStatus: function(val) {
this.options.lockOnStatus = !!(val);},
update: 		function() { },
clearEvents: function() { /* VIRTUAL */ },
// Handles ['CLR', 'SET', 'OVR', 'SOV', 'DWN', 'SDW']
applyStyle: function(styleState) {
var cssOver = this.options.cssOver || 'selOver';
var cssSel = this.options.cssSelected || 'selected';
switch(styleState) {
case "OVR":
Element.addClassName(this.element, cssOver);
break;
case 'DWN':	case 'SDW':
Element.addClassName(this.element, cssSel);
break;
case 'SOV':
Element.addClassName(this.element, cssSel);
Element.addClassName(this.element, cssOver);
break;
case 'SET':
Element.addClassName(this.element, cssSel);
Element.removeClassName(this.element, cssOver);
break;
default: // CLR...
Element.removeClassName(this.element, cssSel);
Element.removeClassName(this.element, cssOver);}},
DESTROY: 		function() {
this.clearEvents();
com.liquidpixels.wui._UIComponent.elements.unset(this.id);
var u = prototype$(this.id) || this.element;
if( u && u.parentNode ) {
u.parentNode.removeChild(u);}
this.element = null;
return this;},
toHTML: function(opts) {
if(!opts) {opts = {}};
var html = com.liquidpixels.wui.UIComponent.elementToHTML(this.element, opts);
return html;},
getNodeName: function() {
return this.element.nodeName;},
toString: function() { return 'com.liquidpixels.wui.UIComponent'; }});
com.liquidpixels.wui.UIComponent.destroy = function(uic) {
if(uic.DESTROY)
uic.DESTROY();
uic = null;};
com.liquidpixels.wui.UIComponent.getCurrentCount = function() {
var cnt = com.liquidpixels.wui._UIComponent.elements.keys().length;
return cnt;};
com.liquidpixels.wui.UIComponent.getCreatedCount = function() {
var cnt = com.liquidpixels.wui._UIComponent.counted;
return cnt;};
com.liquidpixels.wui.UIComponent.getElement = function(uid) {
return ( com.liquidpixels.wui._UIComponent.elements.get(uid) );};
var $UIC = function (parent, type, id, cssClass, value) {
var opts = {};
if(type) { opts.tagType = type; }
if(id) { opts.id = id; }
if(cssClass) { opts.cssClass = cssClass; }
var u = new com.liquidpixels.wui.UIComponent(parent, opts);
if($DEF(value)) { u.setValue(value) };
return u;};
com.liquidpixels.wui.UIComponent.elementToHTML = function(elemOrID, opts) {
var element = (typeof(elemOrID) == 'string' ? $(elemOrID) : elemOrID);
opts = opts || {};
var nodeName = (opts.nodeName || element.nodeName);
var html = '<' + nodeName;
$A(element.attributes).each(function(o,i) {
var name = o.nodeName;
var val = $NVL(o.nodeValue, "").toString();
if(val != "" && (opts.keepFunctions || !val.match("^function()"))) {
html += ' ' + name + '="' + val + '"';}});
if(opts.closing == 'slash') {
html += ' /';
} else if(opts.closing == 'tag') {
html += '</ ' + nodeName;}
html += '>';
return html;};
com.liquidpixels.wui.Gestureable = Class.create(com.liquidpixels.Mixable, {
startX: undefined,
startY: undefined,
mvX: undefined,
mvY: undefined,
offX: undefined,
offY: undefined,
mouseStarted: undefined,
events: undefined,
dragging: undefined,
dragged: undefined,
setDefaults: function () {
Object.extend(this.options, {
useMouse: true,
forceMouse: false,
useTouch: true,
useGestures: true,
startOnOver: false,
passthroughEvents: false});
this.mixName = 'Gestureable';
this.userAgent = $UAQ();},
prepare: function () {
this.events = [];
this.prepareOffSets();
this.prepareSpecialCases();
if (this.options.useMouse) {
this.prepareForMouse();}
if (this.options.useTouch) {
this.prepareForTouch();}
if (this.options.useGestures) {
this.prepareForGestures();}},
prepareOffSets: function () {
this.offX = this.options.offsetX;
this.offY = this.options.offsetY;},
prepareSpecialCases: function () {
if (this.userAgent.android && !this.userAgent.modern && !this.options.forceMouse) {
this.options.useMouse = false;}},
prepareForMouse: function () {
var item = this.target.element;
Event.observe(item, 'mouseout', this.mouseOut.bind(this), false);
Event.observe(item, 'mouseup', this.mouseUp.bind(this), false);
Event.observe(item, 'mousedown', this.mouseDown.bind(this), false);
Event.observe(item, 'mousemove', this.mouseMove.bind(this), false);
if (this.options.startOnOver) {
Event.observe(item, 'mouseover', this.mouseOver.bind(this), false);
this.events.push('mouseover');}
this.target.setAttribute('unselectable', 'on');
this.events.push('mouseout', 'mouseup', 'mousedown', 'mousemove');},
prepareForTouch: function () {
var item = this.target.element;
Event.observe(item, 'touchstart', this.touchStart.bind(this), false);
Event.observe(item, 'touchmove', this.touchMove.bind(this), false);
Event.observe(item, 'touchend', this.touchEnd.bind(this), false);
Event.observe(item, 'touchcancel', this.touchCancel.bind(this), false);
this.events.push('touchstart', 'touchmove', 'touchend', 'touchcancel');},
prepareForGestures: function () {
var item = this.target.element;
Event.observe(item, 'gesturestart', this.gestureStart.bind(this), false);
Event.observe(item, 'gesturechange', this.gestureMove.bind(this), false);
Event.observe(item, 'gestureend', this.gestureEnd.bind(this), false);
this.events.push('gesturestart', 'gesturechange', 'gestureend');},
collectMouseStart: function (e) {
this.startX = e.clientX;
this.startY = e.clientY;},
collectMouseMove: function (e) {
this.mvX = e.clientX;
this.mvY = e.clientY;},
getStart: function (which) {
if (which === 'x') {
return this.startX;
} else if (which === 'y') {
return this.startY;
} else {
return {
x: this.startX,
y: this.startY};}},
getDelta: function (which) {
if (this.mouseStarted) {
return this.getMoveFromStart(which);
} else {
return this.getMove(which);}},
getMove: function (which) {
if (which === 'x') {
return this.mvX;
} else if (which === 'y') {
return this.mvY;
} else {
return {
x: this.mvX,
y: this.mvY};}},
getMoveFromStart: function (which) {
if (which === 'x') {
return this.mvX - this.startX;
} else if (which === 'y') {
return this.mvY - this.startY;
} else {
return {
x: this.mvX - this.startX,
y: this.mvY - this.startY};}},
mouseOver: function (e) {
if (!this.options.passthroughEvents) {
Event.stop(e);}
if (this.options.startOnOver) {
this.mouseStarted = true;
this.collectMouseStart(e);
if (this.options.actionOnStart) {
this.options.actionOnStart(e);}}
return false;},
mouseDown: function (e) {
if (!this.options.passthroughEvents) {
Event.stop(e);}
if (!this.options.startOnOver) {
this.mouseStarted = true;}
this.mouseIsDown = true;
this.collectMouseStart(e);
if (this.options.startOnOver && this.options.actionOnDown) {
this.options.actionOnDown(e);}
if (!this.options.startOnOver && this.options.actionOnStart) {
this.options.actionOnStart(e);}
return false;},
mouseMove: function (e) {
if (!this.options.passthroughEvents) {
Event.stop(e);}
if (!this.mouseStarted) {
return false;}
this.collectMouseMove(e);
var delta = this.getDelta();
if (!(this.userAgent.ie && this.userAgent.verMajor <= 10) || (delta.x !== 0 && delta.y !== 0)) {
if (this.mouseIsDown) {
this.dragging = true;}
if (this.options.actionOnMove) {
this.options.actionOnMove(e);}
}else {}
return false;},
mouseUp: function (e) {
if (!this.options.passthroughEvents) {
Event.stop(e);}
this.mouseIsDown = false;
if (this.dragging) {
this.dragging = false;
if (this.options.startOnOver) {
if (this.options.actionOnUp) {
this.options.actionOnUp(e);}
} else {
this.mouseFinish(e);}
} else {
if (!this.options.startOnOver) {
this.mouseStarted = false;}
if (this.options.actionOnClick) {
this.options.actionOnClick(e);}}},
mouseOut: function (e) {
if (this.dragging || this.dragged || this.mouseStarted) {
this.mouseFinish(e);}
return false;},
mouseFinish: function (e) {
this.mouseStarted = false;
this.dragging = false;
if (this.options.actionOnFinish) {
this.options.actionOnFinish(e);}
return false;},
collectTouchStart: function (e) {
var imgLeft = this.posX || 0;
var imgTop = this.posY || 0;
var ecX = e.targetTouches[0].clientX;
var ecY = e.targetTouches[0].clientY;
this.startX = e.targetTouches[0].clientX + imgLeft;
this.startY = e.targetTouches[0].clientY + imgTop;},
collectTouchMove: function (e) {
this.mvX = (e.targetTouches[0].clientX - this.startX);
this.mvY = (e.targetTouches[0].clientY - this.startY);
var ecX = e.targetTouches[0].clientX;
var ecY = e.targetTouches[0].clientY;},
collectScale: function (e) {
return e.scale;},
touchStart: function (e) {
if (!this.options.passthroughEvents) {
Event.stop(e);}
if (this.mouseStarted || this.gestureStarted || this.gestureEnding || e.touches.length !== 1) {
return false;}
this.collectTouchStart(e);
if (this.options.actionTouchStart) {
this.options.actionTouchStart(e);}
return false;},
touchMove: function (e) {
if (!this.options.passthroughEvents) {
Event.stop(e);}
if (this.mouseStarted || this.gestureStarted || this.gestureEnding || e.touches.length !== 1) {
return false;}
this.dragging = true;
this.collectTouchMove(e);
if (this.options.actionTouchMove) {
this.options.actionTouchMove(e);}
return false;},
touchEnd: function (e) {
if (!this.options.passthroughEvents) {
Event.stop(e);}
if (this.mouseStarted || this.gestureStarted || this.gestureEnding) {
return false;}
if (this.dragging || this.dragged) {
this.dragging = false;
if (this.options.actionTouchFinish) {
this.options.actionTouchFinish(e);}
} else {
if (this.options.actionOnPress) {
this.options.actionOnPress(e);}}
return false;},
touchCancel: function (e) {
if (this.options.actionTouchCancel) {
this.options.actionTouchCancel(e);}
return false;},
gestureStart: function (e) {
if (!this.options.passthroughEvents) {
Event.stop(e);}
if (this.mouseStarted || this.gestureStarted) {
return false;}
this.gestureStarted = true;
if (this.options.actionGestureStart) {
this.options.actionGestureStart(e);}
return false;},
gestureMove: function (e) {
if (!this.options.passthroughEvents) {
Event.stop(e);}
if (this.mouseStarted || !this.gestureStarted || this.gestureEnding) {
return false;}
if (this.options.actionGestureMove) {
this.options.actionGestureMove(e);}
return false;},
gestureEnd: function (e) {
if (!this.options.passthroughEvents) {
Event.stop(e);}
if (this.mouseStarted || !this.gestureStarted || this.gestureEnding) {
return false;}
if (this.options.actionGestureEnd) {
this.options.actionGestureEnd(e);}
this.gestureStarted = false;
return false;},
gestureCancel: function (e) {
if (this.options.actionGestureCancel) {
this.options.actionGestureCancel(e);}
return false;},
clearEvents: function () {
$A(this.events).each(this.clearEvent.bind(this));},
clearEvent: function (eventName) {
var item = this.target.element;
Event.stopObserving(item, eventName);},
prepareExportList: function ($super) {
$super(["events", "sOffset", "prepareOffSets", "prepareSpecialCases",
"prepareForTouch", "prepareForGestures", "prepareForMouse",
"collectMouseStart", "collectMouseMove",
"getStart", "getMove", "getMoveFromStart",
"mouseUp", "mouseDown", "mouseOut", "mouseOver",
"mouseMove", "mouseFinish", "mouseClick",
"collectTouchStart", "collectTouchMove", "collectScale",
"gestureStart", "gestureMove", "gestureEnd", "gestureCancel",
"touchStart", "touchMove", "touchEnd", "touchCancel",
"expand", "contract", "getDelta", "userAgent"
]);},
toString: function () {
return "Mixable.Gestureable";}});
com.liquidpixels.wui.Transformable = Class.create(com.liquidpixels.Mixable, {
minX:				undefined,
minY:				undefined,
maxX:				undefined,
maxY:				undefined,
minH:				undefined,
maxH:				undefined,
minW:				undefined,
maxW:				undefined,
posX:				undefined,
posY:				undefined,
mvX:				undefined,
mvY:				undefined,
setDefaults: function($super) {
$super();
Object.extend(this.options, {
maxScale:			2.0,
minScale:			.30,
boundW:				0,
boundH:				0});
this.mixName = 'Transformable';},
prepare: function() {
this.update();
this.ua = $UAQ();
this.transformValues = {
scale: {
x: 1,
y: 1,
str: "scale(1,1)"},
translate: {
x: 0,
y: 0,
str: "translate(0px,0px)"}}},
update: function() {
var pos = this.target.getPosition();
this.posX = pos.left || 0;
this.posY = pos.top || 0;
var dims = this.target.getSize();
this.tgW = dims.width;
this.tgH = dims.height;
this.calcBoundaries();},
calcBoundaries: function() {
var boxW = this.options.boundW;
var boxH = this.options.boundH;
if(this.tgH <= boxH) {
this.minY = 0;
this.maxY = 0; //boxH - this.tgH;
} else {
this.maxY = 0;
this.minY = boxH - this.tgH;}
if(this.tgW <= boxW) {
this.minX = 0;
this.maxX = 0; //boxW - this.tgW;
} else {
this.maxX = 0;
this.minX = boxW - this.tgW;}},
translate: function(x, y, opts) {
var px = this.posX;
var py = this.posY;
var tX = (x || 0) + (px || 0);
var tY = (y || 0) + (py || 0);
var valPos = this.keepBound(tX, tY);
this.mvX = valPos.x;
this.mvY = valPos.y;
if (opts && opts.centered){
this.mvX += opts.centered.x;
this.mvY += opts.centered.y;}
if(opts && opts.tween) {
this.tweenToPosition({ x: this.mvX, y: this.mvY }, opts);
} else {
this.target.setPosition(this.mvX, this.mvY, opts);}},
keepBound: function(x, y) {
var rtn = {};
if(x < this.minX) {
rtn.x = this.minX;
} else if(x > this.maxX) {
rtn.x = this.maxX;
} else {
rtn.x = x;}
if(y < this.minY) {
rtn.y = this.minY;
} else if(y > this.maxY) {
rtn.y = this.maxY;
} else {
rtn.y = y;}
return rtn;},
getBounds: function() {
var rtn = {
maxX:	this.maxX,
maxY:	this.maxY,
minX:	this.minX,
minY:	this.minY};
return rtn;},
normalizeOffset: function(e) {
this.posX = this.mvX;
this.posY = this.mvY;},
setLayout: function(layout, opts) {
if(!layout) { return; }
if(typeof(layout) === "object" ) {
var vpCX = Math.round(this.options.boundW / 2);
var vpCY = Math.round(this.options.boundH / 2);
var nwX = vpCX - layout.x;
var nwY = vpCY - layout.y;
var bnd = this.keepBound(nwX, nwY);
var ptX = bnd.x;
var ptY = bnd.y;
this.posX = ptX;
this.posY = ptY;
} else if(layout === 'center') {
var cp = this.getCenterPosition();
this.posX = cp.x;
this.posY = cp.y;}
if(opts && opts.tween) {
this.tweenToPosition({ x: this.posX, y: this.posY }, opts);
} else {
this.target.setPosition(this.posX, this.posY, opts);
if(opts && opts.afterLayout) {
opts.afterLayout({
target:		this.target,
mixName:	this.mixName,
layout:		layout,
opts:		opts});}}},
getCenterPosition: function() {
var tgSz = this.target.getSize();
var vpCX = Math.round(this.options.boundW / 2);
var vpCY = Math.round(this.options.boundH / 2);
var tgCX = Math.round(tgSz.width / 2);
var tgCY = Math.round(tgSz.height / 2);
var ctr = {
x: 	vpCX - tgCX,
y: 	vpCY - tgCY,
vpX: vpCX,
vpY: vpCY,
tgX: tgCX,
tgY: tgCY}
return ctr;},
getCenteredAt: function(ptx, pty) {
var vpCX = Math.round(this.options.boundW / 2);
var vpCY = Math.round(this.options.boundH / 2);
var tgx = vpCX - (ptx || 0);
var tgy = vpCY - (pty || 0);
var bnd = this.keepBound(tgx, tgy);
return bnd;},
getBoundCenter: function() {
var vpCX = Math.round(this.options.boundW / 2);
var vpCY = Math.round(this.options.boundH / 2);
return { x: vpCX, y: vpCY };},
tweenToPosition: function(values, opts) {
if (!$DEF(opts)){
opts = {};}
var params = {
x:	values.x,
y:	values.y,
mode: 'absolute',
duration: opts.duration || 0.5,
transition: Effect.Transitions[opts.easingFunction] || Effect.Transitions.linear,
afterFinish: function(e) {
this.target.setPosition(values.x, values.y);
if(opts.afterLayout) {
opts.afterLayout({
target:		this.target,
mixName:	this.mixName,
opts:		opts,
values:		values,
UAEvent:	e});}
}.bind(this)};
new Effect.Move(this.target.element, params);},
cssTransformUpdate: function(){
if (this.ua.browser.match(/android/i) && this.ua.deviceVer.match(/^[234]\./i) && !this.ua.modern){
this.transformValues.scale.str = "scale(" + this.transformValues.scale.x + "," + this.transformValues.scale.y + ")";
this.transformValues.translate.str = "translate(" + this.transformValues.translate.x + "px," + this.transformValues.translate.y + "px)";
}else{
this.transformValues.scale.str = "scale3d(" + this.transformValues.scale.x + "," + this.transformValues.scale.y + ", 1)";
this.transformValues.translate.str = "translate3d(" + this.transformValues.translate.x + "px," + this.transformValues.translate.y + "px, 0)";}
var str = this.transformValues.translate.str + " " + this.transformValues.scale.str;
this.target.setStyle({
webkitTransform: str,
mozTransform: str,
msTransform: str,
oTransform: str,
transform: str});},
cssTransformReset: function(){
this.cssTransformScale(1);
this.cssTransformTranslate(0,0);},
cssTransformScale: function(scale) {
var val = $DEF(scale) ? scale : 1;
this.transformValues.scale.x = val;
this.transformValues.scale.y = val;
this.cssTransformUpdate();},
cssTransformTranslate: function(x,y) {
if ($DEF(x)){
this.transformValues.translate.x = x;}
if ($DEF(y)){
this.transformValues.translate.y = y;}
this.cssTransformUpdate();},
cssTransformTranslateX: function(x) {
this.cssTransformTranslate(x, undefined);},
cssTransformTranslateY: function(y) {
this.cssTransformTranslate(undefined, y);},
centerOrigin: function() {
var pos = this.target.getPosition();
var ctr = this.getBoundCenter();
var imgCtrX = ctr.x - pos.left;
var imgCtrY = ctr.y - pos.top;
this.target.setTranformOrigin(imgCtrX, imgCtrY);},
rotate: function(values) {},
transform: function(values) {},
prepareExportList: function($super) {
$super(["viewPort", "update",
"calcBoundaries", "getBoundaries",
"calcScaleLimits", "getScaleLimits",
"mvX", "mvY", "posX", "posY", "transformValues",
"cssTransformReset", "cssTransformUpdate", "cssTransformScale", "cssTransformTranslate", "cssTransformTranslateX", "cssTransformTranslateY","unscale", "scaleTo", "setLayout",
"translate", "rotate", "transform",
"setMinMax", "normalizeOffset",
"keepBound", "tweenToPosition", "getBounds",
"getCenterPosition", "getCenteredAt", "getBoundCenter",
"centerOrigin"
]);}});
com.liquidpixels.wui.Clickable = Class.create(com.liquidpixels.Mixable,  {
state:				undefined, // visual state (string-code)
states:				undefined, // hash of ints representing visuals
selected:			undefined, // is on
value:				undefined, // holds some user-defined meaningful value
enabled:			undefined, // non-responding, (irregardless of visual)
mouseDown:			undefined,
DEBUG:				undefined,
actions: 			undefined,
dragged:			undefined, // ?? bool
dragging:			undefined, // ?? bool
setDefaults: function() {
Object.extend(this.options, {
toggles:			false,
state:				'CLR',
stateLock:			false,
lockOnBusy:			true,
enabled:			true,
visible:			true,
ignoreEvent:		false,
ignoreClickAction:	false,
eventType:			"Clickable.Clicked",
eventDescription: 	["Clickable.Clicked"],
singleClick: 		true,
doubleClick: 		false,
useStateEvents:		[],		// list of ['CLR', 'SET', 'OVR', 'SOV', 'DWN', 'SDW', 'DIS']
stopClickPropagation:    false,
touchEvents:		true,
mouseEvents: 		true});
this.mixName = 'Clickable';},
prepare: function() {
this.enabled = !!(this.options.enabled);
this.prepareActions();
this.prepareStates();
this.prepareEvents();},
prepareActions: function() {
this.actions = {};
if(this.options.actionOnCLR) {
this.actions[CLR] = this.options.actionOnCLR.bind(this);}
if(this.options.actionOnSET) {
this.actions[SET] = this.options.actionOnSET.bind(this);}
if(this.options.actionOnOVR) {
this.actions[OVR] = this.options.actionOnOVR.bind(this);}
if(this.options.actionOnSOV) {
this.actions[SOV] = this.options.actionOnSOV.bind(this);}
if(this.options.actionOnDWN) {
this.actions[DWN] = this.options.actionOnDWN.bind(this);}
if(this.options.actionOnSDW) {
this.actions[SDW] = this.options.actionOnSDW.bind(this);}
if(this.options.actionOnDIS) {
this.actions[DIS] = this.options.actionOnDIS.bind(this);}
if(this.options.actionOnENA) {
this.actions[ENA] = this.options.actionOnENA.bind(this);}},
prepareStates: function() {
this.states = com.liquidpixels.consts.Style.getStates();
if(this.options.useStateEvents) {
$A(this.options.useStateEvents).each(function(o, i) {
this.states[o].event = true;
}.bind(this));}
if(this.options.state && this.states[this.options.state]) {
this.state = this.options.state;
} else {
this.state = 'CLR';}
this.target.applyStyle(this.state);},
isOff: function() {	return !!!(this.selected); },
isOn:  function() { return  !!(this.selected); },
isSelected: function() { return  !!(this.selected); },
isEnabled:  function() { return  !!(this.enabled); },
isDisabled: function() { return !!!(this.enabled); },
enable: function(opts)   { this.setState('ENA', opts); },
disable: function(opts)  { this.setState('DIS', opts); },
select: function(opts)   { this.setState('SET', opts); },
deselect: function(opts) { this.setState('CLR', opts); },
setEnabled:  function(isEna) { this.enabled  = isEna; },
setSelected: function(isSel) { this.selected = isSel; },
lock: function()   { this.options.stateLock = true },
unlock: function() { this.options.stateLock = false },
isStateLocked: function() { return !!(this.options.stateLock) },
setValue: function(value) { this.value = value; },
getValue: function() { return this.value; },
setIgnoreClick: function (ignore) { this.options.ignoreClick = !!(ignore); },
setIgnoreEvent: function (ignore) { this.options.ignoreEvent = !!(ignore); },
setDebug: function(verbose) { this.DEBUG = !!(verbose) },
isActive: function() {
if(this.isDisabled()) {
return false;
} else if(this.options.lockOnBusy && this.isBusy()) {
return false;
} else if(this.options.isBusy && this.options.isBusy()) {
return false;
} else {
return true;}},
getState: function() { return this.state || "";	},
setClick: function(callback) {
this.options.actionOnClick = callback;},
handleOnMouseOut: function(e) {
if(!this.isActive()) { return; }
this.mouseDown = false;
this.setState('mout', {event: e});
if(this.options.actionOnMouseOut) {
this.options.actionOnMouseOut(e);}},
handleOnMouseOver: function(e) {
if(!this.isActive()) { return; }
this.setState('mover', {event: e});
if(this.options.actionOnMouseOver) {
this.options.actionOnMouseOver(e);}},
handleOnMouseDown: function(e) {
if(!this.isActive()) { return; }
this.mouseDown = true;
this.setState('mdown', {event: e});
if(this.options.actionOnMouseDown) {
this.options.actionOnMouseDown(e);}},
handleOnMouseUp: function(e) {
if(!this.isActive()) { return; }
this.setState('mup', {event: e});
if(this.options.actionOnMouseUp) {
this.options.actionOnMouseUp(e);}
if(this.clickInfo && !this.clickInfo.UIEvent.ignoreClick) {
if (this.DEBUG) { this.printClickAction(this.clickInfo.UIEvent); }
this.click(this.clickInfo.UIEvent);}
if(this.clickInfo && !this.clickInfo.UIEvent.ignoreEvent) {
if (this.DEBUG) { this.printEventAction(this.clickInfo.UIEvent); }
this.dispatchEvent(this.clickInfo.UIEvent);}},
handleOnClick: function(e) {
if(!this.isActive()) { return; }
if (this.options.stopClickPropagation){
Event.stop(e);}},
handleDoubleClick: function(e) {
if(!this.isActive()) { return; }
if (this.options.stopPropagation){
Event.stop(e);}
this.setState('dclk', {event: e});
if(this.options.actionOnDoubleClick) {
this.options.actionOnDoubleClick(e);}},
prepareEvents: function() {
com.liquidpixels.event.EventDispatcher.makeDispatcher(this);
var item = this.target.element;
if (this.options.touchEvents){
com.liquidpixels.Mixable.applyTo(this.target, this.options.gestureable || com.liquidpixels.wui.Gestureable, {
actionTouchStart: function(e){
this.handleOnMouseOver(e);
this.handleOnMouseDown(e);
}.bind(this),
actionTouchMove: this.handleOnMouseOut.bind(this),
actionTouchFinish: function(e){
this.handleOnMouseUp(e);
this.handleOnMouseOut(e);
}.bind(this),
actionOnPress: function(e){
this.handleOnMouseUp(e);
this.handleOnMouseOut(e);
if (this.options.passthroughEvents){
Event.stop(e);}
}.bind(this),
useMouse: false,
useGestures: false,
passthroughEvents: $DEF(this.options.passthroughEvents) ? this.options.passthroughEvents : false});
this.target.Gestureable.prepare();}
if (this.options.mouseEvents){
Event.observe(item, 'mouseout', this.handleOnMouseOut.bind(this), false);
Event.observe(item, 'mouseover', this.handleOnMouseOver.bind(this), false);
Event.observe(item, 'mousedown', this.handleOnMouseDown.bind(this), false);
Event.observe(item, 'mouseup', this.handleOnMouseUp.bind(this), false);
Event.observe(item, 'click', this.handleOnClick.bind(this), false);
if (this.options.doubleClick) {
Event.observe(item, 'dblclick', this.handleDoubleClick.bind(this), false);}}},
isBusy: function() { /* VIRTUAL */
return false;},
setState: function(change, opts) {
opts = opts || {};
var current = this.getState();
this.clickInfo = undefined;
var ns, fireClick;
var keepVisState = opts.keepVisState || false;
switch(change) {
case "mout":
if(this.isStateLocked()) {
ns = current;
} else if (current == "OVR" || current == "DWN") {
ns = "CLR";
} else if (current == "SOV" || current == "SDW") {
ns = "SET";}
if(this.isStateLocked()) {
keepVisState = true;}
break;
case "mover":
if(this.isStateLocked()) {
ns = current;
} else if (current == "CLR") {
ns = "OVR";
} else if ( current == "SET" ){
ns = "SOV";}
if(this.isStateLocked()) {
keepVisState = true;}
break;
case "mdown":
if(this.isStateLocked()) {
ns = current;
} else if (this.state == "OVR" ) {
ns = "DWN";
} else if (this.state == "SOV" || this.state == "SET") {
ns = "SDW";}
if(this.isStateLocked()) {
keepVisState = true;}
break;
case "mup":
if (current == undefined) {
ns = "CLR";
} else if (current == "DWN" ) {
if (this.options.toggles) {
ns = "SOV";
this.setSelected(true);
} else {
ns = "OVR";}
if(this.mouseDown) {
fireClick = true;}
} else if (current == "SDW" ) {
if (this.options.toggles) {
ns = "OVR";
this.setSelected(false);
} else {
ns = "SOV";}
if(this.mouseDown) {
fireClick = true;}
} else if (current == "SET") {
ns = "CLR";
} else {
ns = "";}
if(this.isStateLocked()) {
keepVisState = true;}
break;
case 'dclk':
if (current == undefined) {
ns = "CLR";
} else if (current == "DWN" ) {
if (this.options.toggles) {
ns = "SOV";
this.setSelected(true);
} else {
ns = "OVR";}
if(this.mouseDown) {
fireClick = true;}
} else if (current == "SDW" ) {
if (this.options.toggles) {
ns = "OVR";
this.setSelected(false);
} else {
ns = "SOV";}
if(this.mouseDown) {
fireClick = true;}
} else if (current == "SET") {
ns = "CLR";
} else {
ns = "";}
if(this.isStateLocked()) {
keepVisState = true;}
break;
case 'CLR':
this.setSelected(false);
ns = change;
break;
case 'SET':
this.setSelected(true);
if (current == undefined) {
ns = "SET";
} else if (current == "OVR" || current == "SOV") {
ns = "SOV";
} else if (current == "DWN" || current == "SDW") {
ns = "SDW";
} else {
ns = "SET";}
break;
case 'OVR':
this.setSelected(false);
ns = change;
break;
case 'SOV':
case 'DWN':
case 'SDW':
this.setSelected(true);
ns = change;
break;
case 'DIS':
this.setEnabled(false);
this.setSelected(false);
ns = 'DIS';
break;
case 'ENA':
this.setEnabled(true);
ns = 'CLR';
break;
default:
this.errorBadStateChange(change);
return false;}
var eventType = this.options.eventType || opts.eventType || "Clickable.Clicked";
var eventInfo = {
fromState:		current,
change:			change,
toState:		ns,
event:			opts.event || "",
keepVisState:	keepVisState,
fireClick:		fireClick,
ignoreClick:	this.options.ignoreClick || opts.ignoreClick || false,
ignoreEvent:	this.options.ignoreEvent || opts.ignoreEvent || false,
target:			this.target,
description:	this.options.eventDescription || opts.eventDescription || "Clickable.Clicked",
value:			this.value || opts.value || "",
sayit:			this.options.sayit || opts.sayit || false,
opts:			opts};
var info = new com.liquidpixels.wui.UIEvent(eventType, eventInfo);
if (this.DEBUG) {
this.printTransition(info);}
if(ns) {
if(!keepVisState) {
this.target.applyStyle(ns);}
this.actionOnState(ns, info);
this.state = ns;}
if(this.options.singleClick && fireClick) {
this.mouseDown = false;
this.clickInfo = {
UIEvent: info}}
if(ns && this.states[ns].event) {
var ste = new com.liquidpixels.wui.UIEvent("Clickable." + this.states[ns].name, eventInfo);
this.dispatchEvent(ste);}
return true;},
click: function(e) {
if(this.options.actionOnClick) {
this.options.actionOnClick(e);}},
errorBadStateChange: function(change) {
_console.debug("%o --> unknown state change: %o", this.id, change);},
printEventAction: function(info) {
_console.debug("%o --> event fired: %o", this.target.id, info);},
printClickAction: function(info) {
_console.debug("%o --> click happened: %o", this.target.id, info);},
printTransition: function(info) {
var current = info.options.fromState;
var change = info.options.change;
var newState = info.options.toState;
_console.debug("%o --> change: %o, from: %o, to: %o", this.target.id, change, current, newState);},
actionOnState: function(state, e) {
if(this.actions[state]) {
(this.actions[state])(e);}},
prepareExportList: function($super) {
$super(["state", "states", "selected", "value",
"enabled", "mouseDown", "DEBUG", "actions",
"prepareActions", "prepareStates",
"isOff", "isOn", "isSelected",
"isEnabled", "isDisabled",
"enable", "disable", "select", "deselect",
"setEnabled", "setSelected",
"lock", "unlock", "isStateLocked",
"setValue", "getValue",
"setIgnoreClick", "setIgnoreEvent",
"setDebug", "isActive", "getState", "setClick",
"handleOnMouseOut", "handleOnMouseOver",
"handleOnMouseOver", "handleOnMouseDown",
"handleOnMouseUp", "handleOnClick", "handleDoubleClick",
"isBusy", "setState", "click",
"errorBadState", "printEventAction", "printClickAction",
"printTransition", "actionOnState"
]);},
clearEvents: function() {
Event.stopObserving(this.target.element);
if (this.target.Gestureable){
this.target.Gestureable.DESTROY();}},
toString: function() {
return "com.liquidpixels.Clickable";}});
com.liquidpixels.viewers.shared.AppDelegate = Class.create({
options: 		undefined, // various options...
initialize: function(options) {
this.options = {};
this.setDefaults();
Object.extend(this.options, options);},
setDefaults: function() { /* VIRTUAL */ },
// Useful for pre-loading settings into Application (maybe with ajax)...
autoconfig: function() { this.autorun(); },
autorun:     function() { /* VIRTUAL */ },
// If there is no status object in Application, you can do something if the
statusNonGratis: function(method, params) { /* VIRTUAL */ }});
com.liquidpixels.query.LFQuery = Class.create(com.liquidpixels.query.Query, {
lferror:			undefined,
data:				undefined,
dataName:			undefined,
dataType:			undefined,
response:			undefined,
origChain:			undefined,
initialize: function($super, options) {
$super(options);
com.liquidpixels.event.EventDispatcher.makeDispatcher(this);},
setDefaults: function() {
Object.extend(this.options, {
proxy:				'query/lfproxy.cms',
format:				'json',
asynchronous:		 true,
onInfoLoadEvent:	'LFQuery.Loaded',
onInfoErrorEvent:	'LFQuery.Error',
configName:			'',
verbose:			0,
globalNamespace:	''});},
createParser: function() {
this.parser = new com.liquidpixels.query.LFQueryParser();},
queryProxyChain: function(chain) {
var infoChain = this.mogrifyChainFormat(chain);
this.queryURL(this.options.proxy, {
cmd: infoChain.asURLVariable(),
config: this.options.configName});},
queryChain: function(chain, opts) {
var infoChain = this.mogrifyChainFormat(chain, opts);
this.queryURL(infoChain.asURL());},
mogrifyChainFormat: function(chain, opts) {
this.origChain = chain;
var clone = chain.clone();
var sink = clone.getCommandByName('sink');
if(!sink) {
var pos = clone.addCommand("sink");
sink = clone.getCommand(pos);}
if(opts) {
if(opts.format) {
sink.addAtt('format', opts.format);}
if(opts.name) {
sink.addAtt('name', opts.name);}
} else {
sink.addAtt('format', this.options.format);}
return clone;},
chainToGlobal: function(chain, name) {
this.dataName = name || "_lfinfojson";
var lfdataName;
if(this.options.globalNamespace) {
lfdataName = this.options.globalNamespace + "." + this.dataName;
} else {
lfdataName = this.dataName;}
if(this.options.format !== "json" && this.options.format !== "json2") {
this.lferror = "Cannot use format: '" +  this.options.format + "'";
return;}
var opts = {
format:			this.options.format,
name:			lfdataName};
var infoChain = this.mogrifyChainFormat(chain, opts);
var node = document.createElement("script");
if(node.addEventListener) {
node.addEventListener("load", this.chainToGlobalHandler.bind(this), false);
node.addEventListener("error", this.chainToGlobalErrorHandler.bind(this), false);
} else {
node.onreadystatechange = function(e) {
if((node.readyState == "loaded") || (node.readyState == "complete")) {
this.chainToGlobalHandler(e);}
}.bind(this)}
var url = infoChain.asURL();
node.src = url;
document.getElementsByTagName("head").item(0).appendChild(node);},
queryURL: function(url, params) {
this.options.success = this.responseHandler.bind(this);
this.setSrc(url);
this.load(params);},
chainToGlobalHandler: function(e) {
var json;
if(this.options.globalNamespace) {
json = window[this.options.globalNamespace][this.dataName];
} else {
json = window[this.dataName];}
this.data = json;
if(json) {
this.parser.jsonParse(json);
this.fireDataLoaded();
} else {
_console.debug("Err: No data from Chain to Global");}},
chainToGlobalErrorHandler: function(e) {
this.fireDataError();},
responseHandler: function(r) {
this.parser.parse(r);
this.fireDataLoaded();},
fireDataLoaded: function(e) {
if(this.options.verbose) {_console.debug("fire data loaded");}
this.dispatchEvent(new com.liquidpixels.wui.Event(this.options.onInfoLoadEvent, {
target: this,
UAevent: e
}));},
fireDataError: function(e) {
if(this.options.verbose) {_console.debug("fire data error");}
this.dispatchEvent(new com.liquidpixels.wui.Event(this.options.onInfoErrorEvent, {
target: this,
UAevent: e
}));},
setQueryFormat: function(format) {
this.options.format = format;},
getJob: function() {
return this.parser.jobInfo;},
getInfo: function() {
return this.parser.metaInfo;},
hasError: function() {
return this.parser.hasError();},
getData: function() {
return this.data;},
getSeed: function(){
if (this.parser.jobInfo && this.parser.jobInfo.seed){
return this.parser.jobInfo.seed.value;
}else{
return undefined;}},
getValue: function(group, tag) {
if(! this.parser.metaInfo) {return undefined};
var grp = this.parser.metaInfo[group];
if(! grp) {return undefined};
var item = grp[tag];
if(! item) {return undefined};
return item.value;},
toString: function() { return "com.liquidpixels.query.LFQuery" }});
com.liquidpixels.query.ResponsePacketParser = Class.create(com.liquidpixels.query.Parser, {
header:		undefined,
body:		undefined,
xmlParse: function(xmlDoc) {
var headerNode = xmlDoc.getElementsByTagName('header')[0];
var bodyNode = xmlDoc.getElementsByTagName('body')[0];
if(!headerNode && !bodyNode) {
this.header = {status: 'error', message: 'No Header or Body'};
return;}
this.xmlHeaderParse(headerNode);
this.xmlBodyParse(bodyNode);},
jsonParse: function(json) {
var jresp = json.response;
if(jresp.response) { jresp = jresp.response };
var header = jresp.header[0].status[0];
var body = jresp.body[0];
if(!header && !body) {
this.header = {status: 'error', message: 'No Header or Body'};
return;}
this.jsonHeaderParse(header);
this.jsonBodyParse(body);},
xmlHeaderParse: function(headerNode) {
var statusNode = headerNode.getElementsByTagName('status')[0] || {};
var statusValue = statusNode.getAttribute('status');
var messageNode = statusNode.getElementsByTagName('message')[0];
var messageValue = NodeValue(messageNode);
var messageID = messageNode.getAttribute('id');
this.header = {
status:	statusValue,
message: messageValue,
messageID: messageID};},
jsonHeaderParse: function(header) {
var message = header.message[0];
this.header = {
status:	header.status,
message: message.text,
messageID: message.id};},
xmlBodyParse: function(bodyNode) {
this.body = bodyNode;},
jsonBodyParse: function(body) {
this.body = body;},
getBody: function() {
return this.body;},
getHeader: function() {
return this.header;},
hasError: function() {
return (this.header && this.header.status && this.header.status == 'ok' ? false : true);}});
com.liquidpixels.wui.Image = Class.create(com.liquidpixels.wui.UIComponent, {
chain:				undefined,
naturalH:			undefined,
naturalW:			undefined,
naturalHeight:		undefined,
naturalWidth:		undefined,
loaded:				undefined,
error:  			undefined,
initialize: function($super, parent, options) {
$super(parent, options);
this.setSize(this.options.width, this.options.height);
this.setAlt(this.options.alt);
com.liquidpixels.event.EventDispatcher.makeDispatcher(this);
this.loaded = false;
this.error = false;
if(this.element.onload) {
this.originalOnload = this.element.onload;}
this.element.onload = this._onLoadHandler.bind(this);
Event.observe(this.element, 'load', this._onLoadHandler.bind(this));
if(this.element.onerror) {
this.originalOnerror = this.element.onerror;}
this.element.onerror = this._onErrorHandler.bind(this);
Event.observe(this.element, 'error', this._onErrorHandler.bind(this));},
setDefaults: function($super) {
$super();
Object.extend(this.options, {
tagType:			'img',
defaultCssClass:	'image',
onLoadEvent:		'Image.Loaded',
onErrorEvent:		'Image.Load.Error',
lf:					{},
alt:				''});},
setSrc: function(src) {
this.loaded = false;
this.error = false;
if(com.liquidpixels.utilities.typeOf(src) == 'KlassInstance' && src instanceof com.liquidpixels.liquifire.Chain) {
var url = src.asURL();
this.setAttribute('src', url);
this.chain = src;
} else if(com.liquidpixels.utilities.typeOf(src) == 'String') {
this.setAttribute('src', src);
} else {}},
setSize: function(w, h, opts) {
var style = {};
opts = opts || {};
if(w || w === 0) {
if(!opts.tweening) { this.width  = w; }
style.width = w + "px";}
if(h || h === 0) {
if(!opts.tweening) { this.height = h; }
style.height = h + "px";}
this.setAttributes(style);
this.setStyle(style);},
setAlt: function(alt){
this.setAttribute('alt', alt);},
getSrc: function() {
var rtn = this.chain || this.element.src;
return rtn;},
getChain: function() {
return this.chain;},
hasChain: function() { return this.getChain() },
srcToChain: function(lf, str) {
if(this.hasChain()) { return this.getChain(); }
if(!lf) return null;
this.chain = new com.liquidpixels.liquifire.Chain(lf);
if(str) {
this.chain.parse(str);
} else if(this.element.src) {
this.chain.addCommand('source', {url: this.element.src});
this.chain.addSink();
} else {
return null;}
var url = this.chain.asURL();
this.setAttribute('src', url);
return this.getChain();},
setLF: function(lf) {
this.options.lf = lf;},
applyTransform: function(t) {
this.srcToChain();
this.chain.applyTransform(t);
this.setSrc(this.chain);},
_onLoadHandler: function(e) {
if (!this.loaded){
this.onLoadHandler(e);}},
onLoadHandler: function(e) {
this.setLoaded();
this.dispatchEvent(new com.liquidpixels.wui.Event(this.options.onLoadEvent, {
target: this,
UAevent: e
}));
if(this.originalOnload) {
this.originalOnload(e);}},
_onErrorHandler: function(e) {
if (!this.error){
this.onErrorHandler(e);}},
onErrorHandler: function(e) {
this.error = true;
this.dispatchEvent(new com.liquidpixels.wui.Event(this.options.onErrorEvent, {
target: this,
UAevent: e
}));
if(this.originalOnerror) {
this.originalOnerror(e);}},
setLoaded: function(){
this.loaded = true;
this.calcNaturalDimensions();},
getNaturalDimensions: function(force) {
if(force || (!this.naturalWidth && !this.naturalHeight)) {
this.calcNaturalDimensions();}
var rtn = {
naturalWidth: this.naturalWidth,
naturalHeight: this.naturalHeight};
return rtn;},
getNaturalHeight: function(){
return this.naturalHeight;},
getNaturalWidth: function(){
return this.naturalWidth;},
setNaturalDimensions: function() { return this.calcNaturalDimensions() },
calcNaturalDimensions: function(){
if (this.element.naturalWidth && this.element.naturalHeight){
this.naturalW = this.element.naturalWidth;
this.naturalH = this.element.naturalHeight;
this.naturalWidth = this.naturalW;
this.naturalHeight = this.naturalH;
} else {
this.naturalDimensionsFallback();}},
naturalDimensionsFallback: function() {
var tempDisplay = this.element.style.display;
this.element.style.display = "block";
var tempWidth = this.element.style.width;
var tempHeight = this.element.style.height;
this.element.style.width = "auto";
this.element.style.height = "auto";
var attr = {
width: this.getAttribute("width"),
height: this.getAttribute("height")};
this.removeAttribute("width");
this.removeAttribute("height");
this.naturalW = this.element.width;
this.naturalH = this.element.height;
this.naturalWidth = this.naturalW;
this.naturalHeight = this.naturalH;
this.element.style.width = tempWidth;
this.element.style.height = tempHeight;
this.element.style.display = tempDisplay;
var tempAttr = $H(attr);
tempAttr.clean();
this.setAttributes(tempAttr.toObject());},
DESTROY: function($super){
this.element.onload = null;
this.element.onerror = null;
Event.stopObserving(this.element);
$super();},
toString: function() {return "com.liquidpixels.wui.Image"}});
com.liquidpixels.wui.Pane = Class.create(com.liquidpixels.wui.UIComponent, {
children:					undefined,	// HASH of UICs
childrenOrder:              undefined, //Array of Children in order
itemRefs:					undefined,
ccElement:		undefined, // childContainerElement
initialize: function($super, parent, options) {
$super(parent, options);
this.ccElement = this.element;},
initializeSpecific: function() {
this.children = new Hash();
this.childrenOrder = new Array();
this.itemRefs = {};},
setDefaults: function() {
Object.extend(this.options, {
defaultCssClass:	"pane"});},
getChild: function(id) {
return ( this.children.get(id) );},
getChildByIndex: function(index) {
var id = this.childrenOrder[index];
return this.getChild(id);},
_appendChild: function(child, id) {
if(child.notAppendable) {
this.errorCannotAppendChild(child, id);
return;}
this._addChild(child, id);
this.childrenOrder.push(id || child.id);
if (this.ccElement) { this.ccElement.appendChild(child.element); }
child.postAppendChild();},
appendChild: function(child, id) {
this._appendChild(child, id);},
errorCannotAppendChild: function(child, id) {
var theid = id || child.id || "";
throw new com.liquidpixels.Exception({
message: "ERR: Child (" + child + ", '" + theid +"') is not appendable.",
target: child});},
insertChild: function(child, location) {
if(child.notAppendable) {
this.errorCannotAppendChild(child, id);
return;}
this._addChild(child);
if (location && typeof(location) === 'object'){
if (this.ccElement) {
this.ccElement.insert(child.element, options);}
return;}
if (this.ccElement) {
if(location === undefined || location >= this.childrenOrder.length){
this.childrenOrder = this.childrenOrder.without(child.id);
this.childrenOrder.push(child.id);
this.ccElement.insert({bottom: child.element})
}else{
var childAtLocation = this.getChildByIndex(location);
var index = this.childrenOrder.indexOf(child.id);
this.childrenOrder.splice(location,0,child.id);
if (location <= index && index !== -1){
this.childrenOrder.splice(index + 1,1);
}else if (index !== -1) {
this.childrenOrder.splice(index,1);}
if (location === 0){
this.ccElement.insert({top: child.element});
}else{
childAtLocation.element.insert({before: child.element});}}}},
_addChild: function(child, id) {
if(! id) { id = child.id; }
this.children.set(id, child);},
incChild: function(child, id) {
return this._addChild(child, id);},
_storeChild: function(child) {
this.appendChild(child);},
getScrollOffset: function(p) {
return ( p - this.element.scrollTop );},
setValue: function(content) {
var cnt = this.children.keys().length;
if(!cnt) {
this.element.update(content);}},
clearEvents: function(){
if (this.element && this.element.stopObserving){
this.element.stopObserving();}},
DESTROY: function($super) {
this.destroyChildren();
$super();},
destroyChildren: function() {
if(this.children) {
this.children.each(function(pair){
this.children.unset(pair.key);
this.childrenOrder = this.childrenOrder.without(pair.key);
pair.value.DESTROY();
pair.value = null;
}.bind(this));}},
removeChild: function(child) {
var c =  this.children.unset(child.id);
if (c && this.ccElement) {
this.childrenOrder = this.childrenOrder.without(child.id);
this.ccElement.removeChild(c.element);}
return c;},
removeChildren: function() {
var list = new Hash();
this.children.each(function(child) {
var c = this.removeChild(child.value);
this.childrenOrder = this.childrenOrder.without(child.key);
list.set(child.key, child.value);
}.bind(this));
return list;},
toString: function() {
return "com.liquidpixels.wui.Pane";}});
com.liquidpixels.zap.Gestureable = Class.create(com.liquidpixels.wui.Gestureable, {
oneTouchTimer: undefined,
oneTouchTimerSet: undefined,
twoTouchTimer: undefined,
initialDistance: undefined,
androidGesture: undefined,
androidScale: undefined,
androidRemainingFinger: undefined,
setDefaults: function($super) {
$super();
this.touchScrollPassthrough = false;},
touchStart: function(e) {
this.checkEventStop(e);
if (e.touches.length === 2){
var time = new Date();
this.twoTouchTimer = time.getTime();
this.oneTouchTimer = null;
this.initialDistance = this.getAndroidDistance(e);
this.androidGesture = false;
this.androidRemainingFinger = false;}
if(this.mouseStarted || this.gestureStarted || this.gestureEnding || e.touches.length !== 1 ) {
return false;}
this.collectTouchStart(e);
if(this.options.actionTouchStart) {
this.options.actionTouchStart(e);}
this.gestureFinished = true;
return false;},
touchMove: function(e) {
this.checkEventStop(e);
if(this.mouseStarted || this.gestureStarted || this.gestureEnding /*|| e.touches.length !== 1 */|| !this.gestureFinished || this.androidRemainingFinger) {
//console.log("touch skip");
return false;}
if (e.touches.length > 1 && this.initialDistance){
var distance = this.getAndroidDistance(e);
this.androidScale = distance / this.initialDistance;
e.scale = this.androidScale;
if (this.androidScale < 1.1 && this.androidScale > 0.9){
return false;}
if (this.androidGesture){
Event.stop(e);
this.twoTouchTimer = null;
if(this.options.actionGestureMove) {
this.options.actionGestureMove(e);}
return false;}
Event.stop(e);
this.androidGesture = true;
this.androidRemainingFinger = false;
this.twoTouchTimer = null;
if(this.options.actionGestureStart) {
this.options.actionGestureStart(e);}
if(this.options.actionGestureMove) {
this.options.actionGestureMove(e);}
}else if (e.touches.length < 1){
return false;}
this.collectTouchMove(e);
if (this.mvX > 2 || this.mvX < -2 || this.mvY > 2 || this.mvY < -2){
this.dragging = true;
if(this.options.actionTouchMove) {
this.options.actionTouchMove(e);}}
return false;},
touchEnd: function(e) {
this.checkEventStop(e);
if(this.mouseStarted || this.gestureStarted || this.gestureEnding || !this.gestureFinished) {
if (e.touches.length === 0 && this.gestureFinished == false){
this.gestureFinished = true;}
return false;}
if (e.changedTouches.length === 2){
if(e.touches.length === 0 && this.options.actionOnTwoFingerPress) {
this.twoTouchTimer = null;
this.options.actionOnTwoFingerPress(e);
return false;}
}else if(this.twoTouchTimer && e.touches.length === 0){
var time = new Date();
var delta = time.getTime() - this.twoTouchTimer;
if (delta < 100){
this.options.actionOnTwoFingerPress(e);}
this.twoTouchTimer = null;
return false;}
if (this.androidGesture){
this.androidGesture = false;
if (e.touches.length === 1){
this.androidRemainingFinger = true;}
this.twoTouchTimer = null;
e.scale = this.androidScale;
if(this.options.actionGestureEnd) {
this.options.actionGestureEnd(e);
return false;}
}else if (this.androidRemainingFinger && e.touches.length === 0)
{
this.androidRemainingFinger = false;
return false;}
if(this.dragging || this.dragged) {
this.dragging = false;
if(this.options.actionTouchFinish) {
this.options.actionTouchFinish(e);}
} else {
if(e.touches.length === 0 && this.options.actionOnPress) {
if (this.oneTouchTimerSet && this.options.actionOnTwoFingerPress){
this.oneTouchTimerSet = false;
clearTimeout(this.oneTouchTimer);
this.options.actionOnTwoFingerPress(e);
return false;
}else{
this.oneTouchTimerSet = true;
this.oneTouchTimer = setTimeout(function(e){
this.oneTouchTimerSet = false;
this.options.actionOnPress(e);
}.bind(this),175);
return false;}
this.options.actionOnPress(e);}}
return false;},
gestureStart: function(e) {
Event.stop(e);
if(this.mouseStarted || this.gestureStarted) {
return false;}
this.gestureStarted = true;
this.gestureFinished = false;
if(this.options.actionGestureStart) {
this.options.actionGestureStart(e);}
return false;},
gestureMove: function(e) {
Event.stop(e);
if(this.mouseStarted || !this.gestureStarted || this.gestureEnding ) {
return false;}
if(this.options.actionGestureMove) {
this.options.actionGestureMove(e);}
return false;},
gestureEnd: function(e) {
Event.stop(e);
if(this.mouseStarted || !this.gestureStarted || this.gestureEnding) {
return false;}
this.twoTouchTimer = null;
if(this.options.actionGestureEnd) {
this.options.actionGestureEnd(e);}
this.gestureStarted = false;
return false;},
getDistance: function(point1,point2){
var xs = 0;
var ys = 0;
xs = point2.x - point1.x;
xs = xs * xs;
ys = point2.y - point1.y;
ys = ys * ys;
return Math.sqrt( xs + ys );},
getAndroidDistance: function(e){
var point1 = {x:e.touches[0].clientX, y:e.touches[0].clientY};
var point2 = {x:e.touches[1].clientX, y:e.touches[1].clientY};
return (this.getDistance(point1,point2));},
setTouchScrollPassthrough: function(value){
if ($DEF(value) && value === true){
this.touchScrollPassthrough = true;
}else{
this.touchScrollPassthrough = false;}},
checkEventStop: function(e){
if (!this.touchScrollPassthrough){
Event.stop(e);}},
prepareExportList: function($super) {
$super();
this.addToExportList(["getAndroidDistance","getDistance","checkEventStop","setTouchScrollPassthrough"]);},
toString: function() { return "Mixable.Gestureable" }});
com.liquidpixels.zap.Engine = Class.create(com.liquidpixels.viewers.shared.AppDelegate, {
zapPane: undefined,
viewPane: undefined,
autoconfig: function ($super) {
Application.set("uaq", $UAQ());
$super();},
loadOptions: function (values) {
Object.extend(this.options, values);
this.build();},
setDefaults: function () {
Object.extend(this.options, {
height: 400,
width: 400,});},
build: function () {
this.buildViewPane();
this.buildZapManager();},
buildViewPane: function () {
this.viewPane = new com.liquidpixels.wui.Pane(this, {
id: "viewpane",
cssClass: "viewpane",});
Application.append(this.viewPane);},
buildZapManager: function () {
var cl_zapMgr = this.determineZapManager();
if (!cl_zapMgr) {
this.errorNoZapMgr();
return;}
var params = new Hash({
pane: this.viewPane,
vpWidth: this.options.width, // viewPort
vpHeight: this.options.height, // viewPort
image: this.options.image, // img
chain: this.options.chain,
displayError: this.options.displayError,
lf: Application.get("lf"),
displayMode: this.options.displayMode,
maxScale: this.options.maxScale || this.options.maxZoom, // support both for legacy
zoomFactor: this.options.zoomFactor,
touchClick: this.options.touchClick,
tweenDuration: this.options.tweenDuration,
retina: this.options.retina,
stitchedBackgroundColor: this.options.stitchedBackgroundColor,
homeIcon: this.options.homeIcon,
touchScrollPassthrough: this.options.touchScrollPassthrough,
easingFunction: this.options.easingFunction,
keyboardControl: this.options.keyboardControl,
description: this.options.description,
chainMetadata: this.options.chainMetadata,});
params.clean();
this.zapManager = new cl_zapMgr(this, params.toObject());},
getView: function () {
if (!this.zapManager.isReady()) {
return "Viewer not initialized yet";}
return this.zapManager.getView();},
loadImage: function (source) {
if (this.zapManager.isReady() || this.zapManager.isApiReady() || this.zapManager.isError()) {
this.clearViewportInterval();
this.zapManager.loadImage(source);}},
loadChain: function (source, options) {
if (this.zapManager.isReady() || this.zapManager.isApiReady() || this.zapManager.isError()) {
this.clearViewportInterval();
this.zapManager.loadChain(source, options);}},
determineZapManager: function () {},
sendEvent: function (data) {},
errorNoZapMgr: function () {
_console.debug("no zap Manager");},
toString: function () {
return "com.liquidpixels.zap.Engine";},});
com.liquidpixels.query.LFQueryParser = Class.create(com.liquidpixels.query.ResponsePacketParser, {
jobInfo:			undefined,
metaInfo:			undefined,
lferror:			undefined,
xmlBodyParse: function(bodyNode) {
this.body = bodyNode;},
jsonBodyParse: function(body) {
this.body = body;
if(this.hasError()) { return; }
job = body.job[0];
jobGroup = job.group[0];
var jobType = jobGroup.type;
this.jobInfo = {};
var jobName;
var jobText;
$A(jobGroup.metadata).each(function(o, i){
this.jobInfo[o.name] = {
type:	jobType,
value:	o.text};
}.bind(this));
var imgData = body.image[0];
var metaInfo = {};
metaInfo.data = {
format:		imgData.format,
name:		imgData.name,
frames:		imgData.frames};
$A(imgData.group).each(function(o,i) {
metaInfo[o.type] = {};
$A(o.metadata).each(function(p,j) {
metaInfo[o.type][p.name] = { value: p.text };});});
this.metaInfo = metaInfo;}});
com.liquidpixels.zap.Tile = Class.create(com.liquidpixels.wui.Image, {
drawSrc:		undefined, 		// what to set to src when asked
drawn:			undefined,		// told to draw
loaded:			undefined,		// image onload fired
initialize: function($super, parent, options) {
$super(parent, options);
this.element.addClassName(this.options.blankCss);
var dataURI = "";
var uaq = Application.get("uaq");
if (uaq.ie && uaq.verMajor <= 7){
dataURI = "";}
this.tileX = this.options.tileX;
this.tileY = this.options.tileY;},
setDefaults: function($super) {
$super();
Object.extend(this.options, {
color:		"white",
blankCss:	"blankDiv",
tileCss:	"tile",
attributes: {
"aria-hidden": "true",
tabindex: "-1",
alt: ""}});},
onLoadHandler: function(e) {
this.loaded = true;
try{
this.appear({
queue: {
scope: 'com.liquidpixels.zap.Tile'},
duration: .2,
afterFinish: function() {
this.dispatchEvent({type: "Tile.Loaded", target: this});
}.bind(this)});
}catch(e){
this.show();
_console.debug("tile onLoadHandler error: " + e);}},
setSrc: function(src) {
if(typeof src === 'object') {
this.chain = src;
this.drawSrc = src.asURL();
} else if(typeof src === 'string') {
this.drawSrc = src;
} else {}},
draw: function() {
if(!this.drawn) {
this.hide();
this.removeClassName(this.options.blankCss);
this.addClassName(this.options.tileCss);
this.setAttribute('src', this.drawSrc);
this.drawn = true;
this.loaded = false;}},
checkComplete: function(){
if (!this.loaded){
if (this.element.complete){
this.onLoadHandler({});
return true;}
return false;
}else {
return true;}},
isDrawn: function() {
return !!(this.drawn);},
isLoaded: function() {
return !!(this.loaded);},
DESTROY: function($super){
$super();}});
com.liquidpixels.viewers.shared.Frame = Class.create(com.liquidpixels.wui.Pane, {
initialize: function($super, parent, options) {
$super(parent, options);
this.userAgent = $UAQ();
com.liquidpixels.event.EventDispatcher.makeDispatcher(this);
this.setAttributes({
frameBorder: 0,
tabindex: 1,
title: "Interactive Image Viewer"});
this.setStyle({
width: this.options.width + "px",
height: this.options.height + "px"});
this.setAttribute("scrolling", this.options.scrolling);
this.setAttribute("allowTransparency", true);
this.onDocLoadHandlerRetryCount = 0;
this.startIframeCounter = 0;
this.prepareEvents();
this.setListeners();
this.setupLF();
this.setSrc();},
setDefaults: function($super) {
$super();
Object.extend(this.options, {
width: 400,
height: 400,
tagType: "iframe",
defaultCssClass: "iframe",
cssStyle: {
position: "relative"},
scrolling: "no",
onLoadEvent: "Iframe.Loaded"});},
prepareEvents: function() {
this.events = {};},
setListeners: function() {
this.element.observe("load", this.blankLoaded.bind(this));},
removeListeners: function() {
this.element.stopObserving("load");},
setupLF: function() {
if (this.options.lf) {
this.lf = this.options.lf;
} else if (this.options.server && this.options.uri) {
this.lf = new com.liquidpixels.liquifire.LiquiFire(this.options.server, this.options.uri, this.options.port);
} else {
this.errorMessage("Error no server/uri");
return;}
var zapDir = this.lf.getZapDir();
if (!zapDir) {
this.errorNoZapDir();
return;}
var simpleDir = this.options.dhtmlDir || "dhtml";
this.baseDir = zapDir + "/" + simpleDir + "/";},
setSrc: function($super, url) {
if (this.options.domain) {
url = this.baseDir + "blank.html?viewer=" + (this.options.identity || "viewer");
if (this.options.domain) {
url += "&domain=" + encodeURI(this.options.domain);}}
$super(url);},
blankLoaded: function(e) {
this.removeListeners();
if (this.element.contentWindow) {
this.window = this.element.contentWindow;
} else if (this.element.contentDocument) {
this.window = this.element.contentDocument;
} else if (window.frames[this.id]) {
this.window = window.frames[this.id];
} else {
return;}
var cssSrc = "";
var scriptSrc = "";
var userCss = "";
if (window.__LIQUIDPIXELS__ && window.__LIQUIDPIXELS__.viewers && window.__LIQUIDPIXELS__.viewers.jsrOverride) {
scriptSrc = window.__LIQUIDPIXELS__.viewers.jsrOverride;
} else if (this.options.jsr) {
scriptSrc = this.baseDir + this.options.jsr;}
if (this.options.cssr) {
cssSrc = this.baseDir + this.options.cssr;}
if (this.options.userStyleSheet) {
userCss = this.options.userStyleSheet;}
var startScript = "try{ window.Application = new com.liquidpixels.viewers.shared.Application(" + this.options.engineType + ");}catch(err){}";
var html = "<!DOCTYPE html><html>" + "  <head> " + '   <link rel="stylesheet" href="' + cssSrc + '" type="text/css" /> ' + '   <link rel="stylesheet" href="' + userCss + '" type="text/css" /> ' + (this.options.domain ? '<script type="text/javascript">document.domain = "' + this.options.domain + '";</script>' : "") + '   <script src="' + scriptSrc + '" type="text/javascript"></script> ' + '   <script type="text/javascript">' + startScript + "</script> " + " </head><body></body></html>";
try {
if (this.userAgent.firefox) {
throw "Firefox, use other path";}
this.window.document.write(html);
this.window._onwindowloaded = this.onDocLoadHandler.bind(this);
if (this.userAgent.ie && this.userAgent.verMajor <= 9) {
this.window.document.onreadystatechange = function() {
if (this.window.document.readyState == "loaded" || this.window.document.readyState == "complete") {
var script1 = new Element("script", {
type: "text/javascript"});
script1.text = "window.Application = new com.liquidpixels.viewers.shared.Application(" + this.options.engineType + ");";
this.window.document.getElementsByTagName("head")[0].appendChild(script1);}
}.bind(this);}
this.window.document.close();
} catch (err) {
this.window.document.getElementsByTagName("head")[0].appendChild(
new Element("link", {
rel: "stylesheet",
href: cssSrc,
type: "text/css"
})
);
this.window.document.getElementsByTagName("head")[0].appendChild(
new Element("link", {
rel: "stylesheet",
href: userCss,
type: "text/css"
})
);
var script = new Element("script", {
src: scriptSrc,
type: "text/javascript",
onload: "window.Application = new com.liquidpixels.viewers.shared.Application(" + this.options.engineType + ");"});
this.window._onwindowloaded = this.onDocLoadHandler.bind(this);
this.window.document.getElementsByTagName("head")[0].appendChild(script);}},
onDocLoadHandler: function() {
this.onDocLoadHandlerRetryCount++;
if (!(this.window && this.window.Application && this.window.Application.delegate) && this.onDocLoadHandlerRetryCount < 10) {
setTimeout(this.onDocLoadHandler.bind(this), 500);
return;
} else if (this.onDocLoadHandlerRetryCount >= 10) {
this.errorMessage("Error Timeout");
return;}
this.engine = this.window.Application.delegate;
this.engine.sendEvent = this.receiveEvent.bind(this);
this.window.Application.set("lf", this.lf);
this.window.Application.set("zap.baseDir", this.baseDir);
this.dispatchEvent({
type: "loaded"});},
startIframe: function() {
this.startIframeCounter++;
if (!(this.engine && this.engine.loadOptions) && this.startIframeCounter < 200) {
setTimeout(
function() {
this.startIframe();
}.bind(this),
10
);
return;
} else if (this.startIframeCounter >= 200) {
this.errorMessage("Iframe Error");
return;}
this.engine.loadOptions(this.options);},
receiveEvent: function(name, data) {
this.dispatchEvent({
type: this.events[name],
response: name,
data: data});},
errorNoZapDir: function() {
_console.debug("no zap dir");},
errorMessage: function(msg) {
this.window.document.getElementsByTagName("body")[0].innerHTML = msg || "Error";
this.window.document.getElementsByTagName("body")[0].style.textAlign = "center";
this.window.document.getElementsByTagName("body")[0].style.lineHeight = this.options.height + "px";},
toString: function() {
return "com.liquidpixels.viewers.shared.Frame";},
DESTROY: function($super) {
this.window = null;
this.engine = null;
$super();}});
com.liquidpixels.wui.loader.Pixels = Class.create(com.liquidpixels.wui.Pane, {
initialize: function($super, parent, options) {
$super(parent, options);
this.userAgent = $UAQ();
if (this.userAgent.modern){
this.cssPixels();
}else{
this.legacyBrowsers();}},
setDefaults: function($super){
$super();
Object.extend(this.options, {
cssClass: 'com_liquidpixels_wui_loader_Pixels'});},
cssPixels: function(){
var pixel1 = new com.liquidpixels.wui.Pane(this, {
cssClass: "com_liquidpixels_wui_loader_Pixels-pixels"});
this.appendChild(pixel1);
var pixel2 = new com.liquidpixels.wui.Pane(this, {
cssClass: "com_liquidpixels_wui_loader_Pixels-pixels"});
this.appendChild(pixel2);
var pixel3 = new com.liquidpixels.wui.Pane(this, {
cssClass: "com_liquidpixels_wui_loader_Pixels-pixels"});
this.appendChild(pixel3);},
legacyBrowsers: function(){
throw new com.liquidpixels.Exception({
message: "com.liquidpixels.wui.loader.Pixels is only for modern browsers. Use an alternative loader for older browsers.",
target: this});}});
com.liquidpixels.wui.Button = Class.create(com.liquidpixels.wui.Pane, {
content:			undefined,
initialize: function($super, parent, options) {
$super(parent, options);
if(this.options.style) {
this.makeStylable(this.options.style);}
if (this.options.accessibility){
this.enableTabIndex();}
this.makeClickable();
this.prepareContent();},
prepareContent: function() {
if($DEF(this.options.label)) {
this.buildLabel(this.options.label);
} else if($DEF(this.options.text)) {
this.buildLabel(this.options.text);
} else if($DEF(this.options.src)) {
this.buildImage(this.options.src);
} else if($DEF(this.options.content)) {
this.setContent(this.options.content);}},
setDefaults: function($super) {
$super();
Object.extend(this.options, {
tagType:			'span',
defaultCssClass:	'button',
stopClickPropagation: true,
passthroughEvents: true,
blurOnClick: true,
accessibility: false,
tabIndex: 0,
clickEvent:			'WUI.UIEvent.Clickable.Clicked',
stateEvents:		['CLR', 'OVR'],	// Fire events for these?
stylableClass:		com.liquidpixels.wui.Stylable,
clickableClass:		com.liquidpixels.wui.Clickable});},
buildLabel: function(label) {
var content;
if(typeof(label) === "string") {
content = new com.liquidpixels.wui.Label(this, {
text: label});
} else if(typeof(label) === "object") {
content = label;
} else {
return;}
this.setContent(content);},
buildImage: function(src) {
var content = new com.liquidpixels.wui.Image(this, {
src: src});
this.setContent(content);},
setContent: function(content) {
if(this.content) {
this.removeChild(this.content);
this.content.DESTROY();}
this.content = content;
this.appendChild(this.content);},
makeStylable: function(style) {
var optList = ['removeCssClass', 'removeCssStyle', 'removeValue',
'removeSrc', 'removeUIC', 'addCssClass', 'addCssStyle', 'addValue',
'addSrc', 'addUIC'];
var styleOpts = {style: style};
var options = this.options;
optList.each(function(o,i) {
if($DEF(options[o])) {
styleOpts[o] = options[o];}});
com.liquidpixels.Mixable.applyTo(this, this.options.stylableClass, styleOpts);
this.Stylable.prepare();},
makeClickable: function() {
var useStateEvents;
if(this.Stylable) {
useStateEvents = this.Stylable.getStates();
} else {
useStateEvents = this.options.stateEvents;}
var optList = ['toggles', 'state', 'stateLock', 'lockOnBusy', 'enabled', 'touchEvents',
'visible', 'ignoreEvent', 'ignoreClickAction', 'eventType',
'eventDescription',	'singleClick', 'doubleClick',
'stopClickPropagation', 'gestureable', 'actionOnMouseOut',  'actionOnMouseOver', 'actionOnMouseDown', 'actionOnMouseUp', 'passthroughEvents'];
var clickOpts = {useStateEvents: useStateEvents};
var options = this.options;
optList.each(function(o,i) {
if($DEF(options[o])) {
clickOpts[o] = options[o];}});
com.liquidpixels.Mixable.applyTo(this, this.options.clickableClass, clickOpts);
this.Clickable.prepare();
if(this.options.click) {
this.Clickable.addEventListener(this.options.clickEvent, this.click.bind(this));
if (this.options.accessibility){
Element.observe(this.element, "keyup", this.keypress.bind(this));
Element.observe(this.element, "keydown", this.keypress.bind(this));}}},
click: function(e){
if (this.options.accessibility && this.options.blurOnClick && e.options && e.options.event && e.options.event.type.match(/mouse/i)){
this.element.blur();}
if (this.options.click){
this.options.click(e);}},
getContent: function() {
return this.content;},
setSrc: function(src) {
if(this.content) {
this.content.setSrc(src);}},
getSrc: function() {
return this.options.src;},
addEventListener: function(event, method) {
this.Clickable.addEventListener(event, method);},
setValue: function(o) {
this.options.value = o;},
getValue: function() {
return this.options.value;},
setData: function(data) {
this.options.data = data;},
getData: function() {
return this.options.data;},
isSelected: function() {
return this.selected;},
toggle: function() {
if(this.isSelected()) {
this.deselect();
} else {
this.select();}},
check: function() {this.select()},
select: function() {
this.selected = true;
this.Clickable.select();},
uncheck: function() {this.deselect()},
deselect: function() {
this.selected = false;
this.Clickable.deselect();},
toString: function() {
return "com.liquidpixels.wui.Button";},
enableTabIndex: function(index){
if ($DEF(index)){
this.options.tabIndex = index;}
this.setAttribute("tabindex", this.options.tabIndex);},
disableTabIndex: function(){
this.removeAttribute("tabindex");},
keypress: function(e){
if (document.activeElement == this.element && e.type == "keydown" && (e.keyCode == 13 || e.keyCode == 32)) {
Event.stop(e);}
if (document.activeElement == this.element && e.type == "keyup" && (e.keyCode == 13 || e.keyCode == 32)) {
Event.stop(e);
var event = {
target: this,
options: {
event: e}};
this.Clickable.handleOnMouseOver(e);
this.Clickable.handleOnMouseDown(e);
this.Clickable.handleOnMouseUp(e);
this.Clickable.handleOnMouseOut(e);}},
DESTROY: function($super){
this.Clickable.DESTROY();
Element.stopObserving(this.element);
if (this.Stylable){
this.Stylable.DESTROY();}
$super();}});
com.liquidpixels.wui.Label = Class.create(com.liquidpixels.wui.Pane, {
style:			undefined,
text:			undefined,
initialize: function($super, parent, options) {
$super(parent, options);
this.style = {};
if($DEF(this.options.text)) {
this.setValue(this.options.text)}},
setDefaults: function() {
Object.extend(this.options, {
text:				'&nbsp;',
defaultCssClass:	"label"});},
getContent: function() {
return ( this.getValue() );},
setLabel: function(text) {
this.setValue(text);},
getValue: function() {
return (this.text);},
setValue: function(text) {
this.text = text;
this.element.innerHTML = this.getDisplayText();},
getDisplayText: function() {
return this.getValue();},
toString: function() { return "com.liquidpixels.wui.Label"; }});
com.liquidpixels.zap.Image = Class.create(com.liquidpixels.wui.Pane, {
chain:			undefined, // isa Chain (base original)
baseChain:		undefined, // isa modifed chain for tiles...
loaded:			undefined,
prepare: function(params) {
this.loaded = false;
com.liquidpixels.Mixable.applyTo(this, com.liquidpixels.wui.Transformable, params);
this.Transformable.prepare();
this.prepareBaseChain();},
setDefaults: function($super) {
$super();
Object.extend(this.options, {
displayAlign:	'center',
eventPrefix:	'ZapImage',
tweenDuration:  0.5});},
prepareBaseChain: function() { /* VIRTUAL */ },
// REQUIRES a Chain (if object, assumed to be Chain)
setSrc: function(src) {
if(typeof src === 'object') {
this.chain = src;}},
layout: function(pos, opts) {
this.Transformable.update();
var lout = pos || 'center';
this.Transformable.setLayout(lout, opts);},
fireLoadedEvent: function(opts) {
this.loaded = true;
var ename = this.options.eventPrefix + ".Loaded";
this.dispatchEvent(new com.liquidpixels.wui.Event(ename, {
target: this,
id: opts.id
}));},
setLoaded: function(isLoaded) {
if(typeof(isLoaded) !== "undefined") {
this.loaded = !!(isLoaded);}
return this.loaded;},
isLoaded: function() {
return this.loaded;},
panTo: function(pos, opts) {},
toString: function() {return "com.liquidpixels.zap.Image"},
DESTROY: function($super){
this.Transformable.DESTROY();
$super();}});
com.liquidpixels.zap.SimpleEngine = Class.create(com.liquidpixels.zap.Engine, {
collectionHome: undefined,
autorunCount: 0,
autorun: function() {
if (window.document.readyState == "complete" && window._onwindowloaded) {
window._onwindowloaded();
} else if (window.document.readyState != "complete") {
setTimeout(
function() {
if (this.autorunCount && this.autorunCount >= 50) {
this.errorNoOnIFrameLoaded();
} else {
this.autorunCount++;
this.autorun();}
}.bind(this),
100
);
} else {
this.errorNoOnIFrameLoaded();}},
zoomReset: function() {
if (!this.zapManager.isReady()) {
return;}
this.zapManager.goHome();},
home: function() {
if (!this.zapManager.isReady()) {
return;}
this.zapManager.goHome();},
dimensions: function() {
if (!this.zapManager.isReady()) {
return;}
this.zapManager.fireDimensionsEvent();},
zoomToPoint: function(scale, x, y) {
if (!this.zapManager.isReady()) {
return;}
this.zapManager.zoomToPoint({ scale: scale, x: x, y: y });},
panToPoint: function(x, y) {
if (!this.zapManager.isReady()) {
return;}
this.zapManager.zoomToPoint({ x: x, y: y });},
panByAmount: function(panX, panY) {
if (!this.zapManager.isReady()) {
return;}
this.zapManager.panByAmount({ x: panX, y: panY });},
panByPercent: function(pctX, pctY) {
if (!this.zapManager.isReady()) {
return;}
this.zapManager.panByPercent({ px: pctX, py: pctY });},
zoomToRegion: function(x1, y1, x2, y2) {
if (!this.zapManager.isReady()) {
return;}
this.zapManager.zoomToRegion({ x1: x1, x2: x2, y1: y1, y2: y2 });},
isReady: function() {
if (this.zapManager && (this.zapManager.isReady() || this.zapManager.isApiReady())) {
return true;
} else {
return false;}},
collectionViewport: function(source, x1, y1, x2, y2) {
if (this.zapManager.isReady() || this.zapManager.isApiReady()) {
this.loadChain(source);
this.collectionHome = { x1: x1, x2: x2, y1: y1, y2: y2 };
this.collectionViewportInterval = setInterval(
function() {
if (this.zapManager.currentLayer && this.zapManager.currentLayer.allLoaded) {
_console.debug("collectionViewport zoomToRegion being called");
this.zapManager.zoomToRegion({ x1: x1, x2: x2, y1: y1, y2: y2, collectionViewport: true });
this.zapManager.options.collectionViewport = this.collectionHome;
this.zapManager.homeScale = this.zapManager.curScale;
clearInterval(this.collectionViewportInterval);
this.collectionViewportInterval = null;
return;}
_console.debug("Not Ready For Zoom");
}.bind(this),
250
);}},
report: function(message) {
_console.debug(message);},
determineZapManager: function() {
var uaq = Application.get("uaq");
var zm;
zm = this.options.zapManager;
return zm;},
setChainMetadata: function(params, update) {
if (this.zapManager.isReady() || this.zapManager.isApiReady()) {
if (update) {
Object.extend(this.zapManager.options.chainMetadata, params);
} else {
this.zapManager.options.chainMetadata = params;}
if (this.zapManager.options.image) {
this.zapManager.loadImage(this.zapManager.options.image);
} else if (this.zapManager.options.chain) {
this.zapManager.loadChain(this.zapManager.options.chain);}}},
getChainMetadata: function() {
if (this.zapManager.isReady() || this.zapManager.isApiReady()) {
return this.zapManager.options.chainMetadata;
} else {
return undefined;}},
errorNoOnIFrameLoaded: function() {
_console.debug("Error: No IFrame Loaded Function");},
clearViewportInterval: function() {
if (this.collectionViewportInterval) {
clearInterval(this.collectionViewportInterval);
this.collectionViewportInterval = null;}},
DESTROY: function($super) {
this.clearViewportInterval();
$super();},
toString: function() {
return "com.liquidpixels.zap.SimpleEngine";}});
com.liquidpixels.zap.Frame = Class.create(com.liquidpixels.viewers.shared.Frame, {
prepareEvents: function() {
this.events = {
started:	"WUI.Event.Frame.Started",
ready:		"WUI.Event.Frame.Ready",
loaded:		"WUI.Event.Frame.Loaded",
waiting:	"WUI.Event.Frame.Waiting",
dimensions:	"WUI.Event.Frame.Ready",
error:		"WUI.Event.Frame.Error",
blur:		"WUI.Event.Frame.Blur"};},
toString: function() { return "com.liquidpixels.zap.Frame"; }});
com.liquidpixels.zap.stitched.Image = Class.create(com.liquidpixels.zap.Image, {
baseImage:		undefined,
cacheImage:     undefined,
lastCacheChain: undefined,
cacheHash:      undefined,
setDefaults: function($super) {
$super();
Object.extend(this.options, {
tLayer:			100,
tScale:			1,
eventPrefix:	'StitchedImage'});
this.cacheHash = new Hash();
this.allLoaded = false;},
prepare: function($super, params) {
this.width = this.options.imgCurrW;
this.height = this.options.imgCurrH;
$super(params);
this.baseImage = new com.liquidpixels.wui.Image(this, {
visible: false,
src: this.baseChain});
this.appendChild(this.baseImage);
this.baseImage.setSize(this.width, this.height);
this.baseImage.setStyle({
willChange: "transform"});
this.cacheImage = new com.liquidpixels.wui.Image(this, {
cssClass: "stitchedView"});
this.appendChild(this.cacheImage);
this.cacheImage.hide();
this.baseImage.addEventListener("WUI.Event.Image.Loaded", this.options.baseImageFunction ? this.options.baseImageFunction.bind(this) : this.onBaseImageLoaded.bind(this));
this.cacheImage.addEventListener("WUI.Event.Image.Loaded", this.onCacheImageLoaded.bind(this));},
prepareBaseChain: function() {
this.baseChain = this.chain.clone();
var vals = {
x:      0,
y:      0,
width:  this.options.baseW,
height: this.options.baseH,
vsize:  this.width,
color:  'white'};
Object.extend(vals, this.options.accounting.seed ? {seed: this.options.accounting.seed} : {});
var uaq = Application.get("uaq");
if (uaq.retina && this.options.retina){
var retinaVals = {};
Object.extend(retinaVals, vals);
retinaVals.vsize *= 2;
this.baseChain.insertCommand("sink", "viewport", retinaVals);
}else{
this.baseChain.insertCommand("sink", "viewport", vals);}},
prepareCacheChain: function(vals) {
this.lastCacheChain = this.cacheChain;
this.cacheChain = this.chain.clone();
var tvals = {};
Object.extend(tvals, vals);
this.cacheChain.insertCommand("sink", "viewport", tvals);
var value = this.cacheHash.get(this.cacheChain.asString());
if (value){
this.cacheHash.set(this.cacheChain.asString(),value++);
}else{
this.cacheHash.set(this.cacheChain.asString(),1);}},
setPosition: function($super, left, top, opts) {
$super(left, top, opts);},
setSize: function($super, w, h, opts) {
this.width = w;
this.height = h;},
onBaseImageLoaded: function(e) {
this.baseImage.show();
if (this.parent.options.displayMode === 'fill'){
this.allLoaded = true;
this.fireLoadedEvent({id: this.id});}},
onCacheImageLoaded: function(e) {
this.cacheImage.appear({
duration: 0.5,//this.options.tweenDuration,
queue: {
scope: 'cacheImage'},
afterFinish: function(){
this.allLoaded = true;
this.fireLoadedEvent({id: this.id});
}.bind(this)});},
updateStitchedImage: function(vals, change) {
this.allLoaded = false;
var biPos = this.getPosition();
var xyFactor = 100;
var whFactor = 200;
var cacheVals = {
x:      Math.floor(vals.x / xyFactor) * xyFactor,
y:      Math.floor(vals.y / xyFactor) * xyFactor,
width:  Math.ceil(vals.width / whFactor) * whFactor,
height: Math.ceil(vals.height / whFactor) * whFactor,
vsize:  undefined,
color:  vals.color};
Object.extend(cacheVals, this.options.accounting.seed ? {seed: this.options.accounting.seed} : {});
if (((cacheVals.width * change - this.options.vpW) < xyFactor) || ((cacheVals.height * change - this.options.vpH) < xyFactor)){
cacheVals.width += 200;
cacheVals.height += 200;}
cacheVals.vsize = Math.round(vals.vsize / (vals.width / cacheVals.width));
var xOffset = ((cacheVals.x - vals.x)  * change);
var yOffset = ((cacheVals.y - vals.y)  * change);
var vileft = (biPos.left) * -1;
var vitop =  (biPos.top ) * -1;
var uaq = Application.get("uaq");
if (uaq.retina && this.options.retina){
var retinaCacheVals = {};
Object.extend(retinaCacheVals, cacheVals);
retinaCacheVals.vsize *= 2;
this.prepareCacheChain(retinaCacheVals);
}else{
this.prepareCacheChain(cacheVals);}
if (this.lastCacheChain && this.lastCacheChain.asString() === this.cacheChain.asString()){
if (!this.cacheImage.visable){
this.onCacheImageLoaded();}
}else{
this.cacheImage.hide();}
this.cacheImage.setPosition(Math.round(vileft + xOffset), Math.round(vitop + yOffset));
this.cacheImage.setSrc(this.cacheChain);
this.cacheImage.setSize(cacheVals.vsize,null);
this.cacheImage.setStyle({height: "auto"});},
setTranformOrigin: function(x, y) {
this.setStyle({
webkitTransformOrigin: x + "px " + y + "px",
mozTransformOrigin: x + "px " + y + "px",
msTransformOrigin: x + "px " + y + "px",
oTransformOrigin: x + "px " + y + "px",
transformOrigin: x + "px " + y + "px"});},
toString: function() {return "com.liquidpixels.zap.stitched.Image"}});
com.liquidpixels.zap.tiled.Image = Class.create(com.liquidpixels.zap.Image, {
tiles: undefined, // isa Array (cols) of Array (rows) of Images...
xTiles: undefined,
yTiles: undefined,
beenPreTiled: undefined,
edgeTW: undefined,
edgeTH: undefined,
prepare: function($super, params) {
this.tiles = [];
$super(params);
this.userAgent = $UAQ();
this.calcLayerValues();
this.scaleTileValues(this.options.tScale);
this.prepareTiles();},
setDefaults: function($super) {
$super();
Object.extend(this.options, {
tileSize: 128,
layer: 100,
tScale: 1,
eventPrefix: "TiledImage"});
this.normalizedLayerValues = new Hash({
100: 100,
50: 50,
25: 25,
13: 12.5,
7: 6.25,
4: 3.125,
2: 1.5625,
1: 0.78125});
this.tilesWaitingToLoad = [];
this.allLoaded = false;},
prepareBaseChain: function() {
var c = this.chain.clone();
var params = {
ver: this.options.accounting.version,
size: this.options.tileSize,
x: 0,
y: 0,
layer: this.options.layer};
Object.extend(params, this.options.accounting.seed ? { seed: this.options.accounting.seed } : {});
c.insertCommand("sink", "zap", params);
this.baseChain = c;},
prepareTiles: function() {
this.backgroundImage = new com.liquidpixels.wui.Image(this, {
cssStyle: {
width: "100%",
height: "100%",
webkitBackfaceVisibility: "hidden",
backfaceVisibility: "hidden",
willChange: "transform"},
attributes: {
"aria-hidden": "true",
tabindex: "-1"}});
this.appendChild(this.backgroundImage);
this.setSize(this.width, this.height);
this.tileContainer = new com.liquidpixels.wui.Pane(this, {
cssClass: "tileContainer"});
this.appendChild(this.tileContainer);
for (var y = 0; y < this.yTiles; y++) {
this.tiles[y] = [];}
this.backgroundImage.setSrc(this.options.backgroundImageChain.asURL());},
makeTile: function(x, y) {
var c = this.baseChain;
var cmd = c.getCommandByName("zap");
cmd.set("layer", this.options.tLayer);
cmd.set("x", x);
cmd.set("y", y);
var tile = new com.liquidpixels.zap.Tile(this, {
src: c,
tileX: x,
tileY: y});
this.placeTile(tile);
this.tileContainer.appendChild(tile);
this.tiles[y][x] = tile;},
removeTiles: function() {
if (this.tileContainer) {
this.tilesWaitingToLoad = null;
this.removeChild(this.tileContainer);
this.tileContainer.DESTROY();
this.tileContainer = null;
this.tiles = null;}},
calcLayerValues: function() {
var imgCurrW = this.options.baseW;
var imgCurrH = this.options.baseH;
var tlayer = this.normalizedLayerValues.get(this.options.tLayer);
if (tlayer == undefined) {
throw "this.options.tLayer is invalid";}
this.layerW = Math.ceil((imgCurrW * tlayer) / 100);
this.layerH = Math.ceil((imgCurrH * tlayer) / 100);
var tbase = this.options.tileSize;
this.xTiles = Math.ceil(this.layerW / tbase);
this.yTiles = Math.ceil(this.layerH / tbase);},
getTLayer: function() {
return this.options.tLayer;},
getLayerValues: function() {
var vals = {
width: this.width,
height: this.height,
edgeTW: this.edgeTW,
edgeTH: this.edgeTH,
tsize: this.tsize,
xTiles: this.xTiles,
yTiles: this.yTiles,
tLayer: this.options.tLayer,
tFactor: this.options.tFactor};
return vals;},
scaleTileValues: function(scale, opts) {
var tbase = this.options.tileSize;
var tfactor = this.options.tFactor;
var tscale = scale * tfactor;
if (opts && opts.zoomFactor) {
this.tsize = Math.round(this.tsize * opts.zoomFactor);
} else if (opts && opts.size && opts.layerFactor) {
var factor = tfactor / opts.layerFactor;
this.tsize = opts.size * factor;
} else {
this.tsize = Math.floor(tbase * tscale) % 2 == 0 ? Math.floor(tbase * tscale) : Math.ceil(tbase * tscale);}
this.edgeTW = Math.round((this.layerW - (this.xTiles - 1) * tbase) * tscale);
this.edgeTH = Math.round((this.layerH - (this.yTiles - 1) * tbase) * tscale);
this.width = Math.round((this.xTiles - 1) * this.tsize + this.edgeTW);
this.height = Math.round((this.yTiles - 1) * this.tsize + this.edgeTH);},
placeTile: function(tile, opts) {
var x = tile.tileX;
var y = tile.tileY;
var imgTop = y * this.tsize;
var imgLeft = x * this.tsize;
var xTSize = this.tsize;
var yTSize = this.tsize;
if (y === this.yTiles - 1) {
yTSize = this.edgeTH;}
if (x === this.xTiles - 1) {
xTSize = this.edgeTW;}
tile.element.style.cssText = "";
tile.setPosition(imgLeft, imgTop, opts);
tile.setSize(xTSize, yTSize);},
placeAllTiles: function() {
if (this.tileContainer) {
for (var y = 0; y < this.yTiles; y++) {
for (var x = 0; x < this.xTiles; x++) {
var tile = this.tiles[y][x];
if (!tile) {
return;}
this.placeTile(tile);}}}},
hideNonVisableTiles: function(opts) {
var shown = this.calcTilesShown();
for (var y = 0; y < this.yTiles; y++) {
for (var x = 0; x < this.xTiles; x++) {
var tile = this.tiles[y][x];
if (!tile) {
return;}
if (y < shown.yFrom || y > shown.yTo || x < shown.xFrom || x > shown.xTo) {
tile.hide();}}}},
hideAllTiles: function() {
this.tileContainer.hide();
this.tilesHidden = true;},
showAllTiles: function(options) {
if (this.tilesHidden) {
if (options && options.appear) {
try {
this.tileContainer.appear({
duration: 0.5,
afterFinish: function(e) {
if (options.afterFinish) {
options.afterFinish();}
}.bind(this)});
} catch (e) {
if (this.tileContainer) {
this.tileContainer.show;}}
} else {
if (this.tileContainer) {
this.tileContainer.show;}}
this.tilesHidden = false;}},
resizeTiles: function(scale, layout, opts) {
this.loaded = false;
if (opts.tween) {
this.resizeTilesWithTween(scale, layout, opts);
} else {
this.resizeTilesNonTween(scale, layout, opts);}},
resizeTilesWithTween: function(scale, layout, opts) {
var currentWidth = this.width;
var currentHeight = this.height;
this.scaleTileValues(scale, opts);
this.Transformable.update();
var ppos = this.getPosition();
var cof = this.Transformable.getCenteredAt(layout.x, layout.y);
var leftTweenFrom = ppos.left;
var topTweenFrom = ppos.top;
var leftTweenTo = cof.x;
var topTweenTo = cof.y;
if (this.width < this.options.vpW) {
leftTweenTo = Math.round((this.options.vpW - this.width) / 2);}
if (this.height < this.options.vpH) {
topTweenTo = Math.round((this.options.vpH - this.height) / 2);}
if (this.userAgent.modern) {
var transition = "transform " + this.options.tweenDuration + "s " + com.liquidpixels.utilities.cssEasingFunctions[this.options.easingFunction];
var webkitTransition = "-webkit-transform " + this.options.tweenDuration + "s " + com.liquidpixels.utilities.cssEasingFunctions[this.options.easingFunction];
this.setStyle({
webkitTransition: webkitTransition,
transition: transition,
webkitTransformOrigin: "left top",
transformOrigin: "left top",
webkitTransform: "translate3d(0, 0, 0) scale3d(1, 1, 1)",
transform: "translate3d(0, 0, 0) scale3d(1, 1, 1)"});
var transitionendFunc = function(e) {
this.element.stopObserving("transitionend");
this.element.stopObserving("webkitTransitionEnd");
this.setStyle({
webkitTransition: "none",
transition: "none",
webkitTransform: "none",
transform: "none"});
this.placeAllTiles();
this.Transformable.update();
this.setSize(this.width, this.height);
if (opts && opts.afterFinish) {
opts.afterFinish();}
}.bind(this);
this.cssTransitionTimeout = setTimeout(
function(e) {
this.element.observe("transitionend", transitionendFunc);
this.element.observe("webkitTransitionEnd", transitionendFunc);
this.setStyle({
webkitTransform: "translate3d(" + (leftTweenTo - leftTweenFrom) + "px, " + (topTweenTo - topTweenFrom) + "px, 0) scale3d(" + this.width / currentWidth + ", " + this.height / currentHeight + ", 1)",
transform: "translate3d(" + (leftTweenTo - leftTweenFrom) + "px, " + (topTweenTo - topTweenFrom) + "px, 0) scale3d(" + this.width / currentWidth + ", " + this.height / currentHeight + ", 1)"});
}.bind(this),
10
);
} else {
var effectArr = new Array();
effectArr.push(
new Effect.Tween(
null,
leftTweenFrom,
leftTweenTo,
{
sync: true},
function(mv) {
this.setPosition(Math.round(mv), "", opts);
}.bind(this)
)
);
effectArr.push(
new Effect.Tween(
null,
topTweenFrom,
topTweenTo,
{
sync: true},
function(mv) {
this.setPosition("", Math.round(mv), opts);
}.bind(this)
)
);
effectArr.push(
new Effect.Tween(
null,
currentWidth,
this.width,
{
sync: true},
function(mv) {
this.setSize(Math.round(mv), "", opts);
}.bind(this)
)
);
effectArr.push(
new Effect.Tween(
null,
currentHeight,
this.height,
{
sync: true},
function(mv) {
this.setSize("", Math.round(mv), opts);
}.bind(this)
)
);
new Effect.Parallel(effectArr, {
afterFinish: function() {
this.placeAllTiles();
this.Transformable.update();
this.setSize(this.width, this.height);
if (opts && opts.afterFinish) {
opts.afterFinish();}
}.bind(this),
duration: this.options.tweenDuration,
transition: Effect.Transitions[this.options.easingFunction]});}},
resizeTilesNonTween: function(scale, layout, opts) {
this.scaleTileValues(scale, opts);
this.Transformable.update();
var cof = this.Transformable.getCenteredAt(layout.x, layout.y);
if (this.width < this.options.vpW) {
cof.x = Math.round((this.options.vpW - this.width) / 2);}
if (this.height < this.options.vpH) {
cof.y = Math.round((this.options.vpH - this.height) / 2);}
this.element.stopObserving("transitionend");
this.element.stopObserving("webkitTransitionEnd");
this.setStyle({
webkitTransition: "none",
transition: "none",
webkitTransform: "none",
transform: "none"});
this.setPosition(cof.x, cof.y, opts);
this.placeAllTiles();
this.Transformable.update();
this.setSize(this.width, this.height);
if (opts && opts.afterFinish) {
opts.afterFinish();}},
layout: function(pos, opts) {
this.Transformable.update();
var lout = pos || "center";
this.Transformable.setLayout(lout, opts);},
drawTiles: function(options) {
if (!$DEF(options)) {
options = {};}
var shown = this.calcTilesShown();
var checkTiles = true;
this.allLoaded = false;
for (var y = shown.yFrom; y <= shown.yTo; y++) {
for (var x = shown.xFrom; x <= shown.xTo; x++) {
if (this.tiles[y]) {
var tile = this.tiles[y][x];
if (tile && !tile.drawn && this.parent.currentLayer == this) {
tile.draw();
this.tilesWaitingToLoad.push(tile);
tile.addEventListener("Tile.Loaded", this.checkTiles.bind(this));
checkTiles = false;
} else if (!tile && this.parent.currentLayer == this) {
this.makeTile(x, y);
tile = this.tiles[y][x];
tile.draw();
this.tilesWaitingToLoad.push(tile);
tile.addEventListener("Tile.Loaded", this.checkTiles.bind(this));
checkTiles = false;}}}}
if (checkTiles) {
this.checkTiles();}},
checkTiles: function(e) {
if (this.tilesHidden) {
return;}
if (e) {
this.tilesWaitingToLoad = this.tilesWaitingToLoad.without(e.target);}
if (this.tilesWaitingToLoad.length == 0) {
this.allLoaded = true;
this.fireLoadedEvent({ id: this.id });}},
calcTilesShown: function() {
var rtn = {
xFrom: 0,
tTo: 0,
yFrom: 0,
yTo: 0};
if (this.posX < 0) {
rtn.xFrom = Math.floor(Math.abs(this.posX / this.tsize));}
if (this.posX > 0) {
rtn.xTo = Math.floor(this.width / this.tsize);
} else {
rtn.xTo = Math.floor(Math.abs(this.options.vpW - this.posX) / this.tsize);}
if (this.posY < 0) {
rtn.yFrom = Math.floor(Math.abs(this.posY / this.tsize));}
if (this.posY > 0) {
rtn.yTo = Math.floor(this.height / this.tsize);
} else {
rtn.yTo = Math.floor(Math.abs(this.options.vpH - this.posY) / this.tsize);}
return rtn;},
setTranformOrigin: function(x, y) {
this.setStyle({
webkitTransformOrigin: x + "px " + y + "px",
mozTransformOrigin: x + "px " + y + "px",
msTransformOrigin: x + "px " + y + "px",
oTransformOrigin: x + "px " + y + "px",
transformOrigin: x + "px " + y + "px"});},
DESTROY: function($super) {
clearTimeout(this.cssTransitionTimeout);
Effect.Queues.get("com.liquidpixels.zap.Tile").invoke("cancel");
this.removeTiles();
$super();},
toString: function() {
return "com.liquidpixels.zap.tiled.Image";}});
com.liquidpixels.zap.stitched.SimpleEngine = Class.create(com.liquidpixels.zap.SimpleEngine, {
setDefaults: function($super) {
$super();
Object.extend(this.options, {
zapManager:			com.liquidpixels.zap.stitched.Manager});},
toString: function() { return "com.liquidpixels.zap.stitched.SimpleEngine"; }});
com.liquidpixels.zap.tiled.SimpleEngine = Class.create(com.liquidpixels.zap.SimpleEngine, {
setDefaults: function($super) {
$super();
Object.extend(this.options, {
zapManager:			com.liquidpixels.zap.tiled.Manager/*,
canvasManager:		com.liquidpixels.zap.tiled.canvas.Manager*/});},
determineZapManager: function() {
var uaq = Application.get("uaq");
var zm;
zm = this.options.zapManager;
return zm;},
toString: function() { return "com.liquidpixels.zap.tiled.SimpleEngine"; }});
com.liquidpixels.Zoom = Class.create(com.liquidpixels.zap.Simple, {
setDefaults: function($super) {
$super();
var jsr = $H(com.liquidpixels.ResourceServer.Loaded.script).keys()[0] + ".jsr";
Object.extend(this.options, {
jsr: jsr});}});

